{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","options","objectMode","neuralNetwork","Error","dataFormatDetermined","i","size","count","sum","floodCallback","doneTrainingCallback","updateTrainingOptions","trainOpts","iterations","errorThresh","log","logPeriod","callbackPeriod","callback","on","finishStreamIteration","bind","write","chunk","enc","next","emit","addFormat","firstDatum","data","formatData","trainPattern","verifyIsInitialized","error","Writable"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\r\n\r\n/**\r\n *\r\n * @param opts\r\n * @returns {TrainStream}\r\n * @constructor\r\n */\r\nexport default class TrainStream extends Writable {\r\n  constructor(options) {\r\n    super({\r\n      objectMode: true\r\n    });\r\n\r\n    options = options || {};\r\n\r\n    // require the neuralNetwork\r\n    if (!options.neuralNetwork) {\r\n      throw new Error('no neural network specified');\r\n    }\r\n\r\n    const { neuralNetwork } = options;\r\n    this.neuralNetwork = neuralNetwork;\r\n    this.dataFormatDetermined = false;\r\n    this.i = 0; // keep track of internal iterations\r\n    this.size = 0;\r\n    this.count = 0;\r\n    this.sum = 0;\r\n    this.floodCallback = options.floodCallback;\r\n    this.doneTrainingCallback = options.doneTrainingCallback;\r\n\r\n    // inherit trainOpts settings from neuralNetwork\r\n    neuralNetwork.updateTrainingOptions(options);\r\n    const { trainOpts } = neuralNetwork;\r\n    this.iterations = trainOpts.iterations;\r\n    this.errorThresh = trainOpts.errorThresh;\r\n    this.log = trainOpts.log;\r\n    this.logPeriod = trainOpts.logPeriod;\r\n    this.callbackPeriod = trainOpts.callbackPeriod;\r\n    this.callback = trainOpts.callback;\r\n\r\n    this.on('finish', this.finishStreamIteration.bind(this));\r\n  }\r\n\r\n  endInputs() {\r\n    this.write(false);\r\n  }\r\n\r\n  /**\r\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\r\n   * @param chunk\r\n   * @param enc\r\n   * @param next\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _write(chunk, enc, next) {\r\n    if (!chunk) {\r\n      // check for the end of one iteration of the stream\r\n      this.emit('finish');\r\n      return next();\r\n    }\r\n\r\n    if (!this.dataFormatDetermined) {\r\n      this.size++;\r\n      this.neuralNetwork.addFormat(chunk);\r\n      this.firstDatum = this.firstDatum || chunk;\r\n      return next();\r\n    }\r\n\r\n    this.count++;\r\n\r\n    const data = this.neuralNetwork.formatData(chunk);\r\n    this.sum += this.neuralNetwork.trainPattern(data[0], true);\r\n\r\n    // tell the Readable Stream that we are ready for more data\r\n    next();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {*}\r\n   */\r\n  finishStreamIteration() {\r\n    if (this.dataFormatDetermined && this.size !== this.count) {\r\n      this.log('This iteration\\'s data length was different from the first.');\r\n    }\r\n\r\n    if (!this.dataFormatDetermined) {\r\n      const data = this.neuralNetwork.formatData(this.firstDatum);\r\n      this.neuralNetwork.verifyIsInitialized(data);\r\n      this.dataFormatDetermined = true;\r\n\r\n      if (typeof this.floodCallback === 'function') {\r\n        this.floodCallback();\r\n      }\r\n      return;\r\n    }\r\n\r\n    const error = this.sum / this.size;\r\n\r\n    if (this.log && (this.i % this.logPeriod === 0)) {\r\n      this.log(`iterations: ${ this.i}, training error: ${ error }`);\r\n    }\r\n    if (this.callback && (this.i % this.callbackPeriod === 0)) {\r\n      this.callback({\r\n        error: error,\r\n        iterations: this.i\r\n      });\r\n    }\r\n\r\n    this.sum = 0;\r\n    this.count = 0;\r\n    // update the iterations\r\n    this.i++;\r\n\r\n    // do a check here to see if we need the stream again\r\n    if (this.i < this.iterations && error > this.errorThresh) {\r\n      if (typeof this.floodCallback === 'function') {\r\n        return this.floodCallback();\r\n      }\r\n    } else {\r\n      // done training\r\n      if (typeof this.doneTrainingCallback === 'function') {\r\n        return this.doneTrainingCallback({\r\n          error: error,\r\n          iterations: this.i\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}