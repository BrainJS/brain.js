{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","opts","objectMode","neuralNetwork","Error","dataFormatDetermined","inputKeys","outputKeys","i","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","floodCallback","doneTrainingCallback","size","count","sum","on","finishStreamIteration","bind","chunk","enc","next","emit","uniques","slice","concat","Object","keys","input","output","firstDatum","data","formatData","trainDatum","datum","err","trainPattern","inputLookup","lookupFromArray","Array","isArray","outputLookup","sizes","inputSize","length","outputSize","hiddenSizes","push","Math","max","floor","forEach","unshift","initialize","error","arr","Set"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\nimport lookup from './lookup';\n\n/**\n *\n * @param opts\n * @returns {TrainStream}\n * @constructor\n */\nexport default class TrainStream extends Writable {\n  constructor(opts) {\n    super({\n      objectMode: true\n    });\n\n    opts = opts || {};\n\n    // require the neuralNetwork\n    if (!opts.neuralNetwork) {\n      throw new Error('no neural network specified');\n    }\n\n    this.neuralNetwork = opts.neuralNetwork;\n    this.dataFormatDetermined = false;\n\n    this.inputKeys = [];\n    this.outputKeys = []; // keeps track of keys seen\n    this.i = 0; // keep track of the for loop i variable that we got rid of\n    this.iterations = opts.iterations || 20000;\n    this.errorThresh = opts.errorThresh || 0.005;\n    this.log = opts.log ? (typeof opts.log === 'function' ? opts.log : console.log) : false;\n    this.logPeriod = opts.logPeriod || 10;\n    this.callback = opts.callback;\n    this.callbackPeriod = opts.callbackPeriod || 10;\n    this.floodCallback = opts.floodCallback;\n    this.doneTrainingCallback = opts.doneTrainingCallback;\n\n    this.size = 0;\n    this.count = 0;\n\n    this.sum = 0;\n\n    this.on('finish', this.finishStreamIteration.bind(this));\n\n    return this;\n  }\n\n  /**\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\n   * @param chunk\n   * @param enc\n   * @param next\n   * @returns {*}\n   * @private\n   */\n  _write(chunk, enc, next) {\n    if (!chunk) { // check for the end of one iteration of the stream\n      this.emit('finish');\n      return next();\n    }\n\n    if (!this.dataFormatDetermined) {\n      this.size++;\n      this.inputKeys = uniques(this.inputKeys.slice(0).concat(Object.keys(chunk.input)));\n      this.outputKeys = uniques(this.outputKeys.slice(0).concat(Object.keys(chunk.output)));\n      this.firstDatum = this.firstDatum || chunk;\n      return next();\n    }\n\n    this.count++;\n\n    let data = this.neuralNetwork.formatData(chunk);\n    this.trainDatum(data[0]);\n\n    // tell the Readable Stream that we are ready for more data\n    next();\n  }\n\n  /**\n   *\n   * @param datum\n   */\n  trainDatum(datum) {\n    let err = this.neuralNetwork.trainPattern(datum.input, datum.output);\n    this.sum += err;\n  }\n\n  /**\n   *\n   * @returns {*}\n   */\n  finishStreamIteration() {\n    if (this.dataFormatDetermined && this.size !== this.count) {\n      this.log('This iteration\\'s data length was different from the first.');\n    }\n\n    if (!this.dataFormatDetermined) {\n      // create the lookup\n      this.neuralNetwork.inputLookup = lookup.lookupFromArray(this.inputKeys);\n      if(!Array.isArray(this.firstDatum.output)){\n        this.neuralNetwork.outputLookup = lookup.lookupFromArray(this.outputKeys);\n      }\n\n      let data = this.neuralNetwork.formatData(this.firstDatum);\n      let sizes = [];\n      let inputSize = data[0].input.length;\n      let outputSize = data[0].output.length;\n      let hiddenSizes = this.hiddenSizes;\n      if (!hiddenSizes) {\n        sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n      } else {\n        hiddenSizes.forEach(size => {\n          sizes.push(size);\n        });\n      }\n\n      sizes.unshift(inputSize);\n      sizes.push(outputSize);\n\n      this.dataFormatDetermined = true;\n      this.neuralNetwork.initialize(sizes);\n\n      if (typeof this.floodCallback === 'function') {\n        this.floodCallback();\n      }\n      return;\n    }\n\n    let error = this.sum / this.size;\n\n    if (this.log && (this.i % this.logPeriod == 0)) {\n      this.log('iterations:', this.i, 'training error:', error);\n    }\n    if (this.callback && (this.i % this.callbackPeriod == 0)) {\n      this.callback({\n        error: error,\n        iterations: this.i\n      });\n    }\n\n    this.sum = 0;\n    this.count = 0;\n    // update the iterations\n    this.i++;\n\n    // do a check here to see if we need the stream again\n    if (this.i < this.iterations && error > this.errorThresh) {\n      if (typeof this.floodCallback === 'function') {\n        return this.floodCallback();\n      }\n    } else {\n      // done training\n      if (typeof this.doneTrainingCallback === 'function') {\n        return this.doneTrainingCallback({\n          error: error,\n          iterations: this.i\n        });\n      }\n    }\n  }\n}\n\n/**\n *\n * https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\n * @param arr\n * @returns {Array}\n */\nfunction uniques(arr) {\n  // Sets cannot contain duplicate elements, which is what we want\n  return [...new Set(arr)];\n}\n"]}