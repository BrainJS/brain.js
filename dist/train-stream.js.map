{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","opts","objectMode","neuralNetwork","Error","dataFormatDetermined","inputKeys","outputKeys","i","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","floodCallback","doneTrainingCallback","size","count","sum","on","finishStreamIteration","bind","chunk","enc","next","emit","uniques","slice","concat","Object","keys","input","output","firstDatum","data","formatData","trainDatum","datum","err","trainPattern","inputLookup","lookupFromArray","constructor","Array","outputLookup","sizes","inputSize","length","outputSize","hiddenSizes","push","Math","max","floor","forEach","unshift","initialize","error","arr","Set"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\r\nimport lookup from './lookup';\r\n\r\n/**\r\n *\r\n * @param opts\r\n * @returns {TrainStream}\r\n * @constructor\r\n */\r\nexport default class TrainStream extends Writable {\r\n  constructor(opts) {\r\n    super({\r\n      objectMode: true\r\n    });\r\n\r\n    opts = opts || {};\r\n\r\n    // require the neuralNetwork\r\n    if (!opts.neuralNetwork) {\r\n      throw new Error('no neural network specified');\r\n    }\r\n\r\n    this.neuralNetwork = opts.neuralNetwork;\r\n    this.dataFormatDetermined = false;\r\n\r\n    this.inputKeys = [];\r\n    this.outputKeys = []; // keeps track of keys seen\r\n    this.i = 0; // keep track of the for loop i variable that we got rid of\r\n    this.iterations = opts.iterations || 20000;\r\n    this.errorThresh = opts.errorThresh || 0.005;\r\n    this.log = opts.log ? (typeof opts.log === 'function' ? opts.log : console.log) : false;\r\n    this.logPeriod = opts.logPeriod || 10;\r\n    this.callback = opts.callback;\r\n    this.callbackPeriod = opts.callbackPeriod || 10;\r\n    this.floodCallback = opts.floodCallback;\r\n    this.doneTrainingCallback = opts.doneTrainingCallback;\r\n\r\n    this.size = 0;\r\n    this.count = 0;\r\n\r\n    this.sum = 0;\r\n\r\n    this.on('finish', this.finishStreamIteration.bind(this));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\r\n   * @param chunk\r\n   * @param enc\r\n   * @param next\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _write(chunk, enc, next) {\r\n    if (!chunk) { // check for the end of one iteration of the stream\r\n      this.emit('finish');\r\n      return next();\r\n    }\r\n\r\n    if (!this.dataFormatDetermined) {\r\n      this.size++;\r\n      this.inputKeys = uniques(this.inputKeys.slice(0).concat(Object.keys(chunk.input)));\r\n      this.outputKeys = uniques(this.outputKeys.slice(0).concat(Object.keys(chunk.output)));\r\n      this.firstDatum = this.firstDatum || chunk;\r\n      return next();\r\n    }\r\n\r\n    this.count++;\r\n\r\n    let data = this.neuralNetwork.formatData(chunk);\r\n    this.trainDatum(data[0]);\r\n\r\n    // tell the Readable Stream that we are ready for more data\r\n    next();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param datum\r\n   */\r\n  trainDatum(datum) {\r\n    let err = this.neuralNetwork.trainPattern(datum.input, datum.output);\r\n    this.sum += err;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {*}\r\n   */\r\n  finishStreamIteration() {\r\n    if (this.dataFormatDetermined && this.size !== this.count) {\r\n      this.log('This iteration\\'s data length was different from the first.');\r\n    }\r\n\r\n    if (!this.dataFormatDetermined) {\r\n      // create the lookup\r\n      this.neuralNetwork.inputLookup = lookup.lookupFromArray(this.inputKeys);\r\n      if(this.firstDatum.output.constructor !== Array){\r\n        this.neuralNetwork.outputLookup = lookup.lookupFromArray(this.outputKeys);\r\n      }\r\n\r\n      let data = this.neuralNetwork.formatData(this.firstDatum);\r\n      let sizes = [];\r\n      let inputSize = data[0].input.length;\r\n      let outputSize = data[0].output.length;\r\n      let hiddenSizes = this.hiddenSizes;\r\n      if (!hiddenSizes) {\r\n        sizes.push(Math.max(3, Math.floor(inputSize / 2)));\r\n      } else {\r\n        hiddenSizes.forEach(size => {\r\n          sizes.push(size);\r\n        });\r\n      }\r\n\r\n      sizes.unshift(inputSize);\r\n      sizes.push(outputSize);\r\n\r\n      this.dataFormatDetermined = true;\r\n      this.neuralNetwork.initialize(sizes);\r\n\r\n      if (typeof this.floodCallback === 'function') {\r\n        this.floodCallback();\r\n      }\r\n      return;\r\n    }\r\n\r\n    let error = this.sum / this.size;\r\n\r\n    if (this.log && (this.i % this.logPeriod == 0)) {\r\n      this.log('iterations:', this.i, 'training error:', error);\r\n    }\r\n    if (this.callback && (this.i % this.callbackPeriod == 0)) {\r\n      this.callback({\r\n        error: error,\r\n        iterations: this.i\r\n      });\r\n    }\r\n\r\n    this.sum = 0;\r\n    this.count = 0;\r\n    // update the iterations\r\n    this.i++;\r\n\r\n    // do a check here to see if we need the stream again\r\n    if (this.i < this.iterations && error > this.errorThresh) {\r\n      if (typeof this.floodCallback === 'function') {\r\n        return this.floodCallback();\r\n      }\r\n    } else {\r\n      // done training\r\n      if (typeof this.doneTrainingCallback === 'function') {\r\n        return this.doneTrainingCallback({\r\n          error: error,\r\n          iterations: this.i\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\r\n * @param arr\r\n * @returns {Array}\r\n */\r\nfunction uniques(arr) {\r\n  // Sets cannot contain duplicate elements, which is what we want\r\n  return [...new Set(arr)];\r\n}\r\n"]}