// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"4I3O":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activate = activate;
exports.measure = measure;
/**
 * Leaky Relu Activation, aka Leaky Rectified Linear Unit Activation
 * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
 * @param weight
 * @returns {number}
 */

function activate(weight) {
  return weight > 0 ? weight : 0.01 * weight;
}
/**
 * Leaky Relu derivative
 * @param weight
 * @param delta
 * @returns {number}
 */


function measure(weight, error) {
  return weight > 0 ? error : 0.01 * error;
}
},{}],"kBu/":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activate = activate;
exports.measure = measure;
/**
 * Relu Activation, aka Rectified Linear Unit Activation
 * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
 * @param weight
 * @returns {number}
 */

function activate(weight) {
  return Math.max(0, weight);
}
/**
 * Leaky Relu derivative
 * @param weight
 * @param delta
 * @returns {number}
 */


function measure(weight, delta) {
  if (weight <= 0) {
    return 0;
  }

  return delta;
}
},{}],"thFH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.activate = activate;
exports.measure = measure;
/**
 * sigmoid activation
 * @param value
 * @returns {number}
 */

function activate(value) {
  return 1 / (1 + Math.exp(-value));
}
/**
 * sigmoid derivative
 * @param weight
 * @param error
 * @returns {number}
 */


function measure(weight, error) {
  return weight * (1 - weight) * error;
}
},{}],"v3/M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tanh = tanh;
exports.tanhDerivative = tanhDerivative;
/**
 *
 * @param weight
 * @returns {number}
 */

function tanh(weight) {
  return Math.tanh(weight);
}
/**
 * @description grad for z = tanh(x) is (1 - z^2)
 * @param weight
 * @param error
 * @returns {number}
 */


function tanhDerivative(weight, error) {
  return (1 - weight * weight) * error;
}
},{}],"l4U/":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _leakyRelu = require('./leaky-relu');

var leakyRelu = _interopRequireWildcard(_leakyRelu);

var _relu = require('./relu');

var relu = _interopRequireWildcard(_relu);

var _sigmoid = require('./sigmoid');

var sigmoid = _interopRequireWildcard(_sigmoid);

var _tanh = require('./tanh');

var tanh = _interopRequireWildcard(_tanh);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

exports.default = {
  leakyRelu: leakyRelu,
  relu: relu,
  sigmoid: sigmoid,
  tanh: tanh
};
},{"./leaky-relu":"4I3O","./relu":"kBu/","./sigmoid":"thFH","./tanh":"v3/M"}],"+wYj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testPartition = testPartition;
exports.shuffleArray = shuffleArray;
exports.default = crossValidate;
/**
 *
 * @param {NeuralNetwork|constructor} Classifier
 * @param {object} opts
 * @param {object} trainOpts
 * @param {object} trainSet
 * @param {object} testSet
 * @returns {void|*}
 */

function testPartition(Classifier, opts, trainOpts, trainSet, testSet) {
  var classifier = new Classifier(opts);
  var beginTrain = Date.now();
  var trainingStats = classifier.train(trainSet, trainOpts);
  var beginTest = Date.now();
  var testStats = classifier.test(testSet);
  var endTest = Date.now();
  var stats = Object.assign({}, testStats, {
    trainTime: beginTest - beginTrain,
    testTime: endTest - beginTest,
    iterations: trainingStats.iterations,
    trainError: trainingStats.error,
    learningRate: trainOpts.learningRate,
    hidden: classifier.hiddenSizes,
    network: classifier.toJSON()
  });
  return stats;
}
/**
 * Randomize array element order in-place.
 * Using Durstenfeld shuffle algorithm.
 * source: http://stackoverflow.com/a/12646864/1324039
 */


function shuffleArray(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

  return array;
}
/**
 *
 * @param {NeuralNetwork|constructor} Classifier
 * @param {object} data
 * @param {object} opts
 * @param {object} trainOpts
 * @param {number} k
 * @returns {
 *  {
 *    avgs: {
 *      error: number,
 *      trainTime: number,
 *      testTime: number,
 *      iterations: number,
 *      trainError: number
 *    },
 *    stats: {
 *      truePos: number,
 *      trueNeg: number,
 *      falsePos: number,
 *      falseNeg: number,
 *      total: number
 *    },
 *    sets: Array,
 *    misclasses: Array
 *  }
 * }
 */


function crossValidate(Classifier, data, opts, trainOpts, k) {
  k = k || 4;
  var size = data.length / k;

  if (data.constructor === Array) {
    shuffleArray(data);
  } else {
    var newData = {};
    shuffleArray(Object.keys(data)).forEach(function (key) {
      newData[key] = data[key];
    });
    data = newData;
  }

  var avgs = {
    error: 0,
    trainTime: 0,
    testTime: 0,
    iterations: 0,
    trainError: 0
  };
  var stats = {
    truePos: 0,
    trueNeg: 0,
    falsePos: 0,
    falseNeg: 0,
    total: 0
  };
  var misclasses = [];
  var results = [];

  var _loop = function _loop(i) {
    var dclone = data.slice(0);
    var testSet = dclone.splice(i * size, size);
    var trainSet = dclone;
    var result = testPartition(Classifier, opts, trainOpts, trainSet, testSet);
    Object.keys(avgs).forEach(function (avg) {
      avgs[avg] += result[avg];
    });
    Object.keys(stats).forEach(function (stat) {
      stats[stat] += result[stat];
    });
    misclasses.concat(results.misclasses);
    results.push(result);
  };

  for (var i = 0; i < k; i++) {
    _loop(i);
  }

  Object.keys(avgs).forEach(function (avg) {
    avgs[avg] /= k;
  });
  stats.precision = stats.truePos / (stats.truePos + stats.falsePos);
  stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);
  stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;
  stats.testSize = size;
  stats.trainSize = data.length - size;
  return {
    avgs: avgs,
    stats: stats,
    sets: results,
    misclasses: misclasses
  };
}
},{}],"/T23":[function(require,module,exports) {
'use strict';

function mock1D() {
  const row = [];
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row.push(this._fn.apply(this, arguments));
  }
  return row;
}

function mock2D() {
  const matrix = [];
  for (let y = 0; y < this.output.y; y++) {
    const row = [];
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row.push(this._fn.apply(this, arguments));
    }
    matrix.push(row);
  }
  return matrix;
}

function mock3D() {
  const cube = [];
  for (let z = 0; z < this.output.z; z++) {
    const matrix = [];
    for (let y = 0; y < this.output.y; y++) {
      const row = [];
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row.push(this._fn.apply(this, arguments));
      }
      matrix.push(row);
    }
    cube.push(matrix);
  }
  return cube;
}

module.exports = function gpuMock(fn, options) {
  let contextOutput = null;
  if (options.output.length) {
    if (options.output.length === 3) {
      contextOutput = { x: options.output[0], y: options.output[1], z: options.output[2] };
    } else if (options.output.length === 2) {
      contextOutput = { x: options.output[0], y: options.output[1] };
    } else {
      contextOutput = { x: options.output[0] };
    }
  } else {
    contextOutput = options.output;
  }

  const context = {
    _fn: fn,
    constants: options.constants,
    output: contextOutput,
    thread: {
      x: 0,
      y: 0,
      z: 0
    }
  };

  if (contextOutput.z) {
    return mock3D.bind(context);
  } else if (contextOutput.y) {
    return mock2D.bind(context);
  } else {
    return mock1D.bind(context);
  }
};

},{}],"Wqy/":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.addLooseExports = addLooseExports;
exports.getLineInfo = getLineInfo;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierStart = isIdentifierStart;
exports.isNewLine = isNewLine;
exports.nonASCIIwhitespace = exports.lineBreakG = exports.lineBreak = exports.Token = exports.tokContexts = exports.TokContext = exports.keywordTypes = exports.tokTypes = exports.TokenType = exports.Node = exports.SourceLocation = exports.Position = exports.defaultOptions = exports.plugins = exports.Parser = exports.pluginsLoose = exports.LooseParser = exports.parse_dammit = exports.version = void 0;
// Reserved word lists for various dialects of the language
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}; // And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing

var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; // eslint-disable-next-line comma-spacing

var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];

    if (pos > code) {
      return false;
    }

    pos += set[i + 1];

    if (pos >= code) {
      return true;
    }
  }
} // Test whether a given character code starts an identifier.


function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
} // Test whether a given character is part of an identifier.


function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }

  if (code < 58) {
    return true;
  }

  if (code < 65) {
    return false;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
} // ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.


var TokenType = function TokenType(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, {
    beforeExpr: true,
    binop: prec
  });
}

var beforeExpr = {
  beforeExpr: true
};
var startsExpr = {
  startsExpr: true
}; // Map keyword names to token types.

var keywords$1 = {}; // Succinct definitions of keyword token types

exports.keywordTypes = keywords$1;

function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options);
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", {
    beforeExpr: true,
    startsExpr: true
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr: true,
    startsExpr: true
  }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {
    beforeExpr: true,
    startsExpr: true
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {
    beforeExpr: true,
    startsExpr: true
  }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", {
    beforeExpr: true,
    isAssign: true
  }),
  assign: new TokenType("_=", {
    beforeExpr: true,
    isAssign: true
  }),
  incDec: new TokenType("++/--", {
    prefix: true,
    postfix: true,
    startsExpr: true
  }),
  prefix: new TokenType("!/~", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr: true,
    binop: 9,
    prefix: true,
    startsExpr: true
  }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {
    beforeExpr: true
  }),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {
    isLoop: true,
    beforeExpr: true
  }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {
    isLoop: true
  }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {
    isLoop: true
  }),
  _with: kw("with"),
  _new: kw("new", {
    beforeExpr: true,
    startsExpr: true
  }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {
    beforeExpr: true,
    binop: 7
  }),
  _instanceof: kw("instanceof", {
    beforeExpr: true,
    binop: 7
  }),
  _typeof: kw("typeof", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _void: kw("void", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _delete: kw("delete", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  })
}; // Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

exports.tokTypes = types;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");
exports.lineBreakG = lineBreakG;

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString; // Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}

var isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
}; // These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.


var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

exports.Position = Position;

Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;

  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
}; // The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.


exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);

    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
} // A second optional argument can be given to further configure
// the parser process. These options are recognized:


var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
}; // Interpret and default an options object

exports.defaultOptions = defaultOptions;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions) {
    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }

  if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;

    options.onToken = function (token) {
      return tokens.push(token);
    };
  }

  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };

    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }

    if (options.ranges) {
      comment.range = [start, end];
    }

    array.push(comment);
  };
} // Registered plugins


var plugins = {};
exports.plugins = plugins;

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";

  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--) {
      if (reserved = reservedWords[v]) {
        break;
      }
    }

    if (options.sourceType === "module") {
      reserved += " await";
    }
  }

  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input); // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  this.containsEsc = false; // Load plugins

  this.loadPlugins(options.plugins); // Set up token state
  // The current position of the tokenizer in the input.

  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  } // Properties of the current token:
  // Its type


  this.type = types.eof; // For tokens that include more information than their type, the value

  this.value = null; // Its start and end offset

  this.start = this.end = this.pos; // And, if locations are used, the {line, column} object
  // corresponding to those offsets

  this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token

  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.

  this.context = this.initialContext();
  this.exprAllowed = true; // Figure out if it's a module code.

  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function

  this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator, an async function.

  this.inFunction = this.inGenerator = this.inAsync = false; // Positions to delayed-check that yield/await does not exist in default parameters.

  this.yieldPos = this.awaitPos = 0; // Labels in scope.

  this.labels = []; // If enabled, skip leading hashbang line.

  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  } // Scope tracking for duplicate variable names (see scope.js)


  this.scopeStack = [];
  this.enterFunctionScope(); // For RegExp validation

  this.regexpState = null;
}; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them


exports.Parser = Parser;

Parser.prototype.isKeyword = function isKeyword(word) {
  return this.keywords.test(word);
};

Parser.prototype.isReservedWord = function isReservedWord(word) {
  return this.reservedWords.test(word);
};

Parser.prototype.extend = function extend(name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
  var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];

    if (!plugin) {
      throw new Error("Plugin '" + name + "' not found");
    }

    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};

var pp = Parser.prototype; // ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;

pp.strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));

    if (!match) {
      return false;
    }

    if ((match[1] || match[2]) === "use strict") {
      return true;
    }

    start += match[0].length;
  }
}; // Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.


pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
}; // Tests whether parsed token is a contextual keyword.


pp.isContextual = function (name) {
  return this.type === types.name && this.value === name && !this.containsEsc;
}; // Consumes contextual keyword if possible.


pp.eatContextual = function (name) {
  if (!this.isContextual(name)) {
    return false;
  }

  this.next();
  return true;
}; // Asserts that following token is given contextual keyword.


pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
}; // Test whether a semicolon can be inserted at the current position.


pp.canInsertSemicolon = function () {
  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }

    return true;
  }
}; // Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.


pp.semicolon = function () {
  if (!this.eat(types.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};

pp.afterTrailingComma = function (tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }

    if (!notNext) {
      this.next();
    }

    return true;
  }
}; // Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.


pp.expect = function (type) {
  this.eat(type) || this.unexpected();
}; // Raise an unexpected token error.


pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}

pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }

  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }

  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;

  if (parens > -1) {
    this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }

  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;

  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }

  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }

  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};

pp.checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }

  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};

pp.isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }

  return expr.type === "Identifier" || expr.type === "MemberExpression";
};

var pp$1 = Parser.prototype; // ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (node) {
  var this$1 = this;
  var exports = {};

  if (!node.body) {
    node.body = [];
  }

  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }

  this.adaptDirectivePrologue(node.body);
  this.next();

  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }

  return this.finishNode(node, "Program");
};

var loopLabel = {
  kind: "loop"
};
var switchLabel = {
  kind: "switch"
};

pp$1.isLet = function () {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);

  if (nextCh === 91 || nextCh === 123) {
    return true;
  } // '{' and '['


  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;

    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
      ++pos;
    }

    var ident = this.input.slice(next, pos);

    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }

  return false;
}; // check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.


pp$1.isAsyncFunction = function () {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
}; // Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.


pp$1.parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type,
      node = this.startNode(),
      kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = "let";
  } // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.


  switch (starttype) {
    case types._break:
    case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);

    case types._debugger:
      return this.parseDebuggerStatement(node);

    case types._do:
      return this.parseDoStatement(node);

    case types._for:
      return this.parseForStatement(node);

    case types._function:
      if (!declaration && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }

      return this.parseFunctionStatement(node, false);

    case types._class:
      if (!declaration) {
        this.unexpected();
      }

      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);

    case types._return:
      return this.parseReturnStatement(node);

    case types._switch:
      return this.parseSwitchStatement(node);

    case types._throw:
      return this.parseThrowStatement(node);

    case types._try:
      return this.parseTryStatement(node);

    case types._const:
    case types._var:
      kind = kind || this.value;

      if (!declaration && kind !== "var") {
        this.unexpected();
      }

      return this.parseVarStatement(node, kind);

    case types._while:
      return this.parseWhileStatement(node);

    case types._with:
      return this.parseWithStatement(node);

    case types.braceL:
      return this.parseBlock();

    case types.semi:
      return this.parseEmptyStatement(node);

    case types._export:
    case types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }

      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.

    default:
      if (this.isAsyncFunction()) {
        if (!declaration) {
          this.unexpected();
        }

        this.next();
        return this.parseFunctionStatement(node, true);
      }

      var maybeName = this.value,
          expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr);
      } else {
        return this.parseExpressionStatement(node, expr);
      }

  }
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;
  var isBreak = keyword === "break";
  this.next();

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  } // Verify that there is an actual destination to break or
  // continue to.


  var i = 0;

  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];

    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }

      if (node.label && isBreak) {
        break;
      }
    }
  }

  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }

  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();

  if (this.options.ecmaVersion >= 6) {
    this.eat(types.semi);
  } else {
    this.semicolon();
  }

  return this.finishNode(node, "DoWhileStatement");
}; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.


pp$1.parseForStatement = function (node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);

  if (this.type === types.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, null);
  }

  var isLet = this.isLet();

  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");

    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 && !(kind !== "var" && init$1.declarations[0].init)) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }

      return this.parseForIn(node, init$1);
    }

    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, init$1);
  }

  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(true, refDestructuringErrors);

  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }

    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }

  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }

  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode

  node.consequent = this.parseStatement(!this.strict && this.type === types._function);
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }

  this.next(); // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  var this$1 = this;
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope(); // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;

  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;

      if (cur) {
        this$1.finishNode(cur, "SwitchCase");
      }

      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();

      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) {
          this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
        }

        sawDefault = true;
        cur.test = null;
      }

      this$1.expect(types.colon);
    } else {
      if (!cur) {
        this$1.unexpected();
      }

      cur.consequent.push(this$1.parseStatement(true));
    }
  }

  this.exitLexicalScope();

  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }

  this.next(); // Closing brace

  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();

  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }

  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
}; // Reused empty array added for node fields that are always empty.


var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;

  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();

    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      this.enterLexicalScope();
      this.checkLVal(clause.param, "let");
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }

      clause.param = null;
      this.enterLexicalScope();
    }

    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }

  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];

    if (label.name === maybeName) {
      this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;

  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];

    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }

  this.labels.push({
    name: maybeName,
    kind: kind,
    statementStart: this.start
  });
  node.body = this.parseStatement(true);

  if (node.body.type === "ClassDeclaration" || node.body.type === "VariableDeclaration" && node.body.kind !== "var" || node.body.type === "FunctionDeclaration" && (this.strict || node.body.generator || node.body.async)) {
    this.raiseRecoverable(node.body.start, "Invalid labeled declaration");
  }

  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
}; // Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).


pp$1.parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);

  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }

  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }

  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }

  return this.finishNode(node, "BlockStatement");
}; // Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.


pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
}; // Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.


pp$1.parseForIn = function (node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();

  if (type === "ForInStatement") {
    if (init.type === "AssignmentPattern" || init.type === "VariableDeclaration" && init.declarations[0].init != null && (this.strict || init.declarations[0].id.type !== "Identifier")) {
      this.raise(init.start, "Invalid assignment in for-in loop head");
    }
  }

  node.left = init;
  node.right = type === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
}; // Parse a list of variable declarations.


pp$1.parseVar = function (node, isFor, kind) {
  var this$1 = this;
  node.declarations = [];
  node.kind = kind;

  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);

    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual("of"))) {
      this$1.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }

    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));

    if (!this$1.eat(types.comma)) {
      break;
    }
  }

  return node;
};

pp$1.parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
}; // Parse a function declaration or literal (depending on the
// `isStatement` parameter).


pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);

  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    node.generator = this.eat(types.star);
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  if (isStatement) {
    node.id = isStatement === "nullableID" && this.type !== types.name ? null : this.parseIdent();

    if (node.id) {
      this.checkLVal(node.id, this.inModule && !this.inFunction ? "let" : "var");
    }
  }

  var oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement) {
    node.id = this.type === types.name ? this.parseIdent() : null;
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
}; // Parse a class declaration or literal (depending on the
// `isStatement` parameter).


pp$1.parseClass = function (node, isStatement) {
  var this$1 = this;
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    var member = this$1.parseClassMember(classBody);

    if (member && member.type === "MethodDefinition" && member.kind === "constructor") {
      if (hadConstructor) {
        this$1.raise(member.start, "Duplicate constructor in the same class");
      }

      hadConstructor = true;
    }
  }

  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.parseClassMember = function (classBody) {
  var this$1 = this;

  if (this.eat(types.semi)) {
    return null;
  }

  var method = this.startNode();

  var tryContextual = function (k, noLineBreak) {
    if (noLineBreak === void 0) noLineBreak = false;
    var start = this$1.start,
        startLoc = this$1.startLoc;

    if (!this$1.eatContextual(k)) {
      return false;
    }

    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
      return true;
    }

    if (method.key) {
      this$1.unexpected();
    }

    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false;
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;

  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }

  if (!method.key) {
    this.parsePropertyName(method);
  }

  var key = method.key;

  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") {
      this.raise(key.start, "Constructor can't have get/set modifier");
    }

    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }

    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }

    method.kind = "constructor";
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  this.parseClassMethod(classBody, method, isGenerator, isAsync);

  if (method.kind === "get" && method.value.params.length !== 0) {
    this.raiseRecoverable(method.value.start, "getter should have no params");
  }

  if (method.kind === "set" && method.value.params.length !== 1) {
    this.raiseRecoverable(method.value.start, "setter should have exactly one param");
  }

  if (method.kind === "set" && method.value.params[0].type === "RestElement") {
    this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
  }

  return method;
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function (node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}; // Parses module export declaration.


pp$1.parseExport = function (node, exports) {
  var this$1 = this;
  this.next(); // export * from '...'

  if (this.eat(types.star)) {
    this.expectContextual("from");

    if (this.type !== types.string) {
      this.unexpected();
    }

    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }

  if (this.eat(types._default)) {
    // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;

    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();

      if (isAsync) {
        this.next();
      }

      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }

    return this.finishNode(node, "ExportDefaultDeclaration");
  } // export var|const|let|function|class ...


  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);

    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
    }

    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);

    if (this.eatContextual("from")) {
      if (this.type !== types.string) {
        this.unexpected();
      }

      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }

    this.semicolon();
  }

  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.checkExport = function (exports, name, pos) {
  if (!exports) {
    return;
  }

  if (has(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }

  exports[name] = true;
};

pp$1.checkPatternExport = function (exports, pat) {
  var this$1 = this;
  var type = pat.type;

  if (type === "Identifier") {
    this.checkExport(exports, pat.name, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this$1.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

      if (elt) {
        this$1.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};

pp$1.checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) {
    return;
  }

  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function () {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
}; // Parses a comma-separated list of module exports.


pp$1.parseExportSpecifiers = function (exports) {
  var this$1 = this;
  var nodes = [],
      first = true; // export { x, y as z } [from '...']

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }

  return nodes;
}; // Parses import declaration.


pp$1.parseImport = function (node) {
  this.next(); // import '...'

  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }

  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
}; // Parses a comma-separated list of module imports.


pp$1.parseImportSpecifiers = function () {
  var this$1 = this;
  var nodes = [],
      first = true;

  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, "let");
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));

    if (!this.eat(types.comma)) {
      return nodes;
    }
  }

  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, "let");
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);

    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }

    this$1.checkLVal(node$2.local, "let");
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }

  return nodes;
}; // Set `ExpressionStatement#directive` property for directive prologues.


pp$1.adaptDirectivePrologue = function (statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};

pp$1.isDirectiveCandidate = function (statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && ( // Reject parenthesized strings.
  this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};

var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Can not use 'await' as identifier inside an async function");
        }

        break;

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this$1.toAssignable(prop, isBinding); // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.

          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this$1.raise(prop.argument.start, "Unexpected token");
          }
        }

        break;

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }

        this.toAssignable(node.value, isBinding);
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        this.toAssignableList(node.elements, isBinding);
        break;

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);

        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }

        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }

        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

      case "AssignmentPattern":
        break;

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) {
          break;
        }

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }

  return node;
}; // Convert list of expression atoms to binding list.


pp$2.toAssignableList = function (exprList, isBinding) {
  var this$1 = this;
  var end = exprList.length;

  for (var i = 0; i < end; i++) {
    var elt = exprList[i];

    if (elt) {
      this$1.toAssignable(elt, isBinding);
    }
  }

  if (end) {
    var last = exprList[end - 1];

    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }

  return exprList;
}; // Parses spread element.


pp$2.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRestBinding = function () {
  var node = this.startNode();
  this.next(); // RestElement inside of a function parameter must be an identifier

  if (this.options.ecmaVersion === 6 && this.type !== types.name) {
    this.unexpected();
  }

  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
}; // Parses lvalue (assignable) atom.


pp$2.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");

      case types.braceL:
        return this.parseObj(true);
    }
  }

  return this.parseIdent();
};

pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var this$1 = this;
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this$1.expect(types.comma);
    }

    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break;
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);

      if (this$1.type === types.comma) {
        this$1.raise(this$1.start, "Comma is not permitted after the rest element");
      }

      this$1.expect(close);
      break;
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }

  return elts;
};

pp$2.parseBindingListItem = function (param) {
  return param;
}; // Parses assignment pattern around given atom if possible.


pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();

  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
    return left;
  }

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
}; // Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references


pp$2.checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }

      if (checkClashes) {
        if (has(checkClashes, expr.name)) {
          this.raiseRecoverable(expr.start, "Argument name clash");
        }

        checkClashes[expr.name] = true;
      }

      if (bindingType && bindingType !== "none") {
        if (bindingType === "var" && !this.canDeclareVarName(expr.name) || bindingType !== "var" && !this.canDeclareLexicalName(expr.name)) {
          this.raiseRecoverable(expr.start, "Identifier '" + expr.name + "' has already been declared");
        }

        if (bindingType === "var") {
          this.declareVarName(expr.name);
        } else {
          this.declareLexicalName(expr.name);
        }
      }

      break;

    case "MemberExpression":
      if (bindingType) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }

      break;

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this$1.checkLVal(prop, bindingType, checkClashes);
      }

      break;

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break;

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

        if (elem) {
          this$1.checkLVal(elem, bindingType, checkClashes);
        }
      }

      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break;

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
}; // A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


var pp$3 = Parser.prototype; // Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }

  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }

  var key = prop.key;
  var name;

  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;

    case "Literal":
      name = String(key.value);
      break;

    default:
      return;
  }

  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {
          refDestructuringErrors.doubleProto = key.start;
        } // Backwards-compat kludge. Can be removed in version 6.0
        else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
      }

      propHash.proto = true;
    }

    return;
  }

  name = "$" + name;
  var other = propHash[name];

  if (other) {
    var redefinition;

    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }

    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }

  other[kind] = true;
}; // ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).


pp$3.parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);

  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];

    while (this.eat(types.comma)) {
      node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
    }

    return this.finishNode(node, "SequenceExpression");
  }

  return expr;
}; // Parse an assignment expression. This includes applications of
// operators like `+=`.


pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) {
    return this.parseYield();
  }

  var ownDestructuringErrors = false,
      oldParenAssign = -1,
      oldTrailingComma = -1;

  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }

  var startPos = this.start,
      startLoc = this.startLoc;

  if (this.type === types.parenL || this.type === types.name) {
    this.potentialArrowAt = this.start;
  }

  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);

  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }

  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;

    if (!ownDestructuringErrors) {
      DestructuringErrors.call(refDestructuringErrors);
    }

    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly

    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }

  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }

  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }

  return left;
}; // Parse a ternary conditional (`?:`) operator.


pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }

  return expr;
}; // Start the precedence parser.


pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
}; // Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.


pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;

  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }

  return left;
};

pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
}; // Parse unary operators, both prefix and postfix.


pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc,
      expr;

  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (update) {
      this.checkLVal(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else {
      sawUnary = true;
    }

    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);

    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }

    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar)) {
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
  } else {
    return expr;
  }
}; // Parse call, dot, and `[]`-subscript expressions.


pp$3.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";

  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
    return expr;
  }

  var result = this.parseSubscripts(expr, startPos, startLoc);

  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }

    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
  }

  return result;
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";

  for (var computed = void 0;;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;

      if (computed) {
        this$1.expect(types.bracketR);
      }

      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(),
          oldYieldPos = this$1.yieldPos,
          oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);

      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);
      }

      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({
        isTagged: true
      });
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
}; // Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.


pp$3.parseExprAtom = function (refDestructuringErrors) {
  var node,
      canBeArrow = this.potentialArrowAt === this.start;

  switch (this.type) {
    case types._super:
      if (!this.inFunction) {
        this.raise(this.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next(); // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super Arguments

      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
        this.unexpected();
      }

      return this.finishNode(node, "Super");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types.name:
      var startPos = this.start,
          startLoc = this.startLoc,
          containsEsc = this.containsEsc;
      var id = this.parseIdent(this.type !== types.name);

      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
        return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);
      }

      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
        }

        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent();

          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
            this.unexpected();
          }

          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
        }
      }

      return id;

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {
        pattern: value.pattern,
        flags: value.flags
      };
      return node;

    case types.num:
    case types.string:
      return this.parseLiteral(this.value);

    case types._null:
    case types._true:
    case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case types.parenL:
      var start = this.start,
          expr = this.parseParenAndDistinguishExpression(canBeArrow);

      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }

        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }

      return expr;

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case types._class:
      return this.parseClass(this.startNode(), false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp$3.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc,
      val,
      allowTrailingComma = this.options.ecmaVersion >= 8;

  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true,
        lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;

    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);

      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));

        if (this$1.type === types.comma) {
          this$1.raise(this$1.start, "Comma is not permitted after the rest element");
        }

        break;
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }

    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }

    if (spreadStart) {
      this.unexpected(spreadStart);
    }

    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp$3.parseParenItem = function (item) {
  return item;
};

pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
}; // New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.


var empty$1 = [];

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);

  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "target" || containsEsc) {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    }

    if (!this.inFunction) {
      this.raiseRecoverable(node.start, "new.target can only be used in functions");
    }

    return this.finishNode(node, "MetaProperty");
  }

  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty$1;
  }

  return this.finishNode(node, "NewExpression");
}; // Parse template expression.


pp$3.parseTemplateElement = function (ref) {
  var isTagged = ref.isTagged;
  var elem = this.startNode();

  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }

    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }

  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var isTagged = ref.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({
    isTagged: isTagged
  });
  node.quasis = [curElt];

  while (!curElt.tail) {
    if (this$1.type === types.eof) {
      this$1.raise(this$1.pos, "Unterminated template literal");
    }

    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({
      isTagged: isTagged
    }));
  }

  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp$3.isAsyncProp = function (prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
}; // Parse an object literal or binding pattern.


pp$3.parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);

    if (!isPattern) {
      this$1.checkPropClash(prop, propHash, refDestructuringErrors);
    }

    node.properties.push(prop);
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
  var prop = this.startNode(),
      isGenerator,
      isAsync,
      startPos,
      startLoc;

  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);

      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }

      return this.finishNode(prop, "RestElement");
    } // To disallow parenthesized identifier via `this.toAssignable()`.


    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }

      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    } // Parse argument.


    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.

    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    } // Finish


    return this.finishNode(prop, "SpreadElement");
  }

  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }
  }

  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);

  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }

  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};

pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon) {
    this.unexpected();
  }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) {
      this.unexpected();
    }

    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }

    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;

    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;

      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";

    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }

      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }

    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};

pp$3.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }

  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);
}; // Initialize empty function node.


pp$3.initFunction = function (node) {
  node.id = null;

  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
}; // Parse object or class method.


pp$3.parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(),
      oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.initFunction(node);

  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression");
}; // Parse arrow function expression with given parameters.


pp$3.parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.enterFunctionScope();
  this.initFunction(node);

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression");
}; // Parse function body and check parameters.


pp$3.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict,
      useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);

    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.

      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    } // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).


    var oldLabels = this.labels;
    this.labels = [];

    if (useStrict) {
      this.strict = true;
    } // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.


    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }

  this.exitFunctionScope();

  if (this.strict && node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none");
  }

  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function (params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];

    if (param.type !== "Identifier") {
      return false;
    }
  }

  return true;
}; // Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.


pp$3.checkParams = function (node, allowDuplicates) {
  var this$1 = this;
  var nameHash = {};

  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
}; // Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).


pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);

      if (allowTrailingComma && this$1.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }

    var elt = void 0;

    if (allowEmpty && this$1.type === types.comma) {
      elt = null;
    } else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);

      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this$1.start;
      }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }

    elts.push(elt);
  }

  return elts;
};

pp$3.checkUnreserved = function (ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator");
  }

  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function");
  }

  if (this.isKeyword(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }

  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }

  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;

  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function");
    }

    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
}; // Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.


pp$3.parseIdent = function (liberal, isBinding) {
  var node = this.startNode();

  if (liberal && this.options.allowReserved === "never") {
    liberal = false;
  }

  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword

    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }

  this.next();
  this.finishNode(node, "Identifier");

  if (!liberal) {
    this.checkUnreserved(node);
  }

  return node;
}; // Parses yield expression inside generator.


pp$3.parseYield = function () {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }

  var node = this.startNode();
  this.next();

  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }

  return this.finishNode(node, "YieldExpression");
};

pp$3.parseAwait = function () {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression");
};

var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function () {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};

var pp$5 = Parser.prototype; // Object.assign polyfill

var assign = Object.assign || function (target) {
  var sources = [],
      len = arguments.length - 1;

  while (len-- > 0) sources[len] = arguments[len + 1];

  for (var i = 0, list = sources; i < list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.


pp$5.enterFunctionScope = function () {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({
    var: {},
    lexical: {},
    childVar: {},
    parentLexical: {}
  });
};

pp$5.exitFunctionScope = function () {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {
    var: {},
    lexical: {},
    childVar: {},
    parentLexical: {}
  };
  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function () {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  assign(parentScope.childVar, childScope.var, childScope.childVar);
};
/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */


pp$5.canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];
  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);
};
/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */


pp$5.canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];
  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);
};

pp$5.declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;

  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }

  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }

  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
}; // Start an AST node, attaching a start offset.


exports.Node = Node;
var pp$6 = Parser.prototype;

pp$6.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp$6.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
}; // Finish an AST node, adding `type` and `end` properties.


function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;

  if (this.options.locations) {
    node.loc.end = loc;
  }

  if (this.options.ranges) {
    node.range[1] = pos;
  }

  return node;
}

pp$6.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
}; // Finish node at given position


pp$6.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
}; // The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

exports.TokContext = TokContext;
var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
exports.tokContexts = types$1;
var pp$7 = Parser.prototype;

pp$7.initialContext = function () {
  return [types$1.b_stat];
};

pp$7.braceIsBlock = function (prevType) {
  var parent = this.curContext();

  if (parent === types$1.f_expr || parent === types$1.f_stat) {
    return true;
  }

  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
    return !parent.isExpr;
  } // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.


  if (prevType === types._return || prevType === types.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }

  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
    return true;
  }

  if (prevType === types.braceL) {
    return parent === types$1.b_stat;
  }

  if (prevType === types._var || prevType === types.name) {
    return false;
  }

  return !this.exprAllowed;
};

pp$7.inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];

    if (context.token === "function") {
      return context.generator;
    }
  }

  return false;
};

pp$7.updateContext = function (prevType) {
  var update,
      type = this.type;

  if (type.keyword && prevType === types.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
}; // Token-specific context update code


types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }

  var out = this.context.pop();

  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }

  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function () {// tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.context.push(types$1.f_expr);
  } else {
    this.context.push(types$1.f_stat);
  }

  this.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types$1.q_tmpl);
  }

  this.exprAllowed = false;
};

types.star.updateContext = function (prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;

    if (this.context[index] === types$1.f_expr) {
      this.context[index] = types$1.f_expr_gen;
    } else {
      this.context[index] = types$1.f_gen;
    }
  }

  this.exprAllowed = true;
};

types.name.updateContext = function (prevType) {
  var allowed = false;

  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }

  this.exprAllowed = allowed;
};

var data = {
  "$LONE": ["ASCII", "ASCII_Hex_Digit", "AHex", "Alphabetic", "Alpha", "Any", "Assigned", "Bidi_Control", "Bidi_C", "Bidi_Mirrored", "Bidi_M", "Case_Ignorable", "CI", "Cased", "Changes_When_Casefolded", "CWCF", "Changes_When_Casemapped", "CWCM", "Changes_When_Lowercased", "CWL", "Changes_When_NFKC_Casefolded", "CWKCF", "Changes_When_Titlecased", "CWT", "Changes_When_Uppercased", "CWU", "Dash", "Default_Ignorable_Code_Point", "DI", "Deprecated", "Dep", "Diacritic", "Dia", "Emoji", "Emoji_Component", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Presentation", "Extender", "Ext", "Grapheme_Base", "Gr_Base", "Grapheme_Extend", "Gr_Ext", "Hex_Digit", "Hex", "IDS_Binary_Operator", "IDSB", "IDS_Trinary_Operator", "IDST", "ID_Continue", "IDC", "ID_Start", "IDS", "Ideographic", "Ideo", "Join_Control", "Join_C", "Logical_Order_Exception", "LOE", "Lowercase", "Lower", "Math", "Noncharacter_Code_Point", "NChar", "Pattern_Syntax", "Pat_Syn", "Pattern_White_Space", "Pat_WS", "Quotation_Mark", "QMark", "Radical", "Regional_Indicator", "RI", "Sentence_Terminal", "STerm", "Soft_Dotted", "SD", "Terminal_Punctuation", "Term", "Unified_Ideograph", "UIdeo", "Uppercase", "Upper", "Variation_Selector", "VS", "White_Space", "space", "XID_Continue", "XIDC", "XID_Start", "XIDS"],
  "General_Category": ["Cased_Letter", "LC", "Close_Punctuation", "Pe", "Connector_Punctuation", "Pc", "Control", "Cc", "cntrl", "Currency_Symbol", "Sc", "Dash_Punctuation", "Pd", "Decimal_Number", "Nd", "digit", "Enclosing_Mark", "Me", "Final_Punctuation", "Pf", "Format", "Cf", "Initial_Punctuation", "Pi", "Letter", "L", "Letter_Number", "Nl", "Line_Separator", "Zl", "Lowercase_Letter", "Ll", "Mark", "M", "Combining_Mark", "Math_Symbol", "Sm", "Modifier_Letter", "Lm", "Modifier_Symbol", "Sk", "Nonspacing_Mark", "Mn", "Number", "N", "Open_Punctuation", "Ps", "Other", "C", "Other_Letter", "Lo", "Other_Number", "No", "Other_Punctuation", "Po", "Other_Symbol", "So", "Paragraph_Separator", "Zp", "Private_Use", "Co", "Punctuation", "P", "punct", "Separator", "Z", "Space_Separator", "Zs", "Spacing_Mark", "Mc", "Surrogate", "Cs", "Symbol", "S", "Titlecase_Letter", "Lt", "Unassigned", "Cn", "Uppercase_Letter", "Lu"],
  "Script": ["Adlam", "Adlm", "Ahom", "Anatolian_Hieroglyphs", "Hluw", "Arabic", "Arab", "Armenian", "Armn", "Avestan", "Avst", "Balinese", "Bali", "Bamum", "Bamu", "Bassa_Vah", "Bass", "Batak", "Batk", "Bengali", "Beng", "Bhaiksuki", "Bhks", "Bopomofo", "Bopo", "Brahmi", "Brah", "Braille", "Brai", "Buginese", "Bugi", "Buhid", "Buhd", "Canadian_Aboriginal", "Cans", "Carian", "Cari", "Caucasian_Albanian", "Aghb", "Chakma", "Cakm", "Cham", "Cherokee", "Cher", "Common", "Zyyy", "Coptic", "Copt", "Qaac", "Cuneiform", "Xsux", "Cypriot", "Cprt", "Cyrillic", "Cyrl", "Deseret", "Dsrt", "Devanagari", "Deva", "Duployan", "Dupl", "Egyptian_Hieroglyphs", "Egyp", "Elbasan", "Elba", "Ethiopic", "Ethi", "Georgian", "Geor", "Glagolitic", "Glag", "Gothic", "Goth", "Grantha", "Gran", "Greek", "Grek", "Gujarati", "Gujr", "Gurmukhi", "Guru", "Han", "Hani", "Hangul", "Hang", "Hanunoo", "Hano", "Hatran", "Hatr", "Hebrew", "Hebr", "Hiragana", "Hira", "Imperial_Aramaic", "Armi", "Inherited", "Zinh", "Qaai", "Inscriptional_Pahlavi", "Phli", "Inscriptional_Parthian", "Prti", "Javanese", "Java", "Kaithi", "Kthi", "Kannada", "Knda", "Katakana", "Kana", "Kayah_Li", "Kali", "Kharoshthi", "Khar", "Khmer", "Khmr", "Khojki", "Khoj", "Khudawadi", "Sind", "Lao", "Laoo", "Latin", "Latn", "Lepcha", "Lepc", "Limbu", "Limb", "Linear_A", "Lina", "Linear_B", "Linb", "Lisu", "Lycian", "Lyci", "Lydian", "Lydi", "Mahajani", "Mahj", "Malayalam", "Mlym", "Mandaic", "Mand", "Manichaean", "Mani", "Marchen", "Marc", "Masaram_Gondi", "Gonm", "Meetei_Mayek", "Mtei", "Mende_Kikakui", "Mend", "Meroitic_Cursive", "Merc", "Meroitic_Hieroglyphs", "Mero", "Miao", "Plrd", "Modi", "Mongolian", "Mong", "Mro", "Mroo", "Multani", "Mult", "Myanmar", "Mymr", "Nabataean", "Nbat", "New_Tai_Lue", "Talu", "Newa", "Nko", "Nkoo", "Nushu", "Nshu", "Ogham", "Ogam", "Ol_Chiki", "Olck", "Old_Hungarian", "Hung", "Old_Italic", "Ital", "Old_North_Arabian", "Narb", "Old_Permic", "Perm", "Old_Persian", "Xpeo", "Old_South_Arabian", "Sarb", "Old_Turkic", "Orkh", "Oriya", "Orya", "Osage", "Osge", "Osmanya", "Osma", "Pahawh_Hmong", "Hmng", "Palmyrene", "Palm", "Pau_Cin_Hau", "Pauc", "Phags_Pa", "Phag", "Phoenician", "Phnx", "Psalter_Pahlavi", "Phlp", "Rejang", "Rjng", "Runic", "Runr", "Samaritan", "Samr", "Saurashtra", "Saur", "Sharada", "Shrd", "Shavian", "Shaw", "Siddham", "Sidd", "SignWriting", "Sgnw", "Sinhala", "Sinh", "Sora_Sompeng", "Sora", "Soyombo", "Soyo", "Sundanese", "Sund", "Syloti_Nagri", "Sylo", "Syriac", "Syrc", "Tagalog", "Tglg", "Tagbanwa", "Tagb", "Tai_Le", "Tale", "Tai_Tham", "Lana", "Tai_Viet", "Tavt", "Takri", "Takr", "Tamil", "Taml", "Tangut", "Tang", "Telugu", "Telu", "Thaana", "Thaa", "Thai", "Tibetan", "Tibt", "Tifinagh", "Tfng", "Tirhuta", "Tirh", "Ugaritic", "Ugar", "Vai", "Vaii", "Warang_Citi", "Wara", "Yi", "Yiii", "Zanabazar_Square", "Zanb"]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;
var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
}; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).


RegExpValidationState.prototype.at = function at(i) {
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return -1;
  }

  var c = s.charCodeAt(i);

  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c;
  }

  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00;
};

RegExpValidationState.prototype.nextIndex = function nextIndex(i) {
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return l;
  }

  var c = s.charCodeAt(i);

  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return i + 1;
  }

  return i + 2;
};

RegExpValidationState.prototype.current = function current() {
  return this.at(this.pos);
};

RegExpValidationState.prototype.lookahead = function lookahead() {
  return this.at(this.nextIndex(this.pos));
};

RegExpValidationState.prototype.advance = function advance() {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat(ch) {
  if (this.current() === ch) {
    this.advance();
    return true;
  }

  return false;
};

function codePointToString$1(ch) {
  if (ch <= 0xFFFF) {
    return String.fromCharCode(ch);
  }

  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);
}
/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$9.validateRegExpFlags = function (state) {
  var this$1 = this;
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);

    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, "Invalid regular expression flag");
    }

    if (flags.indexOf(flag, i + 1) > -1) {
      this$1.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$9.validateRegExpPattern = function (state) {
  this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.

  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern


pp$9.regexp_pattern = function (state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29
    /* ) */
    )) {
      state.raise("Unmatched ')'");
    }

    if (state.eat(0x5D
    /* [ */
    ) || state.eat(0x7D
    /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }

  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }

  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction


pp$9.regexp_disjunction = function (state) {
  var this$1 = this;
  this.regexp_alternative(state);

  while (state.eat(0x7C
  /* | */
  )) {
    this$1.regexp_alternative(state);
  } // Make the same message as V8.


  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  if (state.eat(0x7B
  /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative


pp$9.regexp_alternative = function (state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term


pp$9.regexp_eatTerm = function (state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }

    return true;
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion


pp$9.regexp_eatAssertion = function (state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false; // ^, $

  if (state.eat(0x5E
  /* ^ */
  ) || state.eat(0x24
  /* $ */
  )) {
    return true;
  } // \b \B


  if (state.eat(0x5C
  /* \ */
  )) {
    if (state.eat(0x42
    /* B */
    ) || state.eat(0x62
    /* b */
    )) {
      return true;
    }

    state.pos = start;
  } // Lookahead / Lookbehind


  if (state.eat(0x28
  /* ( */
  ) && state.eat(0x3F
  /* ? */
  )) {
    var lookbehind = false;

    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C
      /* < */
      );
    }

    if (state.eat(0x3D
    /* = */
    ) || state.eat(0x21
    /* ! */
    )) {
      this.regexp_disjunction(state);

      if (!state.eat(0x29
      /* ) */
      )) {
        state.raise("Unterminated group");
      }

      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }

  state.pos = start;
  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier


pp$9.regexp_eatQuantifier = function (state, noError) {
  if (noError === void 0) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F
    /* ? */
    );
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix


pp$9.regexp_eatQuantifierPrefix = function (state, noError) {
  return state.eat(0x2A
  /* * */
  ) || state.eat(0x2B
  /* + */
  ) || state.eat(0x3F
  /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};

pp$9.regexp_eatBracedQuantifier = function (state, noError) {
  var start = state.pos;

  if (state.eat(0x7B
  /* { */
  )) {
    var min = 0,
        max = -1;

    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;

      if (state.eat(0x2C
      /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }

      if (state.eat(0x7D
      /* } */
      )) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }

        return true;
      }
    }

    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom


pp$9.regexp_eatAtom = function (state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};

pp$9.regexp_eatReverseSolidusAtomEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatUncapturingGroup = function (state) {
  var start = state.pos;

  if (state.eat(0x28
  /* ( */
  )) {
    if (state.eat(0x3F
    /* ? */
    ) && state.eat(0x3A
    /* : */
    )) {
      this.regexp_disjunction(state);

      if (state.eat(0x29
      /* ) */
      )) {
        return true;
      }

      state.raise("Unterminated group");
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatCapturingGroup = function (state) {
  if (state.eat(0x28
  /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F
    /* ? */
    ) {
        state.raise("Invalid group");
      }

    this.regexp_disjunction(state);

    if (state.eat(0x29
    /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }

    state.raise("Unterminated group");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom


pp$9.regexp_eatExtendedAtom = function (state) {
  return state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier


pp$9.regexp_eatInvalidBracedQuantifier = function (state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter


pp$9.regexp_eatSyntaxCharacter = function (state) {
  var ch = state.current();

  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
};

function isSyntaxCharacter(ch) {
  return ch === 0x24
  /* $ */
  || ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  || ch === 0x2E
  /* . */
  || ch === 0x3F
  /* ? */
  || ch >= 0x5B
  /* [ */
  && ch <= 0x5E
  /* ^ */
  || ch >= 0x7B
  /* { */
  && ch <= 0x7D
  /* } */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.


pp$9.regexp_eatPatternCharacters = function (state) {
  var start = state.pos;
  var ch = 0;

  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }

  return state.pos !== start;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter


pp$9.regexp_eatExtendedPatternCharacter = function (state) {
  var ch = state.current();

  if (ch !== -1 && ch !== 0x24
  /* $ */
  && !(ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  ) && ch !== 0x2E
  /* . */
  && ch !== 0x3F
  /* ? */
  && ch !== 0x5B
  /* [ */
  && ch !== 0x5E
  /* ^ */
  && ch !== 0x7C
  /* | */
  ) {
      state.advance();
      return true;
    }

  return false;
}; // GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]


pp$9.regexp_groupSpecifier = function (state) {
  if (state.eat(0x3F
  /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }

      state.groupNames.push(state.lastStringValue);
      return;
    }

    state.raise("Invalid group");
  }
}; // GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$9.regexp_eatGroupName = function (state) {
  state.lastStringValue = "";

  if (state.eat(0x3C
  /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E
    /* > */
    )) {
      return true;
    }

    state.raise("Invalid capture group name");
  }

  return false;
}; // RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$9.regexp_eatRegExpIdentifierName = function (state) {
  state.lastStringValue = "";

  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);

    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }

    return true;
  }

  return false;
}; // RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]


pp$9.regexp_eatRegExpIdentifierStart = function (state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F;
  /* _ */
} // RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>


pp$9.regexp_eatRegExpIdentifierPart = function (state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F
  /* _ */
  || ch === 0x200C
  /* <ZWNJ> */
  || ch === 0x200D;
  /* <ZWJ> */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape


pp$9.regexp_eatAtomEscape = function (state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }

  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63
    /* c */
    ) {
        state.raise("Invalid unicode escape");
      }

    state.raise("Invalid escape");
  }

  return false;
};

pp$9.regexp_eatBackReference = function (state) {
  var start = state.pos;

  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;

    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }

      return true;
    }

    if (n <= state.numCapturingParens) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatKGroupName = function (state) {
  if (state.eat(0x6B
  /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }

    state.raise("Invalid named reference");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape


pp$9.regexp_eatCharacterEscape = function (state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};

pp$9.regexp_eatCControlLetter = function (state) {
  var start = state.pos;

  if (state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatZero = function (state) {
  if (state.current() === 0x30
  /* 0 */
  && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape


pp$9.regexp_eatControlEscape = function (state) {
  var ch = state.current();

  if (ch === 0x74
  /* t */
  ) {
      state.lastIntValue = 0x09;
      /* \t */

      state.advance();
      return true;
    }

  if (ch === 0x6E
  /* n */
  ) {
      state.lastIntValue = 0x0A;
      /* \n */

      state.advance();
      return true;
    }

  if (ch === 0x76
  /* v */
  ) {
      state.lastIntValue = 0x0B;
      /* \v */

      state.advance();
      return true;
    }

  if (ch === 0x66
  /* f */
  ) {
      state.lastIntValue = 0x0C;
      /* \f */

      state.advance();
      return true;
    }

  if (ch === 0x72
  /* r */
  ) {
      state.lastIntValue = 0x0D;
      /* \r */

      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter


pp$9.regexp_eatControlLetter = function (state) {
  var ch = state.current();

  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true;
  }

  return false;
};

function isControlLetter(ch) {
  return ch >= 0x41
  /* A */
  && ch <= 0x5A
  /* Z */
  || ch >= 0x61
  /* a */
  && ch <= 0x7A
  /* z */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence


pp$9.regexp_eatRegExpUnicodeEscapeSequence = function (state) {
  var start = state.pos;

  if (state.eat(0x75
  /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;

      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;

        if (state.eat(0x5C
        /* \ */
        ) && state.eat(0x75
        /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;

          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true;
          }
        }

        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }

      return true;
    }

    if (state.switchU && state.eat(0x7B
    /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(0x7D
    /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }

    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }

    state.pos = start;
  }

  return false;
};

function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape


pp$9.regexp_eatIdentityEscape = function (state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }

    if (state.eat(0x2F
    /* / */
    )) {
      state.lastIntValue = 0x2F;
      /* / */

      return true;
    }

    return false;
  }

  var ch = state.current();

  if (ch !== 0x63
  /* c */
  && (!state.switchN || ch !== 0x6B
  /* k */
  )) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape


pp$9.regexp_eatDecimalEscape = function (state) {
  state.lastIntValue = 0;
  var ch = state.current();

  if (ch >= 0x31
  /* 1 */
  && ch <= 0x39
  /* 9 */
  ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
        /* 0 */
        );
        state.advance();
      } while ((ch = state.current()) >= 0x30
      /* 0 */
      && ch <= 0x39
      /* 9 */
      );

      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape


pp$9.regexp_eatCharacterClassEscape = function (state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }

  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50
  /* P */
  || ch === 0x70
  /* p */
  )) {
    state.lastIntValue = -1;
    state.advance();

    if (state.eat(0x7B
    /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D
    /* } */
    )) {
      return true;
    }

    state.raise("Invalid property name");
  }

  return false;
};

function isCharacterClassEscape(ch) {
  return ch === 0x64
  /* d */
  || ch === 0x44
  /* D */
  || ch === 0x73
  /* s */
  || ch === 0x53
  /* S */
  || ch === 0x77
  /* w */
  || ch === 0x57
  /* W */
  ;
} // UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue


pp$9.regexp_eatUnicodePropertyValueExpression = function (state) {
  var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue

  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D
  /* = */
  )) {
    var name = state.lastStringValue;

    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true;
    }
  }

  state.pos = start; // LoneUnicodePropertyNameOrValue

  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }

  return false;
};

pp$9.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise("Invalid property name");
  }
};

pp$9.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise("Invalid property name");
  }
}; // UnicodePropertyName ::
//   UnicodePropertyNameCharacters


pp$9.regexp_eatUnicodePropertyName = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F;
  /* _ */
} // UnicodePropertyValue ::
//   UnicodePropertyValueCharacters


pp$9.regexp_eatUnicodePropertyValue = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
} // LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters


pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
  return this.regexp_eatUnicodePropertyValue(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass


pp$9.regexp_eatCharacterClass = function (state) {
  if (state.eat(0x5B
  /* [ */
  )) {
    state.eat(0x5E
    /* ^ */
    );
    this.regexp_classRanges(state);

    if (state.eat(0x5D
    /* [ */
    )) {
      return true;
    } // Unreachable since it threw "unterminated regular expression" error before.


    state.raise("Unterminated character class");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash


pp$9.regexp_classRanges = function (state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;

    if (state.eat(0x2D
    /* - */
    ) && this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;

      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }

      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash


pp$9.regexp_eatClassAtom = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }

    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();

      if (ch$1 === 0x63
      /* c */
      || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }

      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  var ch = state.current();

  if (ch !== 0x5D
  /* [ */
  ) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape


pp$9.regexp_eatClassEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x62
  /* b */
  )) {
    state.lastIntValue = 0x08;
    /* <BS> */

    return true;
  }

  if (state.switchU && state.eat(0x2D
  /* - */
  )) {
    state.lastIntValue = 0x2D;
    /* - */

    return true;
  }

  if (!state.switchU && state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter


pp$9.regexp_eatClassControlLetter = function (state) {
  var ch = state.current();

  if (isDecimalDigit(ch) || ch === 0x5F
  /* _ */
  ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$9.regexp_eatHexEscapeSequence = function (state) {
  var start = state.pos;

  if (state.eat(0x78
  /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }

    if (state.switchU) {
      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits


pp$9.regexp_eatDecimalDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
    /* 0 */
    );
    state.advance();
  }

  return state.pos !== start;
};

function isDecimalDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39;
  /* 9 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits


pp$9.regexp_eatHexDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return state.pos !== start;
};

function isHexDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39
  /* 9 */
  || ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  || ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ;
}

function hexToInt(ch) {
  if (ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  ) {
      return 10 + (ch - 0x41
      /* A */
      );
    }

  if (ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ) {
      return 10 + (ch - 0x61
      /* a */
      );
    }

  return ch - 0x30;
  /* 0 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).


pp$9.regexp_eatLegacyOctalEscapeSequence = function (state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;

    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;

      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }

    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit


pp$9.regexp_eatOctalDigit = function (state) {
  var ch = state.current();

  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30;
    /* 0 */

    state.advance();
    return true;
  }

  state.lastIntValue = 0;
  return false;
};

function isOctalDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x37;
  /* 7 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$9.regexp_eatFixedHexDigits = function (state, length) {
  var start = state.pos;
  state.lastIntValue = 0;

  for (var i = 0; i < length; ++i) {
    var ch = state.current();

    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }

    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return true;
}; // Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.


var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;

  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }

  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
}; // ## Tokenizer


exports.Token = Token;
var pp$8 = Parser.prototype; // Move to the next token

pp$8.next = function () {
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function () {
  this.next();
  return new Token(this);
}; // If we're in an ES6 environment, make parsers iterable


if (typeof Symbol !== "undefined") {
  pp$8[Symbol.iterator] = function () {
    var this$1 = this;
    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        };
      }
    };
  };
} // Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).


pp$8.curContext = function () {
  return this.context[this.context.length - 1];
}; // Read a single token, updating the parser object's token-related
// properties.


pp$8.nextToken = function () {
  var curContext = this.curContext();

  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }

  this.start = this.pos;

  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }

  if (this.pos >= this.input.length) {
    return this.finishToken(types.eof);
  }

  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};

pp$8.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92
  /* '\' */
  ) {
      return this.readWord();
    }

  return this.getTokenFromCode(code);
};

pp$8.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);

  if (code <= 0xd7ff || code >= 0xe000) {
    return code;
  }

  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp$8.skipBlockComment = function () {
  var this$1 = this;
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);

  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }

  this.pos = end + 2;

  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;

    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }

  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};

pp$8.skipLineComment = function (startSkip) {
  var this$1 = this;
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);

  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }

  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
}; // Called at the start of the parse and after every token. Skips
// whitespace and comments, and.


pp$8.skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);

    switch (ch) {
      case 32:
      case 160:
        // ' '
        ++this$1.pos;
        break;

      case 13:
        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
          ++this$1.pos;
        }

      case 10:
      case 8232:
      case 8233:
        ++this$1.pos;

        if (this$1.options.locations) {
          ++this$1.curLine;
          this$1.lineStart = this$1.pos;
        }

        break;

      case 47:
        // '/'
        switch (this$1.input.charCodeAt(this$1.pos + 1)) {
          case 42:
            // '*'
            this$1.skipBlockComment();
            break;

          case 47:
            this$1.skipLineComment(2);
            break;

          default:
            break loop;
        }

        break;

      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this$1.pos;
        } else {
          break loop;
        }

    }
  }
}; // Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.


pp$8.finishToken = function (type, val) {
  this.end = this.pos;

  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }

  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
}; // ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//


pp$8.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);

  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }

  var next2 = this.input.charCodeAt(this.pos + 2);

  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types.dot);
  }
};

pp$8.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);

  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.slash, 1);
};

pp$8.readToken_mult_modulo_exp = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=

  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, size + 1);
  }

  return this.finishOp(tokentype, size);
};

pp$8.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};

pp$8.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.bitwiseXOR, 1);
};

pp$8.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }

    return this.finishOp(types.incDec, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.plusMin, 1);
};

pp$8.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;

  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;

    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types.assign, size + 1);
    }

    return this.finishOp(types.bitShift, size);
  }

  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }

  if (next === 61) {
    size = 2;
  }

  return this.finishOp(types.relational, size);
};

pp$8.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }

  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow);
  }

  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};

pp$8.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();
    // Punctuation tokens.

    case 40:
      ++this.pos;
      return this.finishToken(types.parenL);

    case 41:
      ++this.pos;
      return this.finishToken(types.parenR);

    case 59:
      ++this.pos;
      return this.finishToken(types.semi);

    case 44:
      ++this.pos;
      return this.finishToken(types.comma);

    case 91:
      ++this.pos;
      return this.finishToken(types.bracketL);

    case 93:
      ++this.pos;
      return this.finishToken(types.bracketR);

    case 123:
      ++this.pos;
      return this.finishToken(types.braceL);

    case 125:
      ++this.pos;
      return this.finishToken(types.braceR);

    case 58:
      ++this.pos;
      return this.finishToken(types.colon);

    case 63:
      ++this.pos;
      return this.finishToken(types.question);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) {
        break;
      }

      ++this.pos;
      return this.finishToken(types.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);

      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      } // '0x', '0X' - hex number


      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        } // '0o', '0O' - octal number


        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        } // '0b', '0B' - binary number

      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.

    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      // 1-9
      return this.readNumber(false);
    // Quotes produce strings.

    case 34:
    case 39:
      // '"', "'"
      return this.readString(code);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:
    case 42:
      // '%*'
      return this.readToken_mult_modulo_exp(code);

    case 124:
    case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:
    case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:
    case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:
    case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 126:
      // '~'
      return this.finishOp(types.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

pp$8.readRegexp = function () {
  var this$1 = this;
  var escaped,
      inClass,
      start = this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(start, "Unterminated regular expression");
    }

    var ch = this$1.input.charAt(this$1.pos);

    if (lineBreak.test(ch)) {
      this$1.raise(start, "Unterminated regular expression");
    }

    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }

      escaped = ch === "\\";
    } else {
      escaped = false;
    }

    ++this$1.pos;
  }

  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();

  if (this.containsEsc) {
    this.unexpected(flagsStart);
  } // Validate pattern


  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state); // Create Literal#value property value.

  var value = null;

  try {
    value = new RegExp(pattern, flags);
  } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {
    pattern: pattern,
    flags: flags,
    value: value
  });
}; // Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.


pp$8.readInt = function (radix, len) {
  var this$1 = this;
  var start = this.pos,
      total = 0;

  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos),
        val = void 0;

    if (code >= 97) {
      val = code - 97 + 10;
    } // a
    else if (code >= 65) {
        val = code - 65 + 10;
      } // A
      else if (code >= 48 && code <= 57) {
          val = code - 48;
        } // 0-9
        else {
            val = Infinity;
          }

    if (val >= radix) {
      break;
    }

    ++this$1.pos;
    total = total * radix + val;
  }

  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }

  return total;
};

pp$8.readRadixNumber = function (radix) {
  this.pos += 2; // 0x

  var val = this.readInt(radix);

  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }

  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  return this.finishToken(types.num, val);
}; // Read an integer, octal integer, or floating-point number.


pp$8.readNumber = function (startsWithDot) {
  var start = this.pos;

  if (!startsWithDot && this.readInt(10) === null) {
    this.raise(start, "Invalid number");
  }

  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;

  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }

  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }

  var next = this.input.charCodeAt(this.pos);

  if (next === 46 && !octal) {
    // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }

  if ((next === 69 || next === 101) && !octal) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);

    if (next === 43 || next === 45) {
      ++this.pos;
    } // '+-'


    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }

  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val);
}; // Read a string value, interpreting backslash-escapes.


pp$8.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code;

  if (ch === 123) {
    // '{'
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }

    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;

    if (code > 0x10FFFF) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }

  return code;
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp$8.readString = function (quote) {
  var this$1 = this;
  var out = "",
      chunkStart = ++this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(this$1.start, "Unterminated string constant");
    }

    var ch = this$1.input.charCodeAt(this$1.pos);

    if (ch === quote) {
      break;
    }

    if (ch === 92) {
      // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) {
        this$1.raise(this$1.start, "Unterminated string constant");
      }

      ++this$1.pos;
    }
  }

  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out);
}; // Reads template string tokens.


var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function () {
  this.inTemplateElement = true;

  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function (position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function () {
  var this$1 = this;
  var out = "",
      chunkStart = this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(this$1.start, "Unterminated template");
    }

    var ch = this$1.input.charCodeAt(this$1.pos);

    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {
      // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL);
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote);
        }
      }

      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out);
    }

    if (ch === 92) {
      // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;

      switch (ch) {
        case 13:
          if (this$1.input.charCodeAt(this$1.pos) === 10) {
            ++this$1.pos;
          }

        case 10:
          out += "\n";
          break;

        default:
          out += String.fromCharCode(ch);
          break;
      }

      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }

      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
}; // Reads a template token to search for the end, without validating any escape sequences


pp$8.readInvalidTemplateToken = function () {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
      case "\\":
        ++this$1.pos;
        break;

      case "$":
        if (this$1.input[this$1.pos + 1] !== "{") {
          break;
        }

      // falls through

      case "`":
        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));
      // no default
    }
  }

  this.raise(this.start, "Unterminated template");
}; // Used to read escaped characters


pp$8.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;

  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'

    case 114:
      return "\r";
    // 'r' -> '\r'

    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'

    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'

    case 116:
      return "\t";
    // 't' -> '\t'

    case 98:
      return "\b";
    // 'b' -> '\b'

    case 118:
      return "\u000b";
    // 'v' -> '\u000b'

    case 102:
      return "\f";
    // 'f' -> '\f'

    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }

    // '\r\n'

    case 10:
      // ' \n'
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }

      return "";

    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);

        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }

        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);

        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }

        return String.fromCharCode(octal);
      }

      return String.fromCharCode(ch);
  }
}; // Used to read character escape sequences ('\x', '\u', '\U').


pp$8.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);

  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }

  return n;
}; // Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.


pp$8.readWord1 = function () {
  var this$1 = this;
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;

  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();

    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;

      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // "u"
        {
          this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

      ++this$1.pos;
      var esc = this$1.readCodePoint();

      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this$1.invalidStringToken(escStart, "Invalid Unicode escape");
      }

      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break;
    }

    first = false;
  }

  return word + this.input.slice(chunkStart, this.pos);
}; // Read an identifier or keyword token. Will check for reserved
// words when necessary.


pp$8.readWord = function () {
  var word = this.readWord1();
  var type = types.name;

  if (this.keywords.test(word)) {
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
    }

    type = keywords$1[word];
  }

  return this.finishToken(type, word);
}; // Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js


var version = "5.7.3"; // The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

exports.version = version;

function parse(input, options) {
  return new Parser(options, input).parse();
} // This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.


function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
} // Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.


function tokenizer(input, options) {
  return new Parser(options, input);
} // This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.


var parse_dammit;
exports.parse_dammit = parse_dammit;
var LooseParser;
exports.LooseParser = LooseParser;
var pluginsLoose; // eslint-disable-line camelcase

exports.pluginsLoose = pluginsLoose;

function addLooseExports(parse, Parser$$1, plugins$$1) {
  exports.parse_dammit = parse_dammit = parse; // eslint-disable-line camelcase

  exports.LooseParser = LooseParser = Parser$$1;
  exports.pluginsLoose = pluginsLoose = plugins$$1;
}
},{}],"ryqg":[function(require,module,exports) {
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Input = function Input(value, size) {
  _classCallCheck(this, Input);

  this.value = value;
  this.size = new Int32Array(3);

  if (Array.isArray(size)) {
    for (var i = 0; i < this.size.length; i++) {
      this.size[i] = size[i] || 1;
    }
  } else {
    if (size.z) {
      this.size = new Int32Array([size.x, size.y, size.z]);
    } else if (size.y) {
      this.size = new Int32Array([size.x, size.y, 1]);
    } else {
      this.size = new Int32Array([size.x, 1, 1]);
    }
  }

  var _this$size = _slicedToArray(this.size, 3),
      h = _this$size[0],
      w = _this$size[1],
      d = _this$size[2];

  if (this.value.length !== h * w * d) {
    throw new Error("Input size ".concat(this.value.length, " does not match ").concat(w, " * ").concat(h, " * ").concat(d, " = ").concat(h * w * d));
  }
};

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input: Input,
  input: input
};
},{}],"5wk/":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @desc WebGl Texture implementation in JS
 * @param {ITextureSettings} settings
 */
var Texture =
/*#__PURE__*/
function () {
  function Texture(settings) {
    _classCallCheck(this, Texture);

    var texture = settings.texture,
        size = settings.size,
        dimensions = settings.dimensions,
        output = settings.output,
        context = settings.context,
        _settings$type = settings.type,
        type = _settings$type === void 0 ? 'NumberTexture' : _settings$type;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    this.texture = texture;
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = null;
    this.type = type;
  }
  /**
   * @desc Converts the Texture into a JavaScript Array
   * @returns {Number[]|Number[][]|Number[][][]}
   */


  _createClass(Texture, [{
    key: "toArray",
    value: function toArray() {
      throw new Error("Not implemented on ".concat(this.constructor.name));
    }
    /**
     * @desc Deletes the Texture
     */

  }, {
    key: "delete",
    value: function _delete() {
      return this.context.deleteTexture(this.texture);
    }
  }]);

  return Texture;
}();

module.exports = {
  Texture: Texture
};
},{}],"9h1E":[function(require,module,exports) {
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var acorn = require('acorn');

var _require = require('./input'),
    Input = _require.Input;

var _require2 = require('./texture'),
    Texture = _require2.Texture;

var FUNCTION_NAME = /function ([^(]*)/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
/**
 *
 * @desc Various utility functions / snippets of code that GPU.JS uses internally.
 * This covers various snippets of code that is not entirely gpu.js specific (ie. may find uses elsewhere)
 */

var utils = {
  /**
   *
   * @desc Gets the system endianness, and cache it
   * @returns {String} 'LE' or 'BE' depending on system architecture
   * Credit: https://gist.github.com/TooTallNate/4750953
   */
  systemEndianness: function systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness: function getSystemEndianness() {
    var b = new ArrayBuffer(4);
    var a = new Uint32Array(b);
    var c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  /**
   * @descReturn TRUE, on a JS function
   * @param {Function} funcObj - Object to validate if its a function
   * @returns  {Boolean} TRUE if the object is a JS function
   */
  isFunction: function isFunction(funcObj) {
    return typeof funcObj === 'function';
  },

  /**
   * @desc Return TRUE, on a valid JS function string
   * Note: This does just a VERY simply sanity check. And may give false positives.
   *
   * @param {String} fn - String of JS function to validate
   * @returns {Boolean} TRUE if the string passes basic validation
   */
  isFunctionString: function isFunctionString(fn) {
    if (typeof fn === 'string') {
      return fn.slice(0, 'function'.length).toLowerCase() === 'function';
    }

    return false;
  },

  /**
   * @desc Return the function name from a JS function string
   * @param {String} funcStr - String of JS function to validate
   * @returns {String} Function name string (if found)
   */
  getFunctionNameFromString: function getFunctionNameFromString(funcStr) {
    return FUNCTION_NAME.exec(funcStr)[1].trim();
  },
  getFunctionBodyFromString: function getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  /**
   * @desc Return list of argument names extracted from a javascript function
   * @param {String} fn - String of JS function to validate
   * @returns {String[]}  Array representing all the parameter names
   */
  getArgumentNamesFromString: function getArgumentNamesFromString(fn) {
    var fnStr = fn.replace(STRIP_COMMENTS, '');
    var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);

    if (result === null) {
      result = [];
    }

    return result;
  },

  /**
   * @desc Returns a clone
   * @param {Object} obj - Object to clone
   * @returns {Object|Array} Cloned object
   */
  clone: function clone(obj) {
    if (obj === null || _typeof(obj) !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;
    var temp = obj.constructor(); // changed

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  /**
   * @desc Checks if is an array or Array-like object
   * @param {Object} array - The argument object to check if is array
   * @returns {Boolean}  true if is array or Array-like object
   */
  isArray: function isArray(array) {
    return !isNaN(array.length);
  },

  /**
   * @desc Evaluate the argument type, to apply respective logic for it
   * @param {Object} value - The argument object to evaluate type
   * @returns {String}  Argument type Array/Number/Float/Texture/Unknown
   */
  getVariableType: function getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }

      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';

      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }

        return 'Float';

      case Texture:
        return value.type;

      case Input:
        return 'Input';
    }

    if (value.nodeName === 'IMG') {
      return 'HTMLImage';
    } else {
      if (value.hasOwnProperty('type')) {
        return value.type;
      }

      return 'Unknown';
    }
  },
  getKernelTextureSize: function getKernelTextureSize(settings, dimensions) {
    var _dimensions = _slicedToArray(dimensions, 3),
        w = _dimensions[0],
        h = _dimensions[1],
        d = _dimensions[2];

    var texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    } // if given dimensions == a 2d image


    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }

    return utils.closestSquareDimensions(texelCount);
  },

  /**
   *
   * @param {Number} length
   * @returns {TextureDimensions}
   */
  closestSquareDimensions: function closestSquareDimensions(length) {
    var sqrt = Math.sqrt(length);
    var high = Math.ceil(sqrt);
    var low = Math.floor(sqrt);

    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }

    return new Int32Array([low, Math.ceil(length / low)]);
  },

  /**
   * A texture takes up four
   * @param {OutputDimensions} dimensions
   * @param {Number} bitRatio
   * @returns {TextureDimensions}
   */
  getMemoryOptimizedFloatTextureSize: function getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    var _dimensions2 = _slicedToArray(dimensions, 3),
        w = _dimensions2[0],
        h = _dimensions2[1],
        d = _dimensions2[2];

    var totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    var texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  /**
   *
   * @param dimensions
   * @param bitRatio
   * @returns {*|TextureDimensions}
   */
  getMemoryOptimizedPackedTextureSize: function getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    var _dimensions3 = _slicedToArray(dimensions, 3),
        w = _dimensions3[0],
        h = _dimensions3[1],
        d = _dimensions3[2];

    var totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    var texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },
  roundTo: function roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },

  /**
   * @desc Return the dimension of an array.
   * @param {Array|String|Texture|Input} x - The array
   * @param {Boolean} [pad] - To include padding in the dimension calculation
   * @returns {OutputDimensions}
   */
  getDimensions: function getDimensions(x, pad) {
    var ret;

    if (utils.isArray(x)) {
      var dim = [];
      var temp = x;

      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }

      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error("Unknown dimensions of ".concat(x));
    }

    if (pad) {
      ret = Array.from(ret);

      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  /**
   * Puts a nested 2d array into a one-dimensional target array
   * @param {Array|*} array
   * @param {Float32Array|Float64Array} target
   */
  flatten2dArrayTo: function flatten2dArrayTo(array, target) {
    var offset = 0;

    for (var y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  /**
   * Puts a nested 3d array into a one-dimensional target array
   * @param {Array|*} array
   * @param {Float32Array|Float64Array} target
   */
  flatten3dArrayTo: function flatten3dArrayTo(array, target) {
    var offset = 0;

    for (var z = 0; z < array.length; z++) {
      for (var y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  /**
   * Puts a nested 1d, 2d, or 3d array into a one-dimensional target array
   * @param {Float32Array|Uint16Array|Uint8Array} array
   * @param {Float32Array} target
   */
  flattenTo: function flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        utils.flatten3dArrayTo(array, target);
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  /**
   *
   * @desc Splits an array into smaller arrays.
   * Number of elements in one small chunk is given by `part`
   *
   * @param {Number[]} array - The array to split into chunks
   * @param {Number} part - elements in one chunk
   *
   * @returns {Number[]} An array of smaller chunks
   */
  splitArray: function splitArray(array, part) {
    var result = [];

    for (var i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }

    return result;
  },
  getAstString: function getAstString(source, ast) {
    var lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    var start = ast.loc.start;
    var end = ast.loc.end;
    var result = [];

    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));

      for (var i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }

      result.push(lines[end.line - 1].slice(0, end.column));
    }

    return result.join('\n');
  },
  allPropertiesOf: function allPropertiesOf(obj) {
    var props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  /**
   * @param {Array} lines - An Array of strings
   * @returns {String} Single combined String, separated by *\n*
   */
  linesToString: function linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated: function warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn("You are using a deprecated ".concat(type, " \"").concat(oldName, "\". It has been replaced with \"").concat(newName, "\". Fixing, but please upgrade as it will soon be removed."));
    } else {
      console.warn("You are using a deprecated ".concat(type, " \"").concat(oldName, "\". It has been removed. Fixing, but please upgrade as it will soon be removed."));
    }
  },

  /**
   *
   * @param {String|Function} source
   * @param {IFunctionSettings} [settings]
   * @returns {IFunction}
   */
  functionToIFunction: function functionToIFunction(source, settings) {
    settings = settings || {};
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    var sourceString = typeof source === 'string' ? source : source.toString();
    var argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (_typeof(settings.argumentTypes) === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString).map(function (name) {
        return settings.argumentTypes[name];
      }) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      source: sourceString,
      argumentTypes: argumentTypes,
      returnType: settings.returnType || null
    };
  },
  flipPixels: function flipPixels(pixels, width, height) {
    // https://stackoverflow.com/a/41973289/1324039
    var halfHeight = height / 2 | 0; // the | 0 keeps the result an int

    var bytesPerRow = width * 4; // make a temp buffer to hold one row

    var temp = new Uint8ClampedArray(width * 4);
    var result = pixels.slice(0);

    for (var y = 0; y < halfHeight; ++y) {
      var topOffset = y * bytesPerRow;
      var bottomOffset = (height - y - 1) * bytesPerRow; // make copy of a row on the top half

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow)); // copy a row from the bottom half to the top

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow); // copy the copy of the top half row to the bottom half

      result.set(temp, bottomOffset);
    }

    return result;
  },
  erectPackedFloat: function erectPackedFloat(array, width) {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: function erect2DPackedFloat(array, width, height) {
    var yResults = new Array(height);

    for (var y = 0; y < height; y++) {
      var xStart = y * width;
      var xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }

    return yResults;
  },
  erect3DPackedFloat: function erect3DPackedFloat(array, width, height, depth) {
    var zResults = new Array(depth);

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var xStart = z * height * width + y * width;
        var xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }

      zResults[z] = yResults;
    }

    return zResults;
  },
  erectMemoryOptimizedFloat: function erectMemoryOptimizedFloat(array, width) {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: function erectMemoryOptimized2DFloat(array, width, height) {
    var yResults = new Array(height);

    for (var y = 0; y < height; y++) {
      var offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }

    return yResults;
  },
  erectMemoryOptimized3DFloat: function erectMemoryOptimized3DFloat(array, width, height, depth) {
    var zResults = new Array(depth);

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var offset = z * height * width + y * width;
        yResults[y] = array.subarray(offset, offset + width);
      }

      zResults[z] = yResults;
    }

    return zResults;
  },
  erectFloat: function erectFloat(array, width) {
    var xResults = new Float32Array(width);
    var i = 0;

    for (var x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }

    return xResults;
  },
  erect2DFloat: function erect2DFloat(array, width, height) {
    var yResults = new Array(height);
    var i = 0;

    for (var y = 0; y < height; y++) {
      var xResults = new Float32Array(width);

      for (var x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }

      yResults[y] = xResults;
    }

    return yResults;
  },
  erect3DFloat: function erect3DFloat(array, width, height, depth) {
    var zResults = new Array(depth);
    var i = 0;

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var xResults = new Float32Array(width);

        for (var x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }

        yResults[y] = xResults;
      }

      zResults[z] = yResults;
    }

    return zResults;
  },
  erectArray2: function erectArray2(array, width) {
    var xResults = new Array(width);
    var xResultsMax = width * 4;
    var i = 0;

    for (var x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }

    return xResults;
  },
  erect2DArray2: function erect2DArray2(array, width, height) {
    var yResults = new Array(height);
    var XResultsMax = width * 4;

    for (var y = 0; y < height; y++) {
      var xResults = new Array(width);
      var offset = y * XResultsMax;
      var i = 0;

      for (var x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }

      yResults[y] = xResults;
    }

    return yResults;
  },
  erect3DArray2: function erect3DArray2(array, width, height, depth) {
    var xResultsMax = width * 4;
    var zResults = new Array(depth);

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var xResults = new Array(width);
        var offset = z * xResultsMax * height + y * xResultsMax;
        var i = 0;

        for (var x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }

        yResults[y] = xResults;
      }

      zResults[z] = yResults;
    }

    return zResults;
  },
  erectArray3: function erectArray3(array, width) {
    var xResults = new Array(width);
    var xResultsMax = width * 4;
    var i = 0;

    for (var x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }

    return xResults;
  },
  erect2DArray3: function erect2DArray3(array, width, height) {
    var xResultsMax = width * 4;
    var yResults = new Array(height);

    for (var y = 0; y < height; y++) {
      var xResults = new Array(width);
      var offset = y * xResultsMax;
      var i = 0;

      for (var x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }

      yResults[y] = xResults;
    }

    return yResults;
  },
  erect3DArray3: function erect3DArray3(array, width, height, depth) {
    var xResultsMax = width * 4;
    var zResults = new Array(depth);

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var xResults = new Array(width);
        var offset = z * xResultsMax * height + y * xResultsMax;
        var i = 0;

        for (var x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }

        yResults[y] = xResults;
      }

      zResults[z] = yResults;
    }

    return zResults;
  },
  erectArray4: function erectArray4(array, width) {
    var xResults = new Array(array);
    var xResultsMax = width * 4;
    var i = 0;

    for (var x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }

    return xResults;
  },
  erect2DArray4: function erect2DArray4(array, width, height) {
    var xResultsMax = width * 4;
    var yResults = new Array(height);

    for (var y = 0; y < height; y++) {
      var xResults = new Array(width);
      var offset = y * xResultsMax;
      var i = 0;

      for (var x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }

      yResults[y] = xResults;
    }

    return yResults;
  },
  erect3DArray4: function erect3DArray4(array, width, height, depth) {
    var xResultsMax = width * 4;
    var zResults = new Array(depth);

    for (var z = 0; z < depth; z++) {
      var yResults = new Array(height);

      for (var y = 0; y < height; y++) {
        var xResults = new Array(width);
        var offset = z * xResultsMax * height + y * xResultsMax;
        var i = 0;

        for (var x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }

        yResults[y] = xResults;
      }

      zResults[z] = yResults;
    }

    return zResults;
  },

  /**
   *
   * @param {String} source
   * @param {Object} settings
   * @return {String}
   */
  flattenFunctionToString: function flattenFunctionToString(source, settings) {
    var findDependency = settings.findDependency,
        thisLookup = settings.thisLookup,
        doNotDefine = settings.doNotDefine;
    var flattened = settings.flattened;

    if (!flattened) {
      flattened = settings.flattened = {};
    }

    var ast = acorn.parse(source);
    var functionDependencies = [];

    function flatten(ast) {
      if (Array.isArray(ast)) {
        var results = [];

        for (var i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }

        return results.join('');
      }

      switch (ast.type) {
        case 'Program':
          return flatten(ast.body);

        case 'FunctionDeclaration':
          return "function ".concat(ast.id.name, "(").concat(ast.params.map(flatten).join(', '), ") ").concat(flatten(ast.body));

        case 'BlockStatement':
          {
            var _result = [];

            for (var _i2 = 0; _i2 < ast.body.length; _i2++) {
              _result.push(flatten(ast.body[_i2]), ';\n');
            }

            return "{\n".concat(_result.join(''), "}");
          }

        case 'VariableDeclaration':
          switch (ast.declarations[0].id.type) {
            case 'ObjectPattern':
              {
                var _source = flatten(ast.declarations[0].init);

                var properties = ast.declarations.map(function (declaration) {
                  return declaration.id.properties.map(flatten);
                })[0];

                if (/this/.test(_source)) {
                  var _result2 = [];
                  var lookups = properties.map(thisLookup);

                  for (var _i3 = 0; _i3 < lookups.length; _i3++) {
                    var lookup = lookups[_i3];
                    if (lookup === null) continue;
                    var property = properties[_i3];

                    _result2.push("".concat(ast.kind, " ").concat(property, " = ").concat(lookup, ";\n"));
                  }

                  return _result2.join('');
                }

                return "".concat(ast.kind, " { ").concat(properties, " } = ").concat(_source);
              }

            case 'ArrayPattern':
              return "".concat(ast.kind, " [ ").concat(ast.declarations.map(function (declaration) {
                return flatten(declaration.id);
              }).join(', '), " ] = ").concat(flatten(ast.declarations[0].init));
          }

          if (doNotDefine && doNotDefine.indexOf(ast.declarations[0].id.name) !== -1) {
            return '';
          }

          return "".concat(ast.kind, " ").concat(ast.declarations[0].id.name, " = ").concat(flatten(ast.declarations[0].init));

        case 'CallExpression':
          {
            if (ast.callee.property.name === 'subarray') {
              return "".concat(flatten(ast.callee.object), ".").concat(flatten(ast.callee.property), "(").concat(ast.arguments.map(function (value) {
                return flatten(value);
              }).join(', '), ")");
            }

            if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
              return "".concat(flatten(ast.callee.object), ".").concat(flatten(ast.callee.property), "(").concat(ast.arguments.map(function (value) {
                return flatten(value);
              }).join(', '), ")");
            }

            if (ast.callee.object.type === 'ThisExpression') {
              functionDependencies.push(findDependency('this', ast.callee.property.name));
              return "".concat(ast.callee.property.name, "(").concat(ast.arguments.map(function (value) {
                return flatten(value);
              }).join(', '), ")");
            } else if (ast.callee.object.name) {
              var foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);

              if (foundSource === null) {
                // we're not flattening it
                return "".concat(ast.callee.object.name, ".").concat(ast.callee.property.name, "(").concat(ast.arguments.map(function (value) {
                  return flatten(value);
                }).join(', '), ")");
              } else {
                functionDependencies.push(foundSource); // we're flattening it

                return "".concat(ast.callee.property.name, "(").concat(ast.arguments.map(function (value) {
                  return flatten(value);
                }).join(', '), ")");
              }
            } else if (ast.callee.object.type === 'MemberExpression') {
              return "".concat(flatten(ast.callee.object), ".").concat(ast.callee.property.name, "(").concat(ast.arguments.map(function (value) {
                return flatten(value);
              }).join(', '), ")");
            } else {
              throw new Error('unknown ast.callee');
            }
          }

        case 'ReturnStatement':
          return "return ".concat(flatten(ast.argument));

        case 'BinaryExpression':
          return "(".concat(flatten(ast.left)).concat(ast.operator).concat(flatten(ast.right), ")");

        case 'UnaryExpression':
          if (ast.prefix) {
            return "".concat(ast.operator, " ").concat(flatten(ast.argument));
          } else {
            return "".concat(flatten(ast.argument), " ").concat(ast.operator);
          }

        case 'ExpressionStatement':
          return "(".concat(flatten(ast.expression), ")");

        case 'ArrowFunctionExpression':
          return "(".concat(ast.params.map(flatten).join(', '), ") => ").concat(flatten(ast.body));

        case 'Literal':
          return ast.raw;

        case 'Identifier':
          return ast.name;

        case 'MemberExpression':
          if (ast.object.type === 'ThisExpression') {
            return thisLookup(ast.property.name);
          }

          if (ast.computed) {
            return "".concat(flatten(ast.object), "[").concat(flatten(ast.property), "]");
          }

          return flatten(ast.object) + '.' + flatten(ast.property);

        case 'ThisExpression':
          return 'this';

        case 'NewExpression':
          return "new ".concat(flatten(ast.callee), "(").concat(ast.arguments.map(function (value) {
            return flatten(value);
          }).join(', '), ")");

        case 'ForStatement':
          return "for (".concat(flatten(ast.init), ";").concat(flatten(ast.test), ";").concat(flatten(ast.update), ") ").concat(flatten(ast.body));

        case 'AssignmentExpression':
          return "".concat(flatten(ast.left)).concat(ast.operator).concat(flatten(ast.right));

        case 'UpdateExpression':
          return "".concat(flatten(ast.argument)).concat(ast.operator);

        case 'IfStatement':
          return "if (".concat(flatten(ast.test), ") ").concat(flatten(ast.consequent));

        case 'ThrowStatement':
          return "throw ".concat(flatten(ast.argument));

        case 'ObjectPattern':
          return ast.properties.map(flatten).join(', ');

        case 'ArrayPattern':
          return ast.elements.map(flatten).join(', ');

        case 'DebuggerStatement':
          return 'debugger;';

        case 'ConditionalExpression':
          return "".concat(flatten(ast.test), "?").concat(flatten(ast.consequent), ":").concat(flatten(ast.alternate));

        case 'Property':
          if (ast.kind === 'init') {
            return flatten(ast.key);
          }

      }

      throw new Error("unhandled ast.type of ".concat(ast.type));
    }

    var result = flatten(ast);

    if (functionDependencies.length > 0) {
      var flattenedFunctionDependencies = [];

      for (var i = 0; i < functionDependencies.length; i++) {
        var functionDependency = functionDependencies[i];

        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }

        flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + ';\n');
      }

      return flattenedFunctionDependencies.join('') + result;
    }

    return result;
  }
};

var _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils: utils
};
},{"acorn":"Wqy/","./input":"ryqg","./texture":"5wk/"}],"JYjN":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('../utils'),
    utils = _require.utils;

var _require2 = require('../input'),
    Input = _require2.Input;

var Kernel =
/*#__PURE__*/
function () {
  _createClass(Kernel, null, [{
    key: "isContextMatch",

    /**
     * @type {Boolean}
     */
    value: function isContextMatch(context) {
      throw new Error("\"isContextMatch\" not implemented on ".concat(this.name));
    }
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      throw new Error("\"getFeatures\" not implemented on ".concat(this.name));
    }
  }, {
    key: "destroyContext",
    value: function destroyContext(context) {
      throw new Error("\"destroyContext\" called on ".concat(this.name));
    }
  }, {
    key: "nativeFunctionArguments",
    value: function nativeFunctionArguments() {
      throw new Error("\"nativeFunctionArguments\" called on ".concat(this.name));
    }
  }, {
    key: "nativeFunctionReturnType",
    value: function nativeFunctionReturnType() {
      throw new Error("\"nativeFunctionReturnType\" called on ".concat(this.name));
    }
  }, {
    key: "combineKernels",
    value: function combineKernels() {
      throw new Error("\"combineKernels\" called on ".concat(this.name));
    }
    /**
     *
     * @param {string|object} source
     * @param [settings]
     */

  }, {
    key: "isSupported",

    /**
     * @type {Boolean}
     */
    get: function get() {
      throw new Error("\"isSupported\" not implemented on ".concat(this.name));
    }
  }]);

  function Kernel(source, settings) {
    _classCallCheck(this, Kernel);

    if (_typeof(source) !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }

      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }

    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;
    /**
     * Name of the arguments found from parsing source argument
     * @type {String[]}
     */

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    /**
     * The function source
     * @type {String}
     */

    this.source = source;
    /**
     * The size of the kernel's output
     * @type {Number[]}
     */

    this.output = null;
    /**
     * Debug mode
     * @type {Boolean}
     */

    this.debug = false;
    /**
     * Graphical mode
     * @type {Boolean}
     */

    this.graphical = false;
    /**
     * Maximum loops when using argument values to prevent infinity
     * @type {Number}
     */

    this.loopMaxIterations = 0;
    /**
     * Constants used in kernel via `this.constants`
     * @type {Object}
     */

    this.constants = null;
    this.constantTypes = null;
    this.constantBitRatios = null;
    this.dynamicArguments = false;
    this.dynamicOutput = true;
    /**
     *
     * @type {Object}
     */

    this.canvas = null;
    /**
     *
     * @type {WebGLRenderingContext}
     */

    this.context = null;
    /**
     *
     * @type {Boolean}
     */

    this.checkContext = null;
    /**
     *
     * @type {GPU}
     */

    this.gpu = null;
    /**
     *
     * @type {IGPUFunction[]}
     */

    this.functions = null;
    /**
     *
     * @type {IGPUNativeFunction[]}
     */

    this.nativeFunctions = null;
    /**
     *
     * @type {ISubKernel[]}
     */

    this.subKernels = null;
    /**
     *
     * @type {Boolean}
     */

    this.validate = true;
    /**
     * Enforces kernel to write to a new array or texture on run
     * @type {Boolean}
     */

    this.immutable = false;
    /**
     * Enforces kernel to write to a texture on run
     * @type {Boolean}
     */

    this.pipeline = false;
    /**
     * Make GPU use single precison or unsigned.  Acceptable values: 'single' or 'unsigned'
     * @type {String|null}
     * @enum 'single' | 'unsigned'
     */

    this.precision = null;
    this.plugins = null;
    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
  }

  _createClass(Kernel, [{
    key: "mergeSettings",
    value: function mergeSettings(settings) {
      for (var p in settings) {
        if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;

        switch (p) {
          case 'output':
            if (!Array.isArray(settings.output)) {
              this.setOutput(settings.output); // Flatten output object

              continue;
            }

            break;

          case 'functions':
            if (typeof settings.functions[0] === 'function') {
              this.functions = settings.functions.map(function (source) {
                return utils.functionToIFunction(source);
              });
              continue;
            }

            break;

          case 'graphical':
            if (settings[p] && !settings.hasOwnProperty('precision')) {
              this.precision = 'unsigned';
            }

            this[p] = settings[p];
            continue;
        }

        this[p] = settings[p];
      }

      if (!this.canvas) this.canvas = this.initCanvas();
      if (!this.context) this.context = this.initContext();
      if (!this.plugins) this.plugins = this.initPlugins(settings);
    }
    /**
     * @desc Builds the Kernel, by compiling Fragment and Vertical Shaders,
     * and instantiates the program.
     * @abstract
     */

  }, {
    key: "build",
    value: function build() {
      throw new Error("\"build\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @desc Run the kernel program, and send the output to renderOutput
     * <p> This method calls a helper method *renderOutput* to return the result. </p>
     * @returns {Float32Array|Float32Array[]|Float32Array[][]|void} Result The final output of the program, as float, and as Textures for reuse.
     * @abstract
     */

  }, {
    key: "run",
    value: function run() {
      throw new Error("\"run\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @abstract
     * @return {Object}
     */

  }, {
    key: "initCanvas",
    value: function initCanvas() {
      throw new Error("\"initCanvas\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @abstract
     * @return {Object}
     */

  }, {
    key: "initContext",
    value: function initContext() {
      throw new Error("\"initContext\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @param {IFunctionSettings} settings
     * @return {Object};
     * @abstract
     */

  }, {
    key: "initPlugins",
    value: function initPlugins(settings) {
      throw new Error("\"initPlugins\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @desc Setup the parameter types for the parameters
     * supplied to the Kernel function
     *
     * @param {IArguments} args - The actual parameters sent to the Kernel
     */

  }, {
    key: "setupArguments",
    value: function setupArguments(args) {
      if (!this.argumentTypes) {
        this.kernelArguments = [];

        if (!this.argumentTypes) {
          this.argumentTypes = [];

          for (var i = 0; i < args.length; i++) {
            var argType = utils.getVariableType(args[i], this.strictIntegers);
            this.argumentTypes.push(argType === 'Integer' ? 'Number' : argType);
          }
        }
      } // setup sizes


      this.argumentSizes = new Array(args.length);
      this.argumentBitRatios = new Int32Array(args.length);

      for (var _i = 0; _i < args.length; _i++) {
        var arg = args[_i];
        this.argumentSizes[_i] = arg.constructor === Input ? arg.size : null;
        this.argumentBitRatios[_i] = this.getBitRatio(arg);
      }

      if (this.argumentNames.length !== args.length) {
        throw new Error("arguments are miss-aligned");
      }
    }
    /**
     * Setup constants
     */

  }, {
    key: "setupConstants",
    value: function setupConstants() {
      this.kernelConstants = [];
      this.constantTypes = {};
      this.constantBitRatios = {};

      if (this.constants) {
        for (var p in this.constants) {
          this.constantTypes[p] = utils.getVariableType(this.constants[p], this.strictIntegers);
          this.constantBitRatios[p] = this.getBitRatio(this.constants[p]);
        }
      }
    }
    /**
     *
     * @param flag
     * @returns {Kernel}
     */

  }, {
    key: "setOptimizeFloatMemory",
    value: function setOptimizeFloatMemory(flag) {
      this.optimizeFloatMemory = flag;
      return this;
    }
    /**
     * @desc Set output dimensions of the kernel function
     * @param {Array|Object} output - The output array to set the kernel output size to
     */

  }, {
    key: "setOutput",
    value: function setOutput(output) {
      if (output.hasOwnProperty('x')) {
        if (output.hasOwnProperty('y')) {
          if (output.hasOwnProperty('z')) {
            this.output = [output.x, output.y, output.z];
          } else {
            this.output = [output.x, output.y];
          }
        } else {
          this.output = [output.x];
        }
      } else {
        this.output = output;
      }

      return this;
    }
    /**
     * @desc Toggle debug mode
     * @param {Boolean} flag - true to enable debug
     */

  }, {
    key: "setDebug",
    value: function setDebug(flag) {
      this.debug = flag;
      return this;
    }
    /**
     * @desc Toggle graphical output mode
     * @param {Boolean} flag - true to enable graphical output
     */

  }, {
    key: "setGraphical",
    value: function setGraphical(flag) {
      this.graphical = flag;
      this.precision = 'unsigned';
      return this;
    }
    /**
     * @desc Set the maximum number of loop iterations
     * @param {number} max - iterations count
     */

  }, {
    key: "setLoopMaxIterations",
    value: function setLoopMaxIterations(max) {
      this.loopMaxIterations = max;
      return this;
    }
    /**
     * @desc Set Constants
     */

  }, {
    key: "setConstants",
    value: function setConstants(constants) {
      this.constants = constants;
      return this;
    }
    /**
     *
     * @param {IFunction[]|KernelFunction[]} functions
     * @returns {Kernel}
     */

  }, {
    key: "setFunctions",
    value: function setFunctions(functions) {
      if (typeof functions[0] === 'function') {
        this.functions = functions.map(function (source) {
          return utils.functionToIFunction(source);
        });
      } else {
        this.functions = functions;
      }

      return this;
    }
    /**
     * Set writing to texture on/off
     * @param flag
     * @returns {Kernel}
     */

  }, {
    key: "setPipeline",
    value: function setPipeline(flag) {
      this.pipeline = flag;
      return this;
    }
    /**
     * Set precision to 'unsigned' or 'single'
     * @param {String} flag 'unsigned' or 'single'
     * @returns {Kernel}
     */

  }, {
    key: "setPrecision",
    value: function setPrecision(flag) {
      this.precision = flag;
      return this;
    }
    /**
     * @param flag
     * @returns {Kernel}
     * @deprecated
     */

  }, {
    key: "setOutputToTexture",
    value: function setOutputToTexture(flag) {
      utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
      this.pipeline = flag;
      return this;
    }
    /**
     * Set to immutable
     * @param flag
     * @returns {Kernel}
     */

  }, {
    key: "setImmutable",
    value: function setImmutable(flag) {
      this.immutable = flag;
      return this;
    }
    /**
     * @desc Bind the canvas to kernel
     * @param {Object} canvas
     */

  }, {
    key: "setCanvas",
    value: function setCanvas(canvas) {
      this.canvas = canvas;
      return this;
    }
    /**
     * @param {Boolean} flag
     * @return {Kernel}
     */

  }, {
    key: "setStrictIntegers",
    value: function setStrictIntegers(flag) {
      this.strictIntegers = flag;
      return this;
    }
    /**
     *
     * @param flag
     * @return {Kernel}
     */

  }, {
    key: "setDynamicOutput",
    value: function setDynamicOutput(flag) {
      this.dynamicOutput = flag;
      return this;
    }
    /**
     * @deprecated
     * @param flag
     * @return {Kernel}
     */

  }, {
    key: "setHardcodeConstants",
    value: function setHardcodeConstants(flag) {
      utils.warnDeprecated('method', 'setHardcodeConstants');
      this.setDynamicOutput(flag);
      this.setDynamicArguments(flag);
      return this;
    }
    /**
     *
     * @param flag
     * @return {Kernel}
     */

  }, {
    key: "setDynamicArguments",
    value: function setDynamicArguments(flag) {
      this.dynamicArguments = flag;
      return this;
    }
    /**
     * @param {Boolean} flag
     * @return {Kernel}
     */

  }, {
    key: "setUseLegacyEncoder",
    value: function setUseLegacyEncoder(flag) {
      this.useLegacyEncoder = flag;
      return this;
    }
    /**
     * @deprecated
     * @returns {Object}
     */

  }, {
    key: "getCanvas",
    value: function getCanvas() {
      utils.warnDeprecated('method', 'getCanvas');
      return this.canvas;
    }
    /**
     * @deprecated
     * @returns {Object}
     */

  }, {
    key: "getWebGl",
    value: function getWebGl() {
      utils.warnDeprecated('method', 'getWebGl');
      return this.context;
    }
    /**
     * @desc Bind the webGL instance to kernel
     * @param {WebGLRenderingContext} context - webGl instance to bind
     */

  }, {
    key: "setContext",
    value: function setContext(context) {
      this.context = context;
      return this;
    }
  }, {
    key: "setArgumentTypes",
    value: function setArgumentTypes(argumentTypes) {
      this.argumentTypes = argumentTypes;
      return this;
    }
  }, {
    key: "requestFallback",
    value: function requestFallback(args) {
      if (!this.onRequestFallback) {
        throw new Error("\"onRequestFallback\" not defined on ".concat(this.constructor.name));
      }

      this.fallbackRequested = true;
      return this.onRequestFallback(args);
    }
    /**
     * @desc Validate settings
     * @abstract
     */

  }, {
    key: "validateSettings",
    value: function validateSettings() {
      throw new Error("\"validateSettings\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @desc Add a sub kernel to the root kernel instance.
     * This is what `createKernelMap` uses.
     *
     * @param {ISubKernel} subKernel - function (as a String) of the subKernel to add
     */

  }, {
    key: "addSubKernel",
    value: function addSubKernel(subKernel) {
      if (this.subKernels === null) {
        this.subKernels = [];
      }

      if (!subKernel.source) throw new Error('subKernel missing "source" property');
      if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
      if (!subKernel.name) throw new Error('subKernel missing "name" property');
      this.subKernels.push(subKernel);
      return this;
    }
    /**
     * @desc Destroys all memory associated with this kernel
     * @param {Boolean} [removeCanvasReferences] remove any associated canvas references
     */

  }, {
    key: "destroy",
    value: function destroy(removeCanvasReferences) {
      throw new Error("\"destroy\" called on ".concat(this.constructor.name));
    }
    /**
     * bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4
     * @param value
     * @returns {number}
     */

  }, {
    key: "getBitRatio",
    value: function getBitRatio(value) {
      if (this.precision === 'single') {
        // 8 and 16 are upconverted to float32
        return 4;
      } else if (Array.isArray(value[0])) {
        return this.getBitRatio(value[0]);
      } else if (value.constructor === Input) {
        return this.getBitRatio(value.value);
      }

      switch (value.constructor) {
        case Uint8ClampedArray:
        case Uint8Array:
        case Int8Array:
          return 1;

        case Uint16Array:
        case Int16Array:
          return 2;

        case Float32Array:
        case Int32Array:
        default:
          return 4;
      }
    }
    /**
     * @returns {number[]}
     */

  }, {
    key: "getPixels",
    value: function getPixels() {
      throw new Error("\"getPixels\" called on ".concat(this.constructor.name));
    }
  }, {
    key: "checkOutput",
    value: function checkOutput() {
      if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
      if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');

      for (var i = 0; i < this.output.length; i++) {
        if (isNaN(this.output[i]) || this.output[i] < 1) {
          throw new Error("".concat(this.constructor.name, ".output[").concat(i, "] incorrectly defined as `").concat(this.output[i], "`, needs to be numeric, and greater than 0"));
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var settings = {
        output: this.output,
        threadDim: this.threadDim,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(function (plugin) {
          return plugin.name;
        }) : null,
        returnType: this.returnType
      };
      return {
        settings: settings
      };
    }
  }]);

  return Kernel;
}();

module.exports = {
  Kernel: Kernel
};
},{"../utils":"9h1E","../input":"ryqg"}],"HOQD":[function(require,module,exports) {
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @desc This handles all the raw state, converted state, etc. of a single function.
 * [INTERNAL] A collection of functionNodes.
 * @class
 */
var FunctionBuilder =
/*#__PURE__*/
function () {
  _createClass(FunctionBuilder, null, [{
    key: "fromKernel",

    /**
     *
     * @param {typeof Kernel} kernel
     * @param {FunctionNode} FunctionNode
     * @param {object} [extraNodeOptions]
     * @returns {FunctionBuilder}
     * @static
     */
    value: function fromKernel(kernel, FunctionNode, extraNodeOptions) {
      var kernelArguments = kernel.kernelArguments,
          argumentNames = kernel.argumentNames,
          argumentTypes = kernel.argumentTypes,
          argumentSizes = kernel.argumentSizes,
          argumentBitRatios = kernel.argumentBitRatios,
          constants = kernel.constants,
          constantTypes = kernel.constantTypes,
          constantBitRatios = kernel.constantBitRatios,
          debug = kernel.debug,
          loopMaxIterations = kernel.loopMaxIterations,
          nativeFunctions = kernel.nativeFunctions,
          output = kernel.output,
          optimizeFloatMemory = kernel.optimizeFloatMemory,
          precision = kernel.precision,
          plugins = kernel.plugins,
          source = kernel.source,
          subKernels = kernel.subKernels,
          functions = kernel.functions,
          leadingReturnStatement = kernel.leadingReturnStatement,
          followingReturnStatement = kernel.followingReturnStatement,
          dynamicOutput = kernel.dynamicOutput;

      var needsArgumentType = function needsArgumentType(functionName, index) {
        return functionBuilder.needsArgumentType(functionName, index);
      };

      var assignArgumentType = function assignArgumentType(functionName, index, type) {
        functionBuilder.assignArgumentType(functionName, index, type);
      };

      var lookupReturnType = function lookupReturnType(functionName, ast, requestingNode) {
        return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
      };

      var lookupFunctionArgumentTypes = function lookupFunctionArgumentTypes(functionName) {
        return functionBuilder.lookupFunctionArgumentTypes(functionName);
      };

      var lookupFunctionArgumentName = function lookupFunctionArgumentName(functionName, argumentIndex) {
        return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
      };

      var lookupFunctionArgumentBitRatio = function lookupFunctionArgumentBitRatio(functionName, argumentName) {
        return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
      };

      var triggerImplyArgumentType = function triggerImplyArgumentType(functionName, i, argumentType, requestingNode) {
        functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
      };

      var triggerTrackArgumentSynonym = function triggerTrackArgumentSynonym(functionName, argumentName, calleeFunctionName, argumentIndex) {
        functionBuilder.trackArgumentSynonym(functionName, argumentName, calleeFunctionName, argumentIndex);
      };

      var lookupArgumentSynonym = function lookupArgumentSynonym(originFunctionName, functionName, argumentName) {
        return functionBuilder.lookupArgumentSynonym(originFunctionName, functionName, argumentName);
      };

      var onFunctionCall = function onFunctionCall(functionName, calleeFunctionName, args) {
        functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
      };

      var onNestedFunction = function onNestedFunction(ast, returnType) {
        var argumentNames = [];

        for (var i = 0; i < ast.params.length; i++) {
          argumentNames.push(ast.params[i].name);
        }

        var nestedFunction = new FunctionNode(null, Object.assign({}, nodeOptions, {
          returnType: null,
          ast: ast,
          name: ast.id.name,
          argumentNames: argumentNames,
          lookupReturnType: lookupReturnType,
          lookupFunctionArgumentTypes: lookupFunctionArgumentTypes,
          lookupFunctionArgumentName: lookupFunctionArgumentName,
          lookupFunctionArgumentBitRatio: lookupFunctionArgumentBitRatio,
          needsArgumentType: needsArgumentType,
          assignArgumentType: assignArgumentType,
          triggerImplyArgumentType: triggerImplyArgumentType,
          triggerTrackArgumentSynonym: triggerTrackArgumentSynonym,
          lookupArgumentSynonym: lookupArgumentSynonym,
          onFunctionCall: onFunctionCall
        }));
        nestedFunction.traceFunctionAST(ast);
        functionBuilder.addFunctionNode(nestedFunction);
      };

      var nodeOptions = Object.assign({
        isRootKernel: false,
        onNestedFunction: onNestedFunction,
        lookupReturnType: lookupReturnType,
        lookupFunctionArgumentTypes: lookupFunctionArgumentTypes,
        lookupFunctionArgumentName: lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio: lookupFunctionArgumentBitRatio,
        needsArgumentType: needsArgumentType,
        assignArgumentType: assignArgumentType,
        triggerImplyArgumentType: triggerImplyArgumentType,
        triggerTrackArgumentSynonym: triggerTrackArgumentSynonym,
        lookupArgumentSynonym: lookupArgumentSynonym,
        onFunctionCall: onFunctionCall,
        optimizeFloatMemory: optimizeFloatMemory,
        precision: precision,
        constants: constants,
        constantTypes: constantTypes,
        constantBitRatios: constantBitRatios,
        debug: debug,
        loopMaxIterations: loopMaxIterations,
        output: output,
        plugins: plugins,
        dynamicOutput: dynamicOutput
      }, extraNodeOptions || {});
      var rootNodeOptions = Object.assign({}, nodeOptions, {
        isRootKernel: true,
        name: 'kernel',
        argumentNames: argumentNames,
        argumentTypes: argumentTypes,
        argumentSizes: argumentSizes,
        argumentBitRatios: argumentBitRatios,
        leadingReturnStatement: leadingReturnStatement,
        followingReturnStatement: followingReturnStatement
      });

      if (_typeof(source) === 'object' && source.functionNodes) {
        return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
      }

      var rootNode = new FunctionNode(source, rootNodeOptions);
      var functionNodes = null;

      if (functions) {
        functionNodes = functions.map(function (fn) {
          return new FunctionNode(fn.source, {
            returnType: fn.returnType,
            argumentTypes: fn.argumentTypes,
            output: output,
            plugins: plugins,
            constants: constants,
            constantTypes: constantTypes,
            constantBitRatios: constantBitRatios,
            optimizeFloatMemory: optimizeFloatMemory,
            precision: precision,
            lookupReturnType: lookupReturnType,
            lookupFunctionArgumentTypes: lookupFunctionArgumentTypes,
            lookupFunctionArgumentName: lookupFunctionArgumentName,
            lookupFunctionArgumentBitRatio: lookupFunctionArgumentBitRatio,
            needsArgumentType: needsArgumentType,
            assignArgumentType: assignArgumentType,
            triggerImplyArgumentType: triggerImplyArgumentType,
            triggerTrackArgumentSynonym: triggerTrackArgumentSynonym,
            lookupArgumentSynonym: lookupArgumentSynonym,
            onFunctionCall: onFunctionCall
          });
        });
      }

      var subKernelNodes = null;

      if (subKernels) {
        subKernelNodes = subKernels.map(function (subKernel) {
          var name = subKernel.name,
              source = subKernel.source;
          return new FunctionNode(source, Object.assign({}, nodeOptions, {
            name: name,
            isSubKernel: true,
            isRootKernel: false
          }));
        });
      }

      var functionBuilder = new FunctionBuilder({
        kernel: kernel,
        rootNode: rootNode,
        functionNodes: functionNodes,
        nativeFunctions: nativeFunctions,
        subKernelNodes: subKernelNodes
      });
      return functionBuilder;
    }
    /**
     *
     * @param {IFunctionBuilderSettings} [settings]
     */

  }]);

  function FunctionBuilder(settings) {
    _classCallCheck(this, FunctionBuilder);

    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.argumentChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (var i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (var _i = 0; _i < this.subKernelNodes.length; _i++) {
        this.functionMap[this.subKernelNodes[_i].name] = this.subKernelNodes[_i];
      }
    }

    if (this.nativeFunctions) {
      for (var _i2 = 0; _i2 < this.nativeFunctions.length; _i2++) {
        var nativeFunction = this.nativeFunctions[_i2];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }
  /**
   * @desc Add the function node directly
   *
   * @param {FunctionNode} functionNode - functionNode to add
   *
   */


  _createClass(FunctionBuilder, [{
    key: "addFunctionNode",
    value: function addFunctionNode(functionNode) {
      if (!functionNode.name) throw new Error('functionNode.name needs set');
      this.functionMap[functionNode.name] = functionNode;

      if (functionNode.isRootKernel) {
        this.rootNode = functionNode;
      }
    }
    /**
     * @desc Trace all the depending functions being called, from a single function
     *
     * This allow for 'unneeded' functions to be automatically optimized out.
     * Note that the 0-index, is the starting function trace.
     *
     * @param {String} functionName - Function name to trace from, default to 'kernel'
     * @param {String[]} [retList] - Returning list of function names that is traced. Including itself.
     *
     * @returns {String[]}  Returning list of function names that is traced. Including itself.
     */

  }, {
    key: "traceFunctionCalls",
    value: function traceFunctionCalls(functionName, retList) {
      functionName = functionName || 'kernel';
      retList = retList || [];

      if (this.nativeFunctionNames.indexOf(functionName) > -1) {
        if (retList.indexOf(functionName) === -1) {
          retList.push(functionName);
        }

        return retList;
      }

      var functionNode = this.functionMap[functionName];

      if (functionNode) {
        // Check if function already exists
        var functionIndex = retList.indexOf(functionName);

        if (functionIndex === -1) {
          retList.push(functionName);
          functionNode.toString(); //ensure JS trace is done

          for (var i = 0; i < functionNode.calledFunctions.length; ++i) {
            this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
          }
        } else {
          /**
           * https://github.com/gpujs/gpu.js/issues/207
           * if dependent function is already in the list, because a function depends on it, and because it has
           * already been traced, we know that we must move the dependent function to the end of the the retList.
           * */
          var dependantFunctionName = retList.splice(functionIndex, 1)[0];
          retList.push(dependantFunctionName);
        }
      }

      return retList;
    }
    /**
     * @desc Return the string for a function
     * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
     * @returns {String} The full string, of all the various functions. Trace optimized if functionName given
     */

  }, {
    key: "getPrototypeString",
    value: function getPrototypeString(functionName) {
      return this.getPrototypes(functionName).join('\n');
    }
    /**
     * @desc Return the string for a function
     * @param {String} [functionName] - Function name to trace from. If null, it returns the WHOLE builder stack
     * @returns {Array} The full string, of all the various functions. Trace optimized if functionName given
     */

  }, {
    key: "getPrototypes",
    value: function getPrototypes(functionName) {
      if (this.rootNode) {
        this.rootNode.toString();
      }

      if (functionName) {
        return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
      }

      return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
    }
    /**
     * @desc Get string from function names
     * @param {String[]} functionList - List of function to build string
     * @returns {String} The string, of all the various functions. Trace optimized if functionName given
     */

  }, {
    key: "getStringFromFunctionNames",
    value: function getStringFromFunctionNames(functionList) {
      var ret = [];

      for (var i = 0; i < functionList.length; ++i) {
        var node = this.functionMap[functionList[i]];

        if (node) {
          ret.push(this.functionMap[functionList[i]].toString());
        }
      }

      return ret.join('\n');
    }
    /**
     * @desc Return string of all functions converted
     * @param {String[]} functionList - List of function names to build the string.
     * @returns {Array} Prototypes of all functions converted
     */

  }, {
    key: "getPrototypesFromFunctionNames",
    value: function getPrototypesFromFunctionNames(functionList) {
      var ret = [];

      for (var i = 0; i < functionList.length; ++i) {
        var functionName = functionList[i];
        var functionIndex = this.nativeFunctionNames.indexOf(functionName);

        if (functionIndex > -1) {
          ret.push(this.nativeFunctions[functionIndex].source);
          continue;
        }

        var node = this.functionMap[functionName];

        if (node) {
          ret.push(node.toString());
        }
      }

      return ret;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this = this;

      return this.traceFunctionCalls(this.rootNode.name).reverse().map(function (name) {
        var nativeIndex = _this.nativeFunctions.indexOf(name);

        if (nativeIndex > -1) {
          return {
            name: name,
            source: _this.nativeFunctions[nativeIndex].source
          };
        } else if (_this.functionMap[name]) {
          return _this.functionMap[name].toJSON();
        } else {
          throw new Error("function ".concat(name, " not found"));
        }
      });
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(jsonFunctionNodes, FunctionNode) {
      this.functionMap = {};

      for (var i = 0; i < jsonFunctionNodes.length; i++) {
        var jsonFunctionNode = jsonFunctionNodes[i];
        this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
      }

      return this;
    }
    /**
     * @desc Get string for a particular function name
     * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
     * @returns {String} settings - The string, of all the various functions. Trace optimized if functionName given
     */

  }, {
    key: "getString",
    value: function getString(functionName) {
      if (functionName) {
        return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
      }

      return this.getStringFromFunctionNames(Object.keys(this.functionMap));
    }
  }, {
    key: "lookupReturnType",
    value: function lookupReturnType(functionName, ast, requestingNode) {
      if (ast.type !== 'CallExpression') {
        throw new Error("expected ast type of \"CallExpression\", but is ".concat(ast.type));
      }

      if (this._isNativeFunction(functionName)) {
        return this._lookupNativeFunctionReturnType(functionName);
      } else if (this._isFunction(functionName)) {
        var node = this._getFunction(functionName);

        if (node.returnType) {
          return node.returnType;
        } else {
          for (var i = 0; i < this.lookupChain.length; i++) {
            // detect circlical logic
            if (this.lookupChain[i].ast === ast) {
              // detect if arguments have not resolved, preventing a return type
              // if so, go ahead and resolve them, so we can resolve the return type
              if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
                var args = ast.arguments;

                for (var j = 0; j < args.length; j++) {
                  this.lookupChain.push({
                    name: requestingNode.name,
                    ast: args[i],
                    requestingNode: requestingNode
                  });
                  node.argumentTypes[j] = requestingNode.getType(args[j]);
                  this.lookupChain.pop();
                }

                return node.returnType = node.getType(node.getJsAST());
              }

              throw new Error('circlical logic detected!');
            }
          } // get ready for a ride!


          this.lookupChain.push({
            name: requestingNode.name,
            ast: ast,
            requestingNode: requestingNode
          });
          var type = node.getType(node.getJsAST());
          this.lookupChain.pop();
          return node.returnType = type;
        }
      } // function not found, maybe native?


      return null;
      /**
       * first iteration
       * kernel.outputs = Array
       * kernel.targets = Array
       * kernel.returns = null
       * kernel.calls.calcErrorOutput = [kernel.output, kernel.targets]
       * kernel.calls.calcDeltas = [calcErrorOutput.returns, kernel.output]
       * calcErrorOutput.output = null
       * calcErrorOutput.targets = null
       * calcErrorOutput.returns = null
       * calcDeltasSigmoid.error = null
       * calcDeltasSigmoid.output = Number
       * calcDeltasSigmoid.returns = null
       *
       * resolvable are:
       * calcErrorOutput.output
       * calcErrorOutput.targets
       * calcErrorOutput.returns
       *
       * second iteration
       * kernel.outputs = Array
       * kernel.targets = Array
       * kernel.returns = null
       * kernel.calls.calcErrorOutput = [kernel.output, kernel.targets]
       * kernel.calls.calcDeltas = [calcErrorOutput.returns, kernel.output]
       * calcErrorOutput.output = Number
       * calcErrorOutput.targets = Array
       * calcErrorOutput.returns = Number
       * calcDeltasSigmoid.error = null
       * calcDeltasSigmoid.output = Number
       * calcDeltasSigmoid.returns = null
       *
       * resolvable are:
       * calcDeltasSigmoid.error
       * calcDeltasSigmoid.returns
       * kernel.returns
       *
       * third iteration
       * kernel.outputs = Array
       * kernel.targets = Array
       * kernel.returns = Number
       * kernel.calls.calcErrorOutput = [kernel.output, kernel.targets]
       * kernel.calls.calcDeltas = [calcErrorOutput.returns, kernel.output]
       * calcErrorOutput.output = Number
       * calcErrorOutput.targets = Array
       * calcErrorOutput.returns = Number
       * calcDeltasSigmoid.error = Number
       * calcDeltasSigmoid.output = Number
       * calcDeltasSigmoid.returns = Number
       *
       *
       */
    }
  }, {
    key: "_getFunction",
    value: function _getFunction(functionName) {
      if (!this._isFunction(functionName)) {
        new Error("Function ".concat(functionName, " not found"));
      }

      return this.functionMap[functionName];
    }
  }, {
    key: "_isFunction",
    value: function _isFunction(functionName) {
      return Boolean(this.functionMap[functionName]);
    }
  }, {
    key: "_getNativeFunction",
    value: function _getNativeFunction(functionName) {
      for (var i = 0; i < this.nativeFunctions.length; i++) {
        if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
      }

      return null;
    }
  }, {
    key: "_isNativeFunction",
    value: function _isNativeFunction(functionName) {
      return Boolean(this._getNativeFunction(functionName));
    }
  }, {
    key: "_lookupNativeFunctionReturnType",
    value: function _lookupNativeFunctionReturnType(functionName) {
      var nativeFunction = this._getNativeFunction(functionName);

      if (nativeFunction) {
        return nativeFunction.returnType;
      }

      throw new Error("Native function ".concat(functionName, " not found"));
    }
  }, {
    key: "lookupFunctionArgumentTypes",
    value: function lookupFunctionArgumentTypes(functionName) {
      if (this._isNativeFunction(functionName)) {
        return this._getNativeFunction(functionName).argumentTypes;
      } else if (this._isFunction(functionName)) {
        return this._getFunction(functionName).argumentTypes;
      }

      return null;
    }
  }, {
    key: "lookupFunctionArgumentName",
    value: function lookupFunctionArgumentName(functionName, argumentIndex) {
      return this._getFunction(functionName).argumentNames[argumentIndex];
    }
  }, {
    key: "lookupFunctionArgumentBitRatio",
    value: function lookupFunctionArgumentBitRatio(functionName, argumentName) {
      if (!this._isFunction(functionName)) {
        throw new Error('function not found');
      }

      if (this.rootNode.name === functionName) {
        var i = this.rootNode.argumentNames.indexOf(argumentName);

        if (i !== -1) {
          return this.rootNode.argumentBitRatios[i];
        } else {
          throw new Error('argument bit ratio not found');
        }
      } else {
        var node = this._getFunction(functionName);

        var argumentSynonym = node.argumentSynonym[node.synonymIndex];

        if (!argumentSynonym) {
          throw new Error('argument synonym not found');
        }

        return this.lookupFunctionArgumentBitRatio(argumentSynonym.functionName, argumentSynonym.argumentName);
      }
    }
  }, {
    key: "needsArgumentType",
    value: function needsArgumentType(functionName, i) {
      if (!this._isFunction(functionName)) return false;

      var fnNode = this._getFunction(functionName);

      return !fnNode.argumentTypes[i];
    }
  }, {
    key: "assignArgumentType",
    value: function assignArgumentType(functionName, i, argumentType, requestingNode) {
      if (!this._isFunction(functionName)) return;

      var fnNode = this._getFunction(functionName);

      if (!fnNode.argumentTypes[i]) {
        fnNode.argumentTypes[i] = argumentType;
      }
    }
  }, {
    key: "trackArgumentSynonym",
    value: function trackArgumentSynonym(functionName, argumentName, calleeFunctionName, argumentIndex) {
      if (!this._isFunction(calleeFunctionName)) return;

      var node = this._getFunction(calleeFunctionName);

      if (!node.argumentSynonym) {
        node.argumentSynonym = {};
      }

      var calleeArgumentName = node.argumentNames[argumentIndex];

      if (!node.argumentSynonym[calleeArgumentName]) {
        node.argumentSynonym[calleeArgumentName] = {};
      }

      node.synonymIndex++;
      node.argumentSynonym[node.synonymIndex] = {
        functionName: functionName,
        argumentName: argumentName,
        calleeArgumentName: calleeArgumentName,
        calleeFunctionName: calleeFunctionName
      };
    }
  }, {
    key: "lookupArgumentSynonym",
    value: function lookupArgumentSynonym(originFunctionName, functionName, argumentName) {
      if (originFunctionName === functionName) return argumentName;
      if (!this._isFunction(functionName)) return null;

      var node = this._getFunction(functionName);

      var argumentSynonym = node.argumentSynonym[node.synonymUseIndex];
      if (!argumentSynonym) return null;
      if (argumentSynonym.calleeArgumentName !== argumentName) return null;
      node.synonymUseIndex++;

      if (originFunctionName !== functionName) {
        return this.lookupArgumentSynonym(originFunctionName, argumentSynonym.functionName, argumentSynonym.argumentName);
      }

      return argumentSynonym.argumentName;
    }
  }, {
    key: "trackFunctionCall",
    value: function trackFunctionCall(functionName, calleeFunctionName, args) {
      if (!this.functionNodeDependencies[functionName]) {
        this.functionNodeDependencies[functionName] = new Set();
        this.functionCalls[functionName] = [];
      }

      this.functionNodeDependencies[functionName].add(calleeFunctionName);
      this.functionCalls[functionName].push(args);
    }
  }, {
    key: "getKernelResultType",
    value: function getKernelResultType() {
      return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
    }
  }, {
    key: "getSubKernelResultType",
    value: function getSubKernelResultType(index) {
      var subKernelNode = this.subKernelNodes[index];
      var called = false;

      for (var functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
        var functionCall = this.rootNode.functionCalls[functionCallIndex];

        if (functionCall.ast.callee.name === subKernelNode.name) {
          called = true;
        }
      }

      if (!called) {
        throw new Error("SubKernel ".concat(subKernelNode.name, " never called by kernel"));
      }

      return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
    }
  }, {
    key: "getReturnTypes",
    value: function getReturnTypes() {
      var result = _defineProperty({}, this.rootNode.name, this.rootNode.getType(this.rootNode.ast));

      var list = this.traceFunctionCalls(this.rootNode.name);

      for (var i = 0; i < list.length; i++) {
        var functionName = list[i];
        var functionNode = this.functionMap[functionName];
        result[functionName] = functionNode.getType(functionNode.ast);
      }

      return result;
    }
  }]);

  return FunctionBuilder;
}();

module.exports = {
  FunctionBuilder: FunctionBuilder
};
},{}],"mAsJ":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FunctionTracer =
/*#__PURE__*/
function () {
  function FunctionTracer(ast) {
    _classCallCheck(this, FunctionTracer);

    this.runningContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.inLoopInit = false;
    this.scan(ast);
  }

  _createClass(FunctionTracer, [{
    key: "newContext",
    value: function newContext(run) {
      var newContext = Object.assign({}, this.currentContext);
      this.contexts.push(newContext);
      this.runningContexts.push(newContext);
      run();
      this.runningContexts.pop();
    }
    /**
     * Recursively scans AST for declarations and functions, and add them to their respective context
     * @param ast
     */

  }, {
    key: "scan",
    value: function scan(ast) {
      var _this = this;

      if (Array.isArray(ast)) {
        for (var i = 0; i < ast.length; i++) {
          this.scan(ast[i]);
        }

        return;
      }

      switch (ast.type) {
        case 'Program':
          this.scan(ast.body);
          break;

        case 'BlockStatement':
          this.newContext(function () {
            _this.scan(ast.body);
          });
          break;

        case 'AssignmentExpression':
          this.scan(ast.left);
          this.scan(ast.right);
          break;

        case 'BinaryExpression':
          this.scan(ast.left);
          if (ast.right) this.scan(ast.right);
          break;

        case 'UpdateExpression':
          this.scan(ast.argument);
          break;

        case 'UnaryExpression':
          this.scan(ast.argument);
          break;

        case 'VariableDeclaration':
          this.scan(ast.declarations);
          break;

        case 'VariableDeclarator':
          var currentContext = this.currentContext;
          var declaration = {
            ast: ast,
            context: currentContext,
            name: ast.id.name,
            origin: 'declaration',
            forceInteger: this.inLoopInit,
            assignable: !this.inLoopInit && !currentContext.hasOwnProperty(ast.id.name)
          };
          currentContext[ast.id.name] = declaration;
          this.declarations.push(declaration);
          this.scan(ast.id);
          this.scan(ast.init);
          break;

        case 'FunctionExpression':
        case 'FunctionDeclaration':
          if (this.runningContexts.length === 0) {
            this.scan(ast.body);
          } else {
            this.functions.push(ast);
          }

          break;

        case 'IfStatement':
          this.scan(ast.test);
          this.scan(ast.consequent);
          if (ast.alternate) this.scan(ast.alternate);
          break;

        case 'ForStatement':
          this.newContext(function () {
            if (ast.init) {
              _this.inLoopInit = true;

              _this.scan(ast.init);

              _this.inLoopInit = false;
            }

            if (ast.test) {
              _this.scan(ast.test);
            }

            _this.scan(ast.update);

            _this.newContext(function () {
              _this.scan(ast.body);
            });
          });
          break;

        case 'DoWhileStatement':
        case 'WhileStatement':
          this.newContext(function () {
            _this.scan(ast.body);

            _this.scan(ast.test);
          });
          break;

        case 'Identifier':
          this.identifiers.push({
            context: this.currentContext,
            ast: ast
          });
          break;

        case 'ReturnStatement':
          this.returnStatements.push(ast);
          this.scan(ast.argument);
          break;

        case 'MemberExpression':
          this.scan(ast.object);
          this.scan(ast.property);
          break;

        case 'ExpressionStatement':
          this.scan(ast.expression);
          break;

        case 'ThisExpression':
          break;

        case 'CallExpression':
          this.functionCalls.push({
            context: this.currentContext,
            ast: ast
          });
          this.scan(ast.arguments);
          break;

        case 'ArrayExpression':
          this.scan(ast.elements);
          break;

        case 'ConditionalExpression':
          this.scan(ast.consequent);
          this.scan(ast.alternate);
          this.scan(ast.consequent);
          break;

        case 'SwitchStatement':
          this.scan(ast.discriminant);
          this.scan(ast.cases);
          break;

        case 'SwitchCase':
          if (ast.test) this.scan(ast.test);
          this.scan(ast.consequent);
          break;

        case 'LogicalExpression':
          this.scan(ast.left);
          this.scan(ast.right);
          break;

        case 'Literal':
          break;

        case 'DebuggerStatement':
          break;

        case 'EmptyStatement':
          break;

        case 'BreakStatement':
          break;

        default:
          throw new Error("unhandled type \"".concat(ast.type, "\""));
      }
    }
  }, {
    key: "currentContext",
    get: function get() {
      return this.runningContexts.length > 0 ? this.runningContexts[this.runningContexts.length - 1] : null;
    }
  }]);

  return FunctionTracer;
}();

module.exports = {
  FunctionTracer: FunctionTracer
};
},{}],"oNAw":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var acorn = require('acorn');

var _require = require('../utils'),
    utils = _require.utils;

var _require2 = require('./function-tracer'),
    FunctionTracer = _require2.FunctionTracer;
/**
 *
 * @desc Represents a single function, inside JS, webGL, or openGL.
 * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
 */


var FunctionNode =
/*#__PURE__*/
function () {
  /**
   *
   * @param {string|object} source
   * @param {IFunctionSettings} [settings]
   */
  function FunctionNode(source, settings) {
    _classCallCheck(this, FunctionNode);

    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }

    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ? 'kernel' : settings.name || utils.getFunctionNameFromString(source) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.declarations = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerTrackArgumentSynonym = null;
    this.lookupArgumentSynonym = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null;
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.strictTypingChecking = false;

    if (settings) {
      for (var p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.synonymIndex = -1;
    this.synonymUseIndex = 0;
    this.argumentSynonym = {};
    this.literalTypes = {};
    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  _createClass(FunctionNode, [{
    key: "validate",
    value: function validate() {
      if (typeof this.source !== 'string' && !this.ast) {
        throw new Error('this.source not a string');
      }

      if (!this.ast && !utils.isFunctionString(this.source)) {
        throw new Error('this.source not a function string');
      }

      if (!this.name) {
        throw new Error('this.name could not be set');
      }

      if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
        throw new Error("argumentTypes count of ".concat(this.argumentTypes.length, " exceeds ").concat(this.argumentNames.length));
      }

      if (this.output.length < 1) {
        throw new Error('this.output is not big enough');
      }
    }
    /**
     * @param {String} name
     * @returns {boolean}
     */

  }, {
    key: "isIdentifierConstant",
    value: function isIdentifierConstant(name) {
      if (!this.constants) return false;
      return this.constants.hasOwnProperty(name);
    }
  }, {
    key: "isInput",
    value: function isInput(argumentName) {
      return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
    }
  }, {
    key: "pushState",
    value: function pushState(state) {
      this.states.push(state);
    }
  }, {
    key: "popState",
    value: function popState(state) {
      if (this.state !== state) {
        throw new Error("Cannot popState ".concat(state, " when in ").concat(this.state));
      }

      this.states.pop();
    }
  }, {
    key: "isState",
    value: function isState(state) {
      return this.state === state;
    }
  }, {
    key: "astMemberExpressionUnroll",

    /**
     * @function
     * @name astMemberExpressionUnroll
     * @desc Parses the abstract syntax tree for binary expression.
     *
     * <p>Utility function for astCallExpression.</p>
     *
     * @param {Object} ast - the AST object to parse
     *
     * @returns {String} the function namespace call, unrolled
     */
    value: function astMemberExpressionUnroll(ast) {
      if (ast.type === 'Identifier') {
        return ast.name;
      } else if (ast.type === 'ThisExpression') {
        return 'this';
      }

      if (ast.type === 'MemberExpression') {
        if (ast.object && ast.property) {
          //babel sniffing
          if (ast.object.hasOwnProperty('name') && ast.object.name[0] === '_') {
            return this.astMemberExpressionUnroll(ast.property);
          }

          return this.astMemberExpressionUnroll(ast.object) + '.' + this.astMemberExpressionUnroll(ast.property);
        }
      } //babel sniffing


      if (ast.hasOwnProperty('expressions')) {
        var firstExpression = ast.expressions[0];

        if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
          return this.astMemberExpressionUnroll(ast.expressions[1]);
        }
      } // Failure, unknown expression


      throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
    }
    /**
     * @desc Parses the class function JS, and returns its Abstract Syntax Tree object.
     * This is used internally to convert to shader code
     *
     * @param {Object} [inParser] - Parser to use, assumes in scope 'parser' if null or undefined
     *
     * @returns {Object} The function AST Object, note that result is cached under this.ast;
     */

  }, {
    key: "getJsAST",
    value: function getJsAST(inParser) {
      if (this.ast) {
        return this.ast;
      }

      if (_typeof(this.source) === 'object') {
        this.traceFunctionAST(this.source);
        return this.ast = this.source;
      }

      inParser = inParser || acorn;

      if (inParser === null) {
        throw new Error('Missing JS to AST parser');
      }

      var ast = Object.freeze(inParser.parse("const parser_".concat(this.name, " = ").concat(this.source, ";"), {
        locations: true
      })); // take out the function object, outside the var declarations

      var functionAST = ast.body[0].declarations[0].init;
      this.traceFunctionAST(functionAST);

      if (!ast) {
        throw new Error('Failed to parse JS code');
      }

      return this.ast = functionAST;
    }
  }, {
    key: "traceFunctionAST",
    value: function traceFunctionAST(ast) {
      var _ref = new FunctionTracer(ast),
          contexts = _ref.contexts,
          declarations = _ref.declarations,
          functions = _ref.functions,
          identifiers = _ref.identifiers,
          functionCalls = _ref.functionCalls;

      this.contexts = contexts;
      this.identifiers = identifiers;
      this.functionCalls = functionCalls;
      this.declarations = [];
      this.functions = functions;

      for (var i = 0; i < declarations.length; i++) {
        var declaration = declarations[i];
        var _ast = declaration.ast,
            context = declaration.context,
            _name = declaration.name,
            origin = declaration.origin,
            forceInteger = declaration.forceInteger,
            assignable = declaration.assignable;
        var init = _ast.init;
        var dependencies = this.getDependencies(init);
        var valueType = null;

        if (forceInteger) {
          valueType = 'Integer';
        } else {
          if (init) {
            var realType = this.getType(init);

            switch (realType) {
              case 'Integer':
              case 'Float':
              case 'Number':
                if (init.type === 'MemberExpression') {
                  valueType = realType;
                } else {
                  valueType = 'Number';
                }

                break;

              case 'LiteralInteger':
                valueType = 'Number';
                break;

              default:
                valueType = realType;
            }
          }
        }

        this.declarations.push({
          valueType: valueType,
          dependencies: dependencies,
          isSafe: this.isSafeDependencies(dependencies),
          ast: _ast,
          name: _name,
          context: context,
          origin: origin,
          assignable: assignable
        });
      }

      for (var _i = 0; _i < functions.length; _i++) {
        this.onNestedFunction(functions[_i]);
      }
    }
  }, {
    key: "getDeclaration",
    value: function getDeclaration(ast) {
      for (var i = 0; i < this.identifiers.length; i++) {
        var identifier = this.identifiers[i];

        if (ast === identifier.ast && identifier.context.hasOwnProperty(ast.name)) {
          for (var j = 0; j < this.declarations.length; j++) {
            var declaration = this.declarations[j];

            if (declaration.name === ast.name && declaration.context[ast.name] === identifier.context[ast.name]) {
              return declaration;
            }
          }
        }
      }

      return null;
    }
    /**
     * @desc Return the type of parameter sent to subKernel/Kernel.
     * @param {Object} ast - Identifier
     * @returns {String} Type of the parameter
     */

  }, {
    key: "getVariableType",
    value: function getVariableType(ast) {
      if (ast.type !== 'Identifier') {
        throw new Error("ast of ".concat(ast.type, " not \"Identifier\""));
      }

      var type = null;
      var argumentIndex = this.argumentNames.indexOf(ast.name);

      if (argumentIndex === -1) {
        var declaration = this.getDeclaration(ast);

        if (declaration) {
          return declaration.valueType;
        }
      } else {
        var argumentType = this.argumentTypes[argumentIndex];

        if (argumentType) {
          type = argumentType;
        }
      }

      if (!type && this.strictTypingChecking) {
        throw new Error("Declaration of ".concat(name, " not found"));
      }

      return type;
    }
    /**
     * Generally used to lookup the value type returned from a member expressions
     * @param {String} type
     * @return {String}
     */

  }, {
    key: "getLookupType",
    value: function getLookupType(type) {
      if (!typeLookupMap.hasOwnProperty(type)) {
        throw new Error("unknown typeLookupMap ".concat(type));
      }

      return typeLookupMap[type];
    }
  }, {
    key: "getConstantType",
    value: function getConstantType(constantName) {
      if (this.constantTypes[constantName]) {
        var type = this.constantTypes[constantName];

        if (type === 'Float') {
          return 'Number';
        } else {
          return type;
        }
      }

      throw new Error("Type for constant \"".concat(constantName, "\" not declared"));
    }
    /**
     * @desc Return the name of the *user argument*(subKernel argument) corresponding
     * to the argument supplied to the kernel
     *
     * @param {String} name - Name of the argument
     * @returns {String} Name of the parameter
     */

  }, {
    key: "getKernelArgumentName",
    value: function getKernelArgumentName(name) {
      if (!this.lookupArgumentSynonym) return null;
      var argumentIndex = this.argumentNames.indexOf(name);
      if (argumentIndex === -1) return null;
      return this.lookupArgumentSynonym('kernel', this.name, name);
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this._string) return this._string;
      return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var settings = {
        source: this.source,
        name: this.name,
        constants: this.constants,
        constantTypes: this.constantTypes,
        isRootKernel: this.isRootKernel,
        isSubKernel: this.isSubKernel,
        debug: this.debug,
        output: this.output,
        loopMaxIterations: this.loopMaxIterations,
        argumentNames: this.argumentNames,
        argumentTypes: this.argumentTypes,
        argumentSizes: this.argumentSizes,
        returnType: this.returnType,
        leadingReturnStatement: this.leadingReturnStatement,
        followingReturnStatement: this.followingReturnStatement
      };
      return {
        ast: this.ast,
        settings: settings
      };
    }
    /**
     * Recursively looks up type for ast expression until it's found
     * @param ast
     * @returns {String|null}
     */

  }, {
    key: "getType",
    value: function getType(ast) {
      if (Array.isArray(ast)) {
        return this.getType(ast[ast.length - 1]);
      }

      switch (ast.type) {
        case 'BlockStatement':
          return this.getType(ast.body);

        case 'ArrayExpression':
          return "Array(".concat(ast.elements.length, ")");

        case 'Literal':
          var literalKey = "".concat(ast.start, ",").concat(ast.end);

          if (this.literalTypes[literalKey]) {
            return this.literalTypes[literalKey];
          }

          if (Number.isInteger(ast.value)) {
            return 'LiteralInteger';
          } else if (ast.value === true || ast.value === false) {
            return 'Boolean';
          } else {
            return 'Number';
          }

        case 'AssignmentExpression':
          return this.getType(ast.left);

        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }

          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              var functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }

            throw this.astErrorOutput('Unknown call expression', ast);
          }

          if (ast.callee && ast.callee.name) {
            var _functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(_functionName, ast.arguments);
            return this.lookupReturnType(_functionName, ast, this);
          }

          throw this.astErrorOutput("Unhandled getType Type \"".concat(ast.type, "\""), ast);

        case 'BinaryExpression':
          // modulos is Number
          switch (ast.operator) {
            case '%':
              return 'Number';

            case '>':
            case '<':
              return 'Boolean';

            case '&':
            case '|':
            case '^':
            case '<<':
            case '>>':
            case '>>>':
              return 'Integer';
          }

          var type = this.getType(ast.left);
          return typeLookupMap[type] || type;

        case 'UpdateExpression':
          return this.getType(ast.argument);

        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }

          return this.getType(ast.argument);

        case 'VariableDeclaration':
          {
            var declarations = ast.declarations;
            var lastType;

            for (var i = 0; i < declarations.length; i++) {
              var _declaration = declarations[i];
              lastType = this.getType(_declaration);
            }

            if (!lastType) {
              throw this.astErrorOutput("Unable to find type for declaration", ast);
            }

            return lastType;
          }

        case 'VariableDeclarator':
          var declaration = this.getDeclaration(ast.id);

          if (!declaration) {
            throw this.astErrorOutput("Unable to find declarator", ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput("Unable to find declarator valueType", ast);
          }

          return declaration.valueType;

        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }

          if (this.isAstVariable(ast)) {
            var signature = this.getVariableSignature(ast);

            if (signature === 'value') {
              var _type = this.getVariableType(ast);

              if (!_type) {
                throw this.astErrorOutput("Unable to find identifier valueType", ast);
              }

              return _type;
            }
          }

          var origin = this.findIdentifierOrigin(ast);

          if (origin && origin.init) {
            return this.getType(origin.init);
          }

          return null;

        case 'ReturnStatement':
          return this.getType(ast.argument);

        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';

              case 'floor':
                return 'Integer';

              case 'round':
                return 'Integer';
            }

            return 'Number';
          }

          if (this.isAstVariable(ast)) {
            var variableSignature = this.getVariableSignature(ast);

            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getVariableType(ast.object));

              case 'value[][]':
                return this.getLookupType(this.getVariableType(ast.object.object));

              case 'value[][][]':
                return this.getLookupType(this.getVariableType(ast.object.object.object));

              case 'value[][][][]':
                return this.getLookupType(this.getVariableType(ast.object.object.object.object));

              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';

              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';

              case 'this.constants.value':
                return this.getConstantType(ast.property.name);

              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));

              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));

              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));

              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));

              case 'fn()[]':
                return this.getLookupType(this.getType(ast.object));

              case 'fn()[][]':
                return this.getLookupType(this.getType(ast.object));

              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));

              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }

                switch (ast.property.name) {
                  case 'r':
                    return this.getLookupType(this.getVariableType(ast.object));

                  case 'g':
                    return this.getLookupType(this.getVariableType(ast.object));

                  case 'b':
                    return this.getLookupType(this.getVariableType(ast.object));

                  case 'a':
                    return this.getLookupType(this.getVariableType(ast.object));
                }

              case '[][]':
                return 'Number';
            }

            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }

          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);

        case 'ConditionalExpression':
          return this.getType(ast.consequent);

        case 'FunctionDeclaration':
        case 'FunctionExpression':
          var lastReturn = this.findLastReturn(ast.body);

          if (lastReturn) {
            return this.getType(lastReturn);
          }

          return null;

        case 'IfStatement':
          return this.getType(ast.consequent);

        default:
          throw this.astErrorOutput("Unhandled getType Type \"".concat(ast.type, "\""), ast);
      }
    }
  }, {
    key: "inferArgumentTypesIfNeeded",
    value: function inferArgumentTypesIfNeeded(functionName, args) {
      // ensure arguments are filled in, so when we lookup return type, we already can infer it
      for (var i = 0; i < args.length; i++) {
        if (!this.needsArgumentType(functionName, i)) continue;
        var type = this.getType(args[i]);

        if (!type) {
          throw this.astErrorOutput("Unable to infer argument ".concat(i), args[i]);
        }

        this.assignArgumentType(functionName, i, type);
      }
    }
  }, {
    key: "isAstMathVariable",
    value: function isAstMathVariable(ast) {
      var mathProperties = ['E', 'PI', 'SQRT2', 'SQRT1_2', 'LN2', 'LN10', 'LOG2E', 'LOG10E'];
      return ast.type === 'MemberExpression' && ast.object && ast.object.type === 'Identifier' && ast.object.name === 'Math' && ast.property && ast.property.type === 'Identifier' && mathProperties.indexOf(ast.property.name) > -1;
    }
  }, {
    key: "isAstMathFunction",
    value: function isAstMathFunction(ast) {
      var mathFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'log2', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sqrt', 'tan'];
      return ast.type === 'CallExpression' && ast.callee && ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.object.type === 'Identifier' && ast.callee.object.name === 'Math' && ast.callee.property && ast.callee.property.type === 'Identifier' && mathFunctions.indexOf(ast.callee.property.name) > -1;
    }
  }, {
    key: "isAstVariable",
    value: function isAstVariable(ast) {
      return ast.type === 'Identifier' || ast.type === 'MemberExpression';
    }
  }, {
    key: "isSafe",
    value: function isSafe(ast) {
      return this.isSafeDependencies(this.getDependencies(ast));
    }
  }, {
    key: "isSafeDependencies",
    value: function isSafeDependencies(dependencies) {
      return dependencies && dependencies.every ? dependencies.every(function (dependency) {
        return dependency.isSafe;
      }) : true;
    }
    /**
     *
     * @param ast
     * @param dependencies
     * @param isNotSafe
     * @return {Array}
     */

  }, {
    key: "getDependencies",
    value: function getDependencies(ast, dependencies, isNotSafe) {
      if (!dependencies) {
        dependencies = [];
      }

      if (!ast) return null;

      if (Array.isArray(ast)) {
        for (var i = 0; i < ast.length; i++) {
          this.getDependencies(ast[i], dependencies, isNotSafe);
        }

        return dependencies;
      }

      switch (ast.type) {
        case 'AssignmentExpression':
          this.getDependencies(ast.left, dependencies, isNotSafe);
          this.getDependencies(ast.right, dependencies, isNotSafe);
          return dependencies;

        case 'Literal':
          dependencies.push({
            origin: 'literal',
            value: ast.value,
            isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
          });
          break;

        case 'VariableDeclarator':
          return this.getDependencies(ast.init, dependencies, isNotSafe);

        case 'Identifier':
          var declaration = this.getDeclaration(ast);

          if (declaration) {
            dependencies.push({
              name: ast.name,
              origin: 'declaration',
              isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies)
            });
          } else if (this.argumentNames.indexOf(ast.name) > -1) {
            dependencies.push({
              name: ast.name,
              origin: 'argument',
              isSafe: false
            });
          } else if (this.strictTypingChecking) {
            throw new Error("Cannot find identifier origin \"".concat(ast.name, "\""));
          }

          break;

        case 'FunctionDeclaration':
          return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);

        case 'ReturnStatement':
          return this.getDependencies(ast.argument, dependencies);

        case 'BinaryExpression':
          isNotSafe = ast.operator === '/' || ast.operator === '*';
          this.getDependencies(ast.left, dependencies, isNotSafe);
          this.getDependencies(ast.right, dependencies, isNotSafe);
          return dependencies;

        case 'UnaryExpression':
        case 'UpdateExpression':
          return this.getDependencies(ast.argument, dependencies, isNotSafe);

        case 'VariableDeclaration':
          return this.getDependencies(ast.declarations, dependencies, isNotSafe);

        case 'ArrayExpression':
          dependencies.push({
            origin: 'declaration',
            isSafe: true
          });
          return dependencies;

        case 'CallExpression':
          dependencies.push({
            origin: 'function',
            isSafe: true
          });
          return dependencies;

        case 'MemberExpression':
          var details = this.getMemberExpressionDetails(ast);

          switch (details.signature) {
            case 'value[]':
              this.getDependencies(ast.object, dependencies, isNotSafe);
              break;

            case 'value[][]':
              this.getDependencies(ast.object.object, dependencies, isNotSafe);
              break;

            case 'value[][][]':
              this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
              break;

            case 'this.output.value':
              if (this.dynamicOutput) {
                dependencies.push({
                  name: details.name,
                  origin: 'output',
                  isSafe: false
                });
              }

              break;
          }

          if (details) {
            if (details.property) {
              this.getDependencies(details.property, dependencies, isNotSafe);
            }

            if (details.xProperty) {
              this.getDependencies(details.xProperty, dependencies, isNotSafe);
            }

            if (details.yProperty) {
              this.getDependencies(details.yProperty, dependencies, isNotSafe);
            }

            if (details.zProperty) {
              this.getDependencies(details.zProperty, dependencies, isNotSafe);
            }

            return dependencies;
          }

        default:
          throw this.astErrorOutput("Unhandled type ".concat(ast.type, " in getDependencies"), ast);
      }

      return dependencies;
    }
  }, {
    key: "getVariableSignature",
    value: function getVariableSignature(ast) {
      if (!this.isAstVariable(ast)) {
        throw new Error("ast of type \"".concat(ast.type, "\" is not a variable signature"));
      }

      if (ast.type === 'Identifier') {
        return 'value';
      }

      var signature = [];

      while (true) {
        if (!ast) break;

        if (ast.computed) {
          signature.push('[]');
        } else if (ast.type === 'ThisExpression') {
          signature.unshift('this');
        } else if (ast.property && ast.property.name) {
          if (ast.property.name === 'x' || ast.property.name === 'y' || ast.property.name === 'z') {
            signature.unshift('.value');
          } else if (ast.property.name === 'constants' || ast.property.name === 'thread' || ast.property.name === 'output') {
            signature.unshift('.' + ast.property.name);
          } else {
            signature.unshift('.value');
          }
        } else if (ast.name) {
          signature.unshift('value');
        } else if (ast.callee && ast.callee.name) {
          signature.unshift('fn()');
        } else if (ast.elements) {
          signature.unshift('[]');
        } else {
          signature.unshift('unknown');
        }

        ast = ast.object;
      }

      var signatureString = signature.join('');
      var allowedExpressions = ['value', 'value[]', 'value[][]', 'value[][][]', 'value[][][][]', 'value.value', 'value.thread.value', 'this.thread.value', 'this.output.value', 'this.constants.value', 'this.constants.value[]', 'this.constants.value[][]', 'this.constants.value[][][]', 'this.constants.value[][][][]', 'fn()[]', 'fn()[][]', 'fn()[][][]', '[][]'];

      if (allowedExpressions.indexOf(signatureString) > -1) {
        return signatureString;
      }

      return null;
    }
  }, {
    key: "build",
    value: function build() {
      return this.toString().length > 0;
    }
    /**
     * @desc Parses the abstract syntax tree for generically to its respective function
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed string array
     */

  }, {
    key: "astGeneric",
    value: function astGeneric(ast, retArr) {
      if (ast === null) {
        throw this.astErrorOutput('NULL ast', ast);
      } else {
        if (Array.isArray(ast)) {
          for (var i = 0; i < ast.length; i++) {
            this.astGeneric(ast[i], retArr);
          }

          return retArr;
        }

        switch (ast.type) {
          case 'FunctionDeclaration':
            return this.astFunctionDeclaration(ast, retArr);

          case 'FunctionExpression':
            return this.astFunctionExpression(ast, retArr);

          case 'ReturnStatement':
            return this.astReturnStatement(ast, retArr);

          case 'Literal':
            return this.astLiteral(ast, retArr);

          case 'BinaryExpression':
            return this.astBinaryExpression(ast, retArr);

          case 'Identifier':
            return this.astIdentifierExpression(ast, retArr);

          case 'AssignmentExpression':
            return this.astAssignmentExpression(ast, retArr);

          case 'ExpressionStatement':
            return this.astExpressionStatement(ast, retArr);

          case 'EmptyStatement':
            return this.astEmptyStatement(ast, retArr);

          case 'BlockStatement':
            return this.astBlockStatement(ast, retArr);

          case 'IfStatement':
            return this.astIfStatement(ast, retArr);

          case 'SwitchStatement':
            return this.astSwitchStatement(ast, retArr);

          case 'BreakStatement':
            return this.astBreakStatement(ast, retArr);

          case 'ContinueStatement':
            return this.astContinueStatement(ast, retArr);

          case 'ForStatement':
            return this.astForStatement(ast, retArr);

          case 'WhileStatement':
            return this.astWhileStatement(ast, retArr);

          case 'DoWhileStatement':
            return this.astDoWhileStatement(ast, retArr);

          case 'VariableDeclaration':
            return this.astVariableDeclaration(ast, retArr);

          case 'VariableDeclarator':
            return this.astVariableDeclarator(ast, retArr);

          case 'ThisExpression':
            return this.astThisExpression(ast, retArr);

          case 'SequenceExpression':
            return this.astSequenceExpression(ast, retArr);

          case 'UnaryExpression':
            return this.astUnaryExpression(ast, retArr);

          case 'UpdateExpression':
            return this.astUpdateExpression(ast, retArr);

          case 'LogicalExpression':
            return this.astLogicalExpression(ast, retArr);

          case 'MemberExpression':
            return this.astMemberExpression(ast, retArr);

          case 'CallExpression':
            return this.astCallExpression(ast, retArr);

          case 'ArrayExpression':
            return this.astArrayExpression(ast, retArr);

          case 'DebuggerStatement':
            return this.astDebuggerStatement(ast, retArr);

          case 'ConditionalExpression':
            return this.astConditionalExpression(ast, retArr);
        }

        throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
      }
    }
    /**
     * @desc To throw the AST error, with its location.
     * @param {string} error - the error message output
     * @param {Object} ast - the AST object where the error is
     */

  }, {
    key: "astErrorOutput",
    value: function astErrorOutput(error, ast) {
      if (typeof this.source !== 'string') {
        return new Error(error);
      }

      var debugString = utils.getAstString(this.source, ast);
      var leadingSource = this.source.substr(ast.start);
      var splitLines = leadingSource.split(/\n/);
      var lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
      return new Error("".concat(error, " on line ").concat(splitLines.length, ", position ").concat(lineBefore.length, ":\n ").concat(debugString));
    }
  }, {
    key: "astDebuggerStatement",
    value: function astDebuggerStatement(arrNode, retArr) {
      return retArr;
    }
  }, {
    key: "astConditionalExpression",
    value: function astConditionalExpression(ast, retArr) {
      if (ast.type !== 'ConditionalExpression') {
        throw this.astErrorOutput('Not a conditional expression', ast);
      }

      retArr.push('(');
      this.astGeneric(ast.test, retArr);
      retArr.push('?');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(':');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(')');
      return retArr;
    }
    /**
     * @abstract
     * @param {Object} ast
     * @param {String[]} retArr
     * @returns {String[]}
     */

  }, {
    key: "astFunction",
    value: function astFunction(ast, retArr) {
      throw new Error("\"astFunction\" not defined on ".concat(this.constructor.name));
    }
    /**
     * @desc Parses the abstract syntax tree for to its *named function declaration*
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astFunctionDeclaration",
    value: function astFunctionDeclaration(ast, retArr) {
      if (this.isChildFunction(ast)) {
        return retArr;
      }

      return this.astFunction(ast, retArr);
    }
  }, {
    key: "astFunctionExpression",
    value: function astFunctionExpression(ast, retArr) {
      if (this.isChildFunction(ast)) {
        return retArr;
      }

      return this.astFunction(ast, retArr);
    }
  }, {
    key: "isChildFunction",
    value: function isChildFunction(ast) {
      for (var i = 0; i < this.functions.length; i++) {
        if (this.functions[i] === ast) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "astReturnStatement",
    value: function astReturnStatement(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astLiteral",
    value: function astLiteral(ast, retArr) {
      this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Number';
      return retArr;
    }
  }, {
    key: "astBinaryExpression",
    value: function astBinaryExpression(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astIdentifierExpression",
    value: function astIdentifierExpression(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astAssignmentExpression",
    value: function astAssignmentExpression(ast, retArr) {
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *generic expression* statement
     * @param {Object} esNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astExpressionStatement",
    value: function astExpressionStatement(esNode, retArr) {
      this.astGeneric(esNode.expression, retArr);
      retArr.push(';');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for an *Empty* Statement
     * @param {Object} eNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astEmptyStatement",
    value: function astEmptyStatement(eNode, retArr) {
      return retArr;
    }
  }, {
    key: "astBlockStatement",
    value: function astBlockStatement(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astIfStatement",
    value: function astIfStatement(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astSwitchStatement",
    value: function astSwitchStatement(ast, retArr) {
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Break* Statement
     * @param {Object} brNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astBreakStatement",
    value: function astBreakStatement(brNode, retArr) {
      retArr.push('break;');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Continue* Statement
     * @param {Object} crNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astContinueStatement",
    value: function astContinueStatement(crNode, retArr) {
      retArr.push('continue;\n');
      return retArr;
    }
  }, {
    key: "astForStatement",
    value: function astForStatement(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astWhileStatement",
    value: function astWhileStatement(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astDoWhileStatement",
    value: function astDoWhileStatement(ast, retArr) {
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Variable Declaration*
     * @param {Object} varDecNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astVariableDeclaration",
    value: function astVariableDeclaration(varDecNode, retArr) {
      var declarations = varDecNode.declarations;

      if (!declarations || !declarations[0] || !declarations[0].init) {
        throw this.astErrorOutput('Unexpected expression', varDecNode);
      }

      var result = [];
      var firstDeclaration = declarations[0];
      var init = firstDeclaration.init;
      var type = this.isState('in-for-loop-init') ? 'Integer' : this.getType(init);

      if (type === 'LiteralInteger') {
        // We had the choice to go either float or int, choosing float
        type = 'Number';
      }

      var markupType = typeMap[type];

      if (!markupType) {
        throw this.astErrorOutput("Markup type ".concat(markupType, " not handled"), varDecNode);
      }

      var dependencies = this.getDependencies(firstDeclaration.init);
      throw new Error('remove me');
      this.declarations[firstDeclaration.id.name] = Object.freeze({
        type: type,
        dependencies: dependencies,
        isSafe: dependencies.every(function (dependency) {
          return dependency.isSafe;
        })
      });
      var initResult = ["".concat(type, " user_").concat(firstDeclaration.id.name, "=")];
      this.astGeneric(init, initResult);
      result.push(initResult.join('')); // first declaration is done, now any added ones setup

      for (var i = 1; i < declarations.length; i++) {
        var declaration = declarations[i];
        dependencies = this.getDependencies(declaration);
        throw new Error('Remove me');
        this.declarations[declaration.id.name] = Object.freeze({
          type: type,
          dependencies: dependencies,
          isSafe: false
        });
        this.astGeneric(declaration, result);
      }

      retArr.push(retArr, result.join(','));
      retArr.push(';');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Variable Declarator*
     * @param {Object} iVarDecNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astVariableDeclarator",
    value: function astVariableDeclarator(iVarDecNode, retArr) {
      this.astGeneric(iVarDecNode.id, retArr);

      if (iVarDecNode.init !== null) {
        retArr.push('=');
        this.astGeneric(iVarDecNode.init, retArr);
      }

      return retArr;
    }
  }, {
    key: "astThisExpression",
    value: function astThisExpression(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astSequenceExpression",
    value: function astSequenceExpression(sNode, retArr) {
      for (var i = 0; i < sNode.expressions.length; i++) {
        if (i > 0) {
          retArr.push(',');
        }

        this.astGeneric(sNode.expressions, retArr);
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Unary* Expression
     * @param {Object} uNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astUnaryExpression",
    value: function astUnaryExpression(uNode, retArr) {
      var unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);

      if (unaryResult) {
        return retArr;
      }

      if (uNode.prefix) {
        retArr.push(uNode.operator);
        this.astGeneric(uNode.argument, retArr);
      } else {
        this.astGeneric(uNode.argument, retArr);
        retArr.push(uNode.operator);
      }

      return retArr;
    }
  }, {
    key: "checkAndUpconvertBitwiseUnary",
    value: function checkAndUpconvertBitwiseUnary(uNode, retArr) {}
    /**
     * @desc Parses the abstract syntax tree for *Update* Expression
     * @param {Object} uNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astUpdateExpression",
    value: function astUpdateExpression(uNode, retArr) {
      if (uNode.prefix) {
        retArr.push(uNode.operator);
        this.astGeneric(uNode.argument, retArr);
      } else {
        this.astGeneric(uNode.argument, retArr);
        retArr.push(uNode.operator);
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Logical* Expression
     * @param {Object} logNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astLogicalExpression",
    value: function astLogicalExpression(logNode, retArr) {
      retArr.push('(');
      this.astGeneric(logNode.left, retArr);
      retArr.push(logNode.operator);
      this.astGeneric(logNode.right, retArr);
      retArr.push(')');
      return retArr;
    }
  }, {
    key: "astMemberExpression",
    value: function astMemberExpression(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astCallExpression",
    value: function astCallExpression(ast, retArr) {
      return retArr;
    }
  }, {
    key: "astArrayExpression",
    value: function astArrayExpression(ast, retArr) {
      return retArr;
    }
    /**
     *
     * @param ast
     * @return {IFunctionNodeMemberExpressionDetails}
     */

  }, {
    key: "getMemberExpressionDetails",
    value: function getMemberExpressionDetails(ast) {
      if (ast.type !== 'MemberExpression') {
        throw this.astErrorOutput("Expression ".concat(ast.type, " not a MemberExpression"), ast);
      }

      var name = null;
      var type = null;
      var variableSignature = this.getVariableSignature(ast);

      switch (variableSignature) {
        case 'value':
          return null;

        case 'value.thread.value':
        case 'this.thread.value':
        case 'this.output.value':
          return {
            signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
          };

        case 'value[]':
          if (typeof ast.object.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.object.name;
          return {
            name: name,
            origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
          };

        case 'value[][]':
          if (typeof ast.object.object.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.object.object.name;
          return {
            name: name,
            origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property
          };

        case 'value[][][]':
          if (typeof ast.object.object.object.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.object.object.object.name;
          return {
            name: name,
            origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property
          };

        case 'value[][][][]':
          if (typeof ast.object.object.object.object.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.object.object.object.object.name;
          return {
            name: name,
            origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property
          };

        case 'value.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          if (this.isAstMathVariable(ast)) {
            name = ast.property.name;
            return {
              name: name,
              origin: 'Math',
              type: 'Number',
              signature: variableSignature
            };
          }

          switch (ast.property.name) {
            case 'r':
            case 'g':
            case 'b':
            case 'a':
              name = ast.object.name;
              return {
                name: name,
                property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
              };

            default:
              throw this.astErrorOutput('Unexpected expression', ast);
          }

        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.property.name;
          type = this.getConstantType(name);

          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }

          return {
            name: name,
            type: type,
            origin: 'constants',
            signature: variableSignature
          };

        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          name = ast.object.property.name;
          type = this.getConstantType(name);

          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }

          return {
            name: name,
            type: type,
            origin: 'constants',
            signature: variableSignature,
            xProperty: ast.property
          };

        case 'this.constants.value[][]':
          {
            if (typeof ast.object.object.property.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }

            name = ast.object.object.property.name;
            type = this.getConstantType(name);

            if (!type) {
              throw this.astErrorOutput('Constant has no type', ast);
            }

            return {
              name: name,
              type: type,
              origin: 'constants',
              signature: variableSignature,
              yProperty: ast.object.property,
              xProperty: ast.property
            };
          }

        case 'this.constants.value[][][]':
          {
            if (typeof ast.object.object.object.property.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }

            name = ast.object.object.object.property.name;
            type = this.getConstantType(name);

            if (!type) {
              throw this.astErrorOutput('Constant has no type', ast);
            }

            return {
              name: name,
              type: type,
              origin: 'constants',
              signature: variableSignature,
              zProperty: ast.object.object.property,
              yProperty: ast.object.property,
              xProperty: ast.property
            };
          }

        case 'fn()[]':
        case '[][]':
          return {
            signature: variableSignature,
            property: ast.property
          };

        default:
          throw this.astErrorOutput('Unexpected expression', ast);
      }
    }
  }, {
    key: "findIdentifierOrigin",
    value: function findIdentifierOrigin(astToFind) {
      var stack = [this.ast];

      while (stack.length > 0) {
        var atNode = stack[0];

        if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
          return atNode;
        }

        stack.shift();

        if (atNode.argument) {
          stack.push(atNode.argument);
        } else if (atNode.body) {
          stack.push(atNode.body);
        } else if (atNode.declarations) {
          stack.push(atNode.declarations);
        } else if (Array.isArray(atNode)) {
          for (var i = 0; i < atNode.length; i++) {
            stack.push(atNode[i]);
          }
        }
      }

      return null;
    }
  }, {
    key: "findLastReturn",
    value: function findLastReturn(ast) {
      var stack = [ast || this.ast];

      while (stack.length > 0) {
        var atNode = stack.pop();

        if (atNode.type === 'ReturnStatement') {
          return atNode;
        }

        if (atNode.type === 'FunctionDeclaration') {
          continue;
        }

        if (atNode.argument) {
          stack.push(atNode.argument);
        } else if (atNode.body) {
          stack.push(atNode.body);
        } else if (atNode.declarations) {
          stack.push(atNode.declarations);
        } else if (Array.isArray(atNode)) {
          for (var i = 0; i < atNode.length; i++) {
            stack.push(atNode[i]);
          }
        } else if (atNode.consequent) {
          stack.push(atNode.consequent);
        } else if (atNode.cases) {
          stack.push(atNode.cases);
        }
      }

      return null;
    }
  }, {
    key: "getInternalVariableName",
    value: function getInternalVariableName(name) {
      if (!this._internalVariableNames.hasOwnProperty(name)) {
        this._internalVariableNames[name] = 0;
      }

      this._internalVariableNames[name]++;

      if (this._internalVariableNames[name] === 1) {
        return name;
      }

      return name + this._internalVariableNames[name];
    }
  }, {
    key: "varWarn",
    value: function varWarn() {
      console.warn('var declarations are deprecated, weird things happen when falling back to CPU because var scope differs in javascript than in most languages.  Use const or let');
    }
  }, {
    key: "state",
    get: function get() {
      return this.states[this.states.length - 1];
    }
  }]);

  return FunctionNode;
}();

var typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLImage': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)'
};
module.exports = {
  FunctionNode: FunctionNode
};
},{"acorn":"Wqy/","../utils":"9h1E","./function-tracer":"mAsJ"}],"JBVu":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../function-node'),
    FunctionNode = _require.FunctionNode;
/**
 * @desc [INTERNAL] Represents a single function, inside JS
 *
 * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
 */


var CPUFunctionNode =
/*#__PURE__*/
function (_FunctionNode) {
  _inherits(CPUFunctionNode, _FunctionNode);

  function CPUFunctionNode() {
    _classCallCheck(this, CPUFunctionNode);

    return _possibleConstructorReturn(this, _getPrototypeOf(CPUFunctionNode).apply(this, arguments));
  }

  _createClass(CPUFunctionNode, [{
    key: "astFunction",

    /**
     * @desc Parses the abstract syntax tree for to its *named function*
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */
    value: function astFunction(ast, retArr) {
      // Setup function return type and name
      if (!this.isRootKernel) {
        retArr.push('function');
        retArr.push(' ');
        retArr.push(this.name);
        retArr.push('('); // Arguments handling

        for (var i = 0; i < this.argumentNames.length; ++i) {
          var argumentName = this.argumentNames[i];

          if (i > 0) {
            retArr.push(', ');
          }

          retArr.push('user_');
          retArr.push(argumentName);
        } // Function opening


        retArr.push(') {\n');
      } // Body statement iteration


      for (var _i = 0; _i < ast.body.body.length; ++_i) {
        this.astGeneric(ast.body.body[_i], retArr);
        retArr.push('\n');
      }

      if (!this.isRootKernel) {
        // Function closing
        retArr.push('}\n');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for to *return* statement
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astReturnStatement",
    value: function astReturnStatement(ast, retArr) {
      var type = this.returnType || this.getType(ast.argument);

      if (!this.returnType) {
        this.returnType = type;
      }

      if (this.isRootKernel) {
        retArr.push(this.leadingReturnStatement);
        this.astGeneric(ast.argument, retArr);
        retArr.push(';\n');
        retArr.push(this.followingReturnStatement);
        retArr.push('continue;\n');
      } else if (this.isSubKernel) {
        retArr.push("subKernelResult_".concat(this.name, " = "));
        this.astGeneric(ast.argument, retArr);
        retArr.push(';');
        retArr.push("return subKernelResult_".concat(this.name, ";"));
      } else {
        retArr.push('return ');
        this.astGeneric(ast.argument, retArr);
        retArr.push(';');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *literal value*
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astLiteral",
    value: function astLiteral(ast, retArr) {
      // Reject non numeric literals
      if (isNaN(ast.value)) {
        throw this.astErrorOutput('Non-numeric literal not supported : ' + ast.value, ast);
      }

      retArr.push(ast.value);
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *binary* expression
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astBinaryExpression",
    value: function astBinaryExpression(ast, retArr) {
      retArr.push('(');
      this.astGeneric(ast.left, retArr);
      retArr.push(ast.operator);
      this.astGeneric(ast.right, retArr);
      retArr.push(')');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *identifier* expression
     * @param {Object} idtNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astIdentifierExpression",
    value: function astIdentifierExpression(idtNode, retArr) {
      if (idtNode.type !== 'Identifier') {
        throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
      }

      switch (idtNode.name) {
        case 'Infinity':
          retArr.push('Infinity');
          break;

        default:
          if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
            retArr.push('constants_' + idtNode.name);
          } else {
            var name = this.getKernelArgumentName(idtNode.name);

            if (name) {
              retArr.push('user_' + name);
            } else {
              retArr.push('user_' + idtNode.name);
            }
          }

      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *for-loop* expression
     * @param {Object} forNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed webgl string
     */

  }, {
    key: "astForStatement",
    value: function astForStatement(forNode, retArr) {
      if (forNode.type !== 'ForStatement') {
        throw this.astErrorOutput('Invalid for statement', forNode);
      }

      var initArr = [];
      var testArr = [];
      var updateArr = [];
      var bodyArr = [];
      var isSafe = null;

      if (forNode.init) {
        this.pushState('in-for-loop-init');
        this.astGeneric(forNode.init, initArr);

        for (var i = 0; i < initArr.length; i++) {
          if (initArr[i].includes && initArr[i].includes(',')) {
            isSafe = false;
          }
        }

        this.popState('in-for-loop-init');
      } else {
        isSafe = false;
      }

      if (forNode.test) {
        this.astGeneric(forNode.test, testArr);
      } else {
        isSafe = false;
      }

      if (forNode.update) {
        this.astGeneric(forNode.update, updateArr);
      } else {
        isSafe = false;
      }

      if (forNode.body) {
        this.pushState('loop-body');
        this.astGeneric(forNode.body, bodyArr);
        this.popState('loop-body');
      } // have all parts, now make them safe


      if (isSafe === null) {
        isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
      }

      if (isSafe) {
        retArr.push("for (".concat(initArr.join(''), ";").concat(testArr.join(''), ";").concat(updateArr.join(''), "){\n"));
        retArr.push(bodyArr.join(''));
        retArr.push('}\n');
      } else {
        var iVariableName = this.getInternalVariableName('safeI');

        if (initArr.length > 0) {
          retArr.push(initArr.join(''), ';\n');
        }

        retArr.push("for (let ".concat(iVariableName, "=0;").concat(iVariableName, "<LOOP_MAX;").concat(iVariableName, "++){\n"));

        if (testArr.length > 0) {
          retArr.push("if (!".concat(testArr.join(''), ") break;\n"));
        }

        retArr.push(bodyArr.join(''));
        retArr.push("\n".concat(updateArr.join(''), ";"));
        retArr.push('}\n');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *while* loop
     * @param {Object} whileNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed javascript string
     */

  }, {
    key: "astWhileStatement",
    value: function astWhileStatement(whileNode, retArr) {
      if (whileNode.type !== 'WhileStatement') {
        throw this.astErrorOutput('Invalid while statement', whileNode);
      }

      retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
      retArr.push('if (');
      this.astGeneric(whileNode.test, retArr);
      retArr.push(') {\n');
      this.astGeneric(whileNode.body, retArr);
      retArr.push('} else {\n');
      retArr.push('break;\n');
      retArr.push('}\n');
      retArr.push('}\n');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *do while* loop
     * @param {Object} doWhileNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed webgl string
     */

  }, {
    key: "astDoWhileStatement",
    value: function astDoWhileStatement(doWhileNode, retArr) {
      if (doWhileNode.type !== 'DoWhileStatement') {
        throw this.astErrorOutput('Invalid while statement', doWhileNode);
      }

      retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
      this.astGeneric(doWhileNode.body, retArr);
      retArr.push('if (!');
      this.astGeneric(doWhileNode.test, retArr);
      retArr.push(') {\n');
      retArr.push('break;\n');
      retArr.push('}\n');
      retArr.push('}\n');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Assignment* Expression
     * @param {Object} assNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astAssignmentExpression",
    value: function astAssignmentExpression(assNode, retArr) {
      var declaration = this.getDeclaration(assNode.left);

      if (declaration && !declaration.assignable) {
        throw new this.astErrorOutput("Variable ".concat(assNode.left.name, " is not assignable here"), assNode);
      }

      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      this.astGeneric(assNode.right, retArr);
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Block* statement
     * @param {Object} bNode - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astBlockStatement",
    value: function astBlockStatement(bNode, retArr) {
      if (this.isState('loop-body')) {
        this.pushState('block-body'); // this prevents recursive removal of braces

        for (var i = 0; i < bNode.body.length; i++) {
          this.astGeneric(bNode.body[i], retArr);
        }

        this.popState('block-body');
      } else {
        retArr.push('{\n');

        for (var _i2 = 0; _i2 < bNode.body.length; _i2++) {
          this.astGeneric(bNode.body[_i2], retArr);
        }

        retArr.push('}\n');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Variable Declaration*
     * @param {Object} varDecNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astVariableDeclaration",
    value: function astVariableDeclaration(varDecNode, retArr) {
      if (varDecNode.kind === 'var') {
        this.varWarn();
      }

      retArr.push("".concat(varDecNode.kind, " "));
      var declarations = varDecNode.declarations;

      for (var i = 0; i < declarations.length; i++) {
        if (i > 0) {
          retArr.push(',');
        }

        this.astGeneric(declarations[i], retArr);
      }

      if (!this.isState('in-for-loop-init')) {
        retArr.push(';');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *If* Statement
     * @param {Object} ifNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astIfStatement",
    value: function astIfStatement(ifNode, retArr) {
      retArr.push('if (');
      this.astGeneric(ifNode.test, retArr);
      retArr.push(')');

      if (ifNode.consequent.type === 'BlockStatement') {
        this.astGeneric(ifNode.consequent, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.consequent, retArr);
        retArr.push('\n}\n');
      }

      if (ifNode.alternate) {
        retArr.push('else ');

        if (ifNode.alternate.type === 'BlockStatement') {
          this.astGeneric(ifNode.alternate, retArr);
        } else {
          retArr.push(' {\n');
          this.astGeneric(ifNode.alternate, retArr);
          retArr.push('\n}\n');
        }
      }

      return retArr;
    }
  }, {
    key: "astSwitchStatement",
    value: function astSwitchStatement(ast, retArr) {
      var discriminant = ast.discriminant,
          cases = ast.cases;
      retArr.push('switch (');
      this.astGeneric(discriminant, retArr);
      retArr.push(') {\n');

      for (var i = 0; i < cases.length; i++) {
        if (cases[i].test === null) {
          retArr.push('default:\n');
          this.astGeneric(cases[i].consequent, retArr);

          if (cases[i].consequent && cases[i].consequent.length > 0) {
            retArr.push('break;\n');
          }

          continue;
        }

        retArr.push('case ');
        this.astGeneric(cases[i].test, retArr);
        retArr.push(':\n');

        if (cases[i].consequent && cases[i].consequent.length > 0) {
          this.astGeneric(cases[i].consequent, retArr);
          retArr.push('break;\n');
        }
      }

      retArr.push('\n}');
    }
    /**
     * @desc Parses the abstract syntax tree for *This* expression
     * @param {Object} tNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astThisExpression",
    value: function astThisExpression(tNode, retArr) {
      retArr.push('_this');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Member* Expression
     * @param {Object} mNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astMemberExpression",
    value: function astMemberExpression(mNode, retArr) {
      var _this$getMemberExpres = this.getMemberExpressionDetails(mNode),
          signature = _this$getMemberExpres.signature,
          type = _this$getMemberExpres.type,
          property = _this$getMemberExpres.property,
          xProperty = _this$getMemberExpres.xProperty,
          yProperty = _this$getMemberExpres.yProperty,
          zProperty = _this$getMemberExpres.zProperty,
          name = _this$getMemberExpres.name,
          origin = _this$getMemberExpres.origin;

      switch (signature) {
        case 'this.thread.value':
          retArr.push("_this.thread.".concat(name));
          return retArr;

        case 'this.output.value':
          switch (name) {
            case 'x':
              retArr.push('outputX');
              break;

            case 'y':
              retArr.push('outputY');
              break;

            case 'z':
              retArr.push('outputZ');
              break;

            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }

          return retArr;

        case 'value':
          throw this.astErrorOutput('Unexpected expression', mNode);

        case 'value[]':
        case 'value[][]':
        case 'value[][][]':
        case 'value.value':
          if (origin === 'Math') {
            retArr.push(Math[name]);
            return retArr;
          }

          switch (property) {
            case 'r':
              retArr.push("user_".concat(name, "[0]"));
              return retArr;

            case 'g':
              retArr.push("user_".concat(name, "[1]"));
              return retArr;

            case 'b':
              retArr.push("user_".concat(name, "[2]"));
              return retArr;

            case 'a':
              retArr.push("user_".concat(name, "[3]"));
              return retArr;
          }

          break;

        case 'this.constants.value':
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
          break;

        case 'fn()[]':
          this.astGeneric(mNode.object, retArr);
          retArr.push('[');
          this.astGeneric(mNode.property, retArr);
          retArr.push(']');
          return retArr;

        default:
          throw this.astErrorOutput('Unexpected expression', mNode);
      }

      if (!mNode.computed) {
        // handle simple types
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'Boolean':
            retArr.push("".concat(origin, "_").concat(name));
            return retArr;
        }
      } // handle more complex types
      // argument may have come from a parent


      var synonymName = this.getKernelArgumentName(name);
      var markupName = "".concat(origin, "_").concat(synonymName || name);

      switch (type) {
        case 'Array(2)':
        case 'Array(3)':
        case 'Array(4)':
        case 'HTMLImageArray':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'HTMLImage':
        default:
          var size;
          var isInput;

          if (origin === 'constants') {
            var constant = this.constants[name];
            isInput = this.constantTypes[name] === 'Input';
            size = isInput ? constant.size : null;
          } else {
            isInput = this.isInput(synonymName || name);
            size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
          }

          retArr.push("".concat(markupName));

          if (zProperty && yProperty) {
            if (isInput) {
              retArr.push('[(');
              this.astGeneric(zProperty, retArr);
              retArr.push("*".concat(size[1] * size[0], ")+("));
              this.astGeneric(yProperty, retArr);
              retArr.push("*".concat(size[0], ")+"));
              this.astGeneric(xProperty, retArr);
              retArr.push(']');
            } else {
              retArr.push('[');
              this.astGeneric(zProperty, retArr);
              retArr.push(']');
              retArr.push('[');
              this.astGeneric(yProperty, retArr);
              retArr.push(']');
              retArr.push('[');
              this.astGeneric(xProperty, retArr);
              retArr.push(']');
            }
          } else if (yProperty) {
            if (isInput) {
              retArr.push('[(');
              this.astGeneric(yProperty, retArr);
              retArr.push("*".concat(size[0], ")+"));
              this.astGeneric(xProperty, retArr);
              retArr.push(']');
            } else {
              retArr.push('[');
              this.astGeneric(yProperty, retArr);
              retArr.push(']');
              retArr.push('[');
              this.astGeneric(xProperty, retArr);
              retArr.push(']');
            }
          } else {
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }

      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *call* expression
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns  {Array} the append retArr
     */

  }, {
    key: "astCallExpression",
    value: function astCallExpression(ast, retArr) {
      if (ast.type !== 'CallExpression') {
        // Failure, unknown expression
        throw this.astErrorOutput('Unknown CallExpression', ast);
      } // Get the full function call, unrolled


      var functionName = this.astMemberExpressionUnroll(ast.callee); // Register the function into the called registry

      if (this.calledFunctions.indexOf(functionName) < 0) {
        this.calledFunctions.push(functionName);
      }

      var isMathFunction = this.isAstMathFunction(ast); // track the function was called

      if (this.onFunctionCall) {
        this.onFunctionCall(this.name, functionName, ast.arguments);
      } // Call the function


      retArr.push(functionName); // Open arguments space

      retArr.push('(');
      var targetTypes = this.lookupFunctionArgumentTypes(functionName) || []; // Add the arguments

      for (var i = 0; i < ast.arguments.length; ++i) {
        var argument = ast.arguments[i]; // in order to track return type, even though this is CPU

        var argumentType = this.getType(argument);

        if (!targetTypes[i]) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
        }

        if (i > 0) {
          retArr.push(', ');
        }

        this.astGeneric(argument, retArr);
      } // Close arguments space


      retArr.push(')');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Array* Expression
     * @param {Object} arrNode - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astArrayExpression",
    value: function astArrayExpression(arrNode, retArr) {
      var arrLen = arrNode.elements.length;
      retArr.push('new Float32Array([');

      for (var i = 0; i < arrLen; ++i) {
        if (i > 0) {
          retArr.push(', ');
        }

        var subNode = arrNode.elements[i];
        this.astGeneric(subNode, retArr);
      }

      retArr.push('])');
      return retArr;
    }
  }, {
    key: "astDebuggerStatement",
    value: function astDebuggerStatement(arrNode, retArr) {
      retArr.push('debugger;');
      return retArr;
    }
  }]);

  return CPUFunctionNode;
}(FunctionNode);

module.exports = {
  CPUFunctionNode: CPUFunctionNode
};
},{"../function-node":"oNAw"}],"71XX":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('../../utils'),
    utils = _require.utils;

var _require2 = require('../../input'),
    Input = _require2.Input;

function constantsToString(constants) {
  var results = [];

  for (var p in constants) {
    var constant = constants[p];

    switch (_typeof(constant)) {
      case 'number':
      case 'boolean':
        results.push("".concat(p, ":").concat(constant));
    }
  }

  return "{ ".concat(results.join(), " }");
}

function cpuKernelString(cpuKernel, name) {
  var header = [];
  var thisProperties = [];
  var beforeReturn = [];
  var useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());
  header.push('  const { context, canvas, constants } = settings;', "  const output = new Int32Array(".concat(JSON.stringify(Array.from(cpuKernel.output)), ");"), "  const _constants = ".concat(constantsToString(cpuKernel.constants), ";"));
  thisProperties.push('    constants: _constants,', '    context,', '    output,', '    thread: {x: 0, y: 0, z: 0},');

  if (cpuKernel.graphical) {
    header.push("  const _imageData = context.createImageData(".concat(cpuKernel.output[0], ", ").concat(cpuKernel.output[1], ");"));
    header.push("  const _colorData = new Uint8ClampedArray(".concat(cpuKernel.output[0], " * ").concat(cpuKernel.output[1], " * 4);"));
    var colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: function thisLookup(propertyName) {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';

          case '_imageData':
            return '_imageData';

          case 'output':
            return 'output';

          case 'thread':
            return 'this.thread';
        }

        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: function findDependency(object, name) {
        return null;
      }
    });
    var getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: function thisLookup(propertyName) {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';

          case '_imageData':
            return '_imageData';

          case 'output':
            return 'output';

          case 'thread':
            return 'this.thread';
        }

        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: function findDependency() {
        return null;
      }
    });
    thisProperties.push('    _imageData,', '    _colorData,', "    color: ".concat(colorFn, ","));
    beforeReturn.push("  kernel.getPixels = ".concat(getPixelsFn, ";"));
  }

  var constantTypes = [];
  var constantKeys = Object.keys(cpuKernel.constantTypes);

  for (var i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }

  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    var flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: function findDependency(object, name) {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }

        return null;
      },
      thisLookup: function thisLookup(propertyName) {
        switch (propertyName) {
          case 'canvas':
            return;

          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push("    _imageTo2DArray,");
    thisProperties.push("    _imageTo3DArray,");
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    var flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo2DArray.toString(), {
      findDependency: function findDependency() {
        debugger;
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push("    _imageTo2DArray,");
  }

  return "function(settings) {\n".concat(header.join('\n'), "\n  for (const p in constants) {\n    const constant = constants[p];\n    switch (typeof constant) {\n      case 'number':\n      case 'boolean':\n        continue;\n    }\n    _constants[p] = constant;\n  }\n  const kernel = (function() {\n").concat(cpuKernel._kernelString, "\n  })\n    .apply({ ").concat(thisProperties.join('\n'), " });\n  ").concat(beforeReturn.join('\n'), "\n  return kernel;\n}");
}

module.exports = {
  cpuKernelString: cpuKernelString
};
},{"../../utils":"9h1E","../../input":"ryqg"}],"A4bq":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../kernel'),
    Kernel = _require.Kernel;

var _require2 = require('../function-builder'),
    FunctionBuilder = _require2.FunctionBuilder;

var _require3 = require('./function-node'),
    CPUFunctionNode = _require3.CPUFunctionNode;

var _require4 = require('../../utils'),
    utils = _require4.utils;

var _require5 = require('./kernel-string'),
    cpuKernelString = _require5.cpuKernelString;
/**
 * @desc Kernel Implementation for CPU.
 * <p>Instantiates properties to the CPU Kernel.</p>
 */


var CPUKernel =
/*#__PURE__*/
function (_Kernel) {
  _inherits(CPUKernel, _Kernel);

  _createClass(CPUKernel, null, [{
    key: "getFeatures",
    value: function getFeatures() {
      return this.features;
    }
  }, {
    key: "isContextMatch",
    value: function isContextMatch(context) {
      return false;
    }
    /**
     * @desc The current mode in which gpu.js is executing.
     */

  }, {
    key: "nativeFunctionArguments",
    value: function nativeFunctionArguments() {
      return null;
    }
  }, {
    key: "nativeFunctionReturnType",
    value: function nativeFunctionReturnType() {
      return null;
    }
  }, {
    key: "combineKernels",
    value: function combineKernels(combinedKernel) {
      return combinedKernel;
    }
  }, {
    key: "features",
    get: function get() {
      return Object.freeze({
        kernelMap: true,
        isIntegerDivisionAccurate: true
      });
    }
  }, {
    key: "isSupported",
    get: function get() {
      return true;
    }
  }, {
    key: "mode",
    get: function get() {
      return 'cpu';
    }
  }]);

  function CPUKernel(source, settings) {
    var _this;

    _classCallCheck(this, CPUKernel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CPUKernel).call(this, source, settings));

    _this.mergeSettings(source.settings || settings);

    _this._imageData = null;
    _this._colorData = null;
    _this._kernelString = null;
    _this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    _this.translatedSources = null;
    return _this;
  }

  _createClass(CPUKernel, [{
    key: "initCanvas",
    value: function initCanvas() {
      if (typeof document !== 'undefined') {
        return document.createElement('canvas');
      } else if (typeof OffscreenCanvas !== 'undefined') {
        return new OffscreenCanvas(0, 0);
      }
    }
  }, {
    key: "initContext",
    value: function initContext() {
      if (!this.canvas) return null;
      return this.canvas.getContext('2d');
    }
  }, {
    key: "initPlugins",
    value: function initPlugins(settings) {
      return [];
    }
    /**
     * @desc Validate settings related to CPU Kernel, such as
     * dimensions size, and auto dimension support.
     */

  }, {
    key: "validateSettings",
    value: function validateSettings() {
      if (!this.output || this.output.length === 0) {
        if (arguments.length !== 1) {
          throw 'Auto dimensions only supported for kernels with only one input';
        }

        var argType = utils.getVariableType(arguments[0], this.strictIntegers);

        if (argType === 'Array') {
          this.output = utils.getDimensions(argType);
        } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
          this.output = arguments[0].output;
        } else {
          throw 'Auto dimensions not supported for input type: ' + argType;
        }
      }

      if (this.graphical) {
        if (this.output.length !== 2) {
          throw new Error('Output must have 2 dimensions on graphical mode');
        }
      }

      this.checkOutput();
    }
  }, {
    key: "translateSource",
    value: function translateSource() {
      this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';

      if (this.subKernels) {
        var followingReturnStatement = [];

        for (var i = 0; i < this.subKernels.length; i++) {
          var name = this.subKernels[i].name;
          followingReturnStatement.push(this.output.length > 1 ? "resultX_".concat(name, "[x] = subKernelResult_").concat(name, ";\n") : "result_".concat(name, "[x] = subKernelResult_").concat(name, ";\n"));
        }

        this.followingReturnStatement = followingReturnStatement.join('');
      }

      var functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
      this.translatedSources = functionBuilder.getPrototypes('kernel');

      if (!this.graphical && !this.returnType) {
        this.returnType = functionBuilder.getKernelResultType();
      }
    }
    /**
     * @desc Builds the Kernel, by generating the kernel
     * string using thread dimensions, and arguments
     * supplied to the kernel.
     *
     * <p>If the graphical flag is enabled, canvas is used.</p>
     */

  }, {
    key: "build",
    value: function build() {
      this.setupConstants();
      this.setupArguments(arguments);
      this.validateSettings();
      this.translateSource();

      if (this.graphical) {
        var canvas = this.canvas,
            output = this.output;

        if (!canvas) {
          throw new Error('no canvas available for using graphical output');
        }

        var width = output[0];
        var height = output[1] || 1;
        canvas.width = width;
        canvas.height = height;
        this._imageData = this.context.createImageData(width, height);
        this._colorData = new Uint8ClampedArray(width * height * 4);
      }

      var kernelString = this.getKernelString();
      this.kernelString = kernelString;

      if (this.debug) {
        console.log('Function output:');
        console.log(kernelString);
      }

      try {
        this.run = new Function([], kernelString).bind(this)();
      } catch (e) {
        console.error('An error occurred compiling the javascript: ', e);
      }
    }
  }, {
    key: "color",
    value: function color(r, g, b, a) {
      if (typeof a === 'undefined') {
        a = 1;
      }

      r = Math.floor(r * 255);
      g = Math.floor(g * 255);
      b = Math.floor(b * 255);
      a = Math.floor(a * 255);
      var width = this.output[0];
      var height = this.output[1];
      var x = this.thread.x;
      var y = height - this.thread.y - 1;
      var index = x + y * width;
      this._colorData[index * 4 + 0] = r;
      this._colorData[index * 4 + 1] = g;
      this._colorData[index * 4 + 2] = b;
      this._colorData[index * 4 + 3] = a;
    }
    /**
     * @desc Generates kernel string for this kernel program.
     *
     * <p>If sub-kernels are supplied, they are also factored in.
     * This string can be saved by calling the `toString` method
     * and then can be reused later.</p>
     *
     * @returns {String} result
     *
     */

  }, {
    key: "getKernelString",
    value: function getKernelString() {
      if (this._kernelString !== null) return this._kernelString;
      var kernelThreadString = null;
      var translatedSources = this.translatedSources;

      if (translatedSources.length > 1) {
        translatedSources = translatedSources.filter(function (fn) {
          if (/^function/.test(fn)) return fn;
          kernelThreadString = fn;
          return false;
        });
      } else {
        kernelThreadString = translatedSources.shift();
      }

      var kernelString = this._kernelString = "  const LOOP_MAX = ".concat(this._getLoopMaxString(), "\n  const constants = this.constants;\n  const _this = this;\n  return (").concat(this.argumentNames.map(function (argumentName) {
        return 'user_' + argumentName;
      }).join(', '), ") => {\n    ").concat(this._processConstants(), "\n    ").concat(this._processArguments(), "\n    ").concat(this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString), "\n    ").concat(translatedSources.length > 0 ? translatedSources.join('\n') : '', "\n  };");
      return kernelString;
    }
    /**
     * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
     */

  }, {
    key: "toString",
    value: function toString() {
      return cpuKernelString(this);
    }
    /**
     * @desc Get the maximum loop size String.
     * @returns {String} result
     */

  }, {
    key: "_getLoopMaxString",
    value: function _getLoopMaxString() {
      return this.loopMaxIterations ? " ".concat(parseInt(this.loopMaxIterations), ";") : ' 1000;';
    }
  }, {
    key: "_processConstants",
    value: function _processConstants() {
      if (!this.constants) return '';
      var result = [];

      for (var p in this.constants) {
        var type = this.constantTypes[p];

        switch (type) {
          case 'HTMLImage':
            result.push("    const constants_".concat(p, " = this._imageTo2DArray(this.constants.").concat(p, ");\n"));
            break;

          case 'HTMLImageArray':
            result.push("    const constants_".concat(p, " = this._imageTo3DArray(this.constants.").concat(p, ");\n"));
            break;

          case 'Input':
            result.push("    const constants_".concat(p, " = this.constants.").concat(p, ".value;\n"));
            break;

          default:
            result.push("    const constants_".concat(p, " = this.constants.").concat(p, ";\n"));
        }
      }

      return result.join('');
    }
  }, {
    key: "_processArguments",
    value: function _processArguments() {
      var result = [];

      for (var i = 0; i < this.argumentTypes.length; i++) {
        var variableName = "user_".concat(this.argumentNames[i]);

        switch (this.argumentTypes[i]) {
          case 'HTMLImage':
            result.push("    ".concat(variableName, " = this._imageTo2DArray(").concat(variableName, ");\n"));
            break;

          case 'HTMLImageArray':
            result.push("    ".concat(variableName, " = this._imageTo3DArray(").concat(variableName, ");\n"));
            break;

          case 'Input':
            result.push("    ".concat(variableName, " = ").concat(variableName, ".value;\n"));
            break;

          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'NumberTexture':
          case 'MemoryOptimizedNumberTexture':
            result.push("\n    if (".concat(variableName, ".toArray) {\n      if (!_this.textureCache) {\n        _this.textureCache = [];\n        _this.arrayCache = [];\n      }\n      const textureIndex = _this.textureCache.indexOf(").concat(variableName, ");\n      if (textureIndex !== -1) {\n        ").concat(variableName, " = _this.arrayCache[textureIndex];\n      } else {\n        _this.textureCache.push(").concat(variableName, ");\n        ").concat(variableName, " = ").concat(variableName, ".toArray();\n        _this.arrayCache.push(").concat(variableName, ");\n      }\n    }"));
            break;
        }
      }

      return result.join('');
    }
  }, {
    key: "_imageTo2DArray",
    value: function _imageTo2DArray(image) {
      var canvas = this.canvas;

      if (canvas.width < image.width) {
        canvas.width = image.width;
      }

      if (canvas.height < image.height) {
        canvas.height = image.height;
      }

      var ctx = this.context;
      ctx.drawImage(image, 0, 0, image.width, image.height);
      var pixelsData = ctx.getImageData(0, 0, image.width, image.height).data;
      var imageArray = new Array(image.height);
      var index = 0;

      for (var y = image.height - 1; y >= 0; y--) {
        var row = imageArray[y] = new Array(image.width);

        for (var x = 0; x < image.width; x++) {
          var pixel = new Float32Array(4);
          pixel[0] = pixelsData[index++] / 255; // r

          pixel[1] = pixelsData[index++] / 255; // g

          pixel[2] = pixelsData[index++] / 255; // b

          pixel[3] = pixelsData[index++] / 255; // a

          row[x] = pixel;
        }
      }

      return imageArray;
    }
  }, {
    key: "getPixels",
    value: function getPixels(flip) {
      var _this$output = _slicedToArray(this.output, 2),
          width = _this$output[0],
          height = _this$output[1]; // cpu is not flipped by default


      return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
    }
  }, {
    key: "_imageTo3DArray",
    value: function _imageTo3DArray(images) {
      var imagesArray = new Array(images.length);

      for (var i = 0; i < images.length; i++) {
        imagesArray[i] = this._imageTo2DArray(images[i]);
      }

      return imagesArray;
    }
  }, {
    key: "_resultKernelBody",
    value: function _resultKernelBody(kernelString) {
      switch (this.output.length) {
        case 1:
          return this._resultKernel1DLoop(kernelString) + this._kernelOutput();

        case 2:
          return this._resultKernel2DLoop(kernelString) + this._kernelOutput();

        case 3:
          return this._resultKernel3DLoop(kernelString) + this._kernelOutput();

        default:
          throw new Error('unsupported size kernel');
      }
    }
  }, {
    key: "_graphicalKernelBody",
    value: function _graphicalKernelBody(kernelThreadString) {
      switch (this.output.length) {
        case 2:
          return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();

        default:
          throw new Error('unsupported size kernel');
      }
    }
  }, {
    key: "_graphicalOutput",
    value: function _graphicalOutput() {
      return "\n    this._imageData.data.set(this._colorData);\n    this.context.putImageData(this._imageData, 0, 0);\n    return;";
    }
  }, {
    key: "_getKernelResultTypeConstructorString",
    value: function _getKernelResultTypeConstructorString() {
      switch (this.returnType) {
        case 'LiteralInteger':
        case 'Number':
        case 'Integer':
        case 'Float':
          return 'Float32Array';

        case 'Array(2)':
        case 'Array(3)':
        case 'Array(4)':
          return 'Array';

        default:
          if (this.graphical) {
            return 'Float32Array';
          }

          throw new Error("unhandled returnType ".concat(this.returnType));
      }
    }
  }, {
    key: "_resultKernel1DLoop",
    value: function _resultKernel1DLoop(kernelString) {
      var output = this.output;

      var constructorString = this._getKernelResultTypeConstructorString();

      return "  const outputX = _this.output[0];\n    const result = new ".concat(constructorString, "(outputX);\n    ").concat(this._mapSubKernels(function (subKernel) {
        return "const result_".concat(subKernel.name, " = new ").concat(constructorString, "(outputX);\n");
      }).join('    '), "\n    ").concat(this._mapSubKernels(function (subKernel) {
        return "let subKernelResult_".concat(subKernel.name, ";\n");
      }).join('    '), "\n    for (let x = 0; x < outputX; x++) {\n      this.thread.x = x;\n      this.thread.y = 0;\n      this.thread.z = 0;\n      ").concat(kernelString, "\n    }");
    }
  }, {
    key: "_resultKernel2DLoop",
    value: function _resultKernel2DLoop(kernelString) {
      var output = this.output;

      var constructorString = this._getKernelResultTypeConstructorString();

      return "  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const result = new Array(outputY);\n    ".concat(this._mapSubKernels(function (subKernel) {
        return "const result_".concat(subKernel.name, " = new Array(outputY);\n");
      }).join('    '), "\n    ").concat(this._mapSubKernels(function (subKernel) {
        return "let subKernelResult_".concat(subKernel.name, ";\n");
      }).join('    '), "\n    for (let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      const resultX = result[y] = new ").concat(constructorString, "(outputX);\n      ").concat(this._mapSubKernels(function (subKernel) {
        return "const resultX_".concat(subKernel.name, " = result_").concat(subKernel.name, "[y] = new ").concat(constructorString, "(outputX);\n");
      }).join(''), "\n      for (let x = 0; x < outputX; x++) {\n        this.thread.x = x;\n        ").concat(kernelString, "\n      }\n    }");
    }
  }, {
    key: "_graphicalKernel2DLoop",
    value: function _graphicalKernel2DLoop(kernelString) {
      var output = this.output;

      var constructorString = this._getKernelResultTypeConstructorString();

      return "  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    ".concat(this._mapSubKernels(function (subKernel) {
        return "const result_".concat(subKernel.name, " = new Array(outputY);\n");
      }).join('    '), "\n    ").concat(this._mapSubKernels(function (subKernel) {
        return "let subKernelResult_".concat(subKernel.name, ";\n");
      }).join('    '), "\n    for (let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      ").concat(this._mapSubKernels(function (subKernel) {
        return "const resultX_".concat(subKernel.name, " = result_").concat(subKernel.name, "[y] = new ").concat(constructorString, "(outputX);\n");
      }).join(''), "\n      for (let x = 0; x < outputX; x++) {\n        this.thread.x = x;\n        ").concat(kernelString, "\n      }\n    }");
    }
  }, {
    key: "_resultKernel3DLoop",
    value: function _resultKernel3DLoop(kernelString) {
      var output = this.output;

      var constructorString = this._getKernelResultTypeConstructorString();

      return "  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const outputZ = _this.output[2];\n    const result = new Array(outputZ);\n    ".concat(this._mapSubKernels(function (subKernel) {
        return "const result_".concat(subKernel.name, " = new Array(outputZ);\n");
      }).join('    '), "\n    ").concat(this._mapSubKernels(function (subKernel) {
        return "let subKernelResult_".concat(subKernel.name, ";\n");
      }).join('    '), "\n    for (let z = 0; z < outputZ; z++) {\n      this.thread.z = z;\n      const resultY = result[z] = new Array(outputY);\n      ").concat(this._mapSubKernels(function (subKernel) {
        return "const resultY_".concat(subKernel.name, " = result_").concat(subKernel.name, "[z] = new Array(outputY);\n");
      }).join('      '), "\n      for (let y = 0; y < outputY; y++) {\n        this.thread.y = y;\n        const resultX = resultY[y] = new ").concat(constructorString, "(outputX);\n        ").concat(this._mapSubKernels(function (subKernel) {
        return "const resultX_".concat(subKernel.name, " = resultY_").concat(subKernel.name, "[y] = new ").concat(constructorString, "(outputX);\n");
      }).join('        '), "\n        for (let x = 0; x < outputX; x++) {\n          this.thread.x = x;\n          ").concat(kernelString, "\n        }\n      }\n    }");
    }
  }, {
    key: "_kernelOutput",
    value: function _kernelOutput() {
      if (!this.subKernels) {
        return '\n    return result;';
      }

      return "\n    return {\n      result: result,\n      ".concat(this.subKernels.map(function (subKernel) {
        return "".concat(subKernel.property, ": result_").concat(subKernel.name);
      }).join(',\n      '), "\n    };");
    }
  }, {
    key: "_mapSubKernels",
    value: function _mapSubKernels(fn) {
      return this.subKernels === null ? [''] : this.subKernels.map(fn);
    }
  }, {
    key: "destroy",
    value: function destroy(removeCanvasReference) {
      if (removeCanvasReference) {
        delete this.canvas;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = _get(_getPrototypeOf(CPUKernel.prototype), "toJSON", this).call(this);

      json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
      return json;
    }
  }, {
    key: "setOutput",
    value: function setOutput(output) {
      _get(_getPrototypeOf(CPUKernel.prototype), "setOutput", this).call(this, output);

      var _this$output2 = _slicedToArray(this.output, 2),
          width = _this$output2[0],
          height = _this$output2[1];

      if (this.graphical) {
        this._imageData = this.context.createImageData(width, height);
        this._colorData = new Uint8ClampedArray(width * height * 4);
      }
    }
  }], [{
    key: "destroyContext",
    value: function destroyContext(context) {}
  }]);

  return CPUKernel;
}(Kernel);

module.exports = {
  CPUKernel: CPUKernel
};
},{"../kernel":"JYjN","../function-builder":"HOQD","./function-node":"JBVu","../../utils":"9h1E","./kernel-string":"71XX"}],"dVPj":[function(require,module,exports) {
'use strict';

function createContext(width, height, options) {
  width = width | 0;
  height = height | 0;

  if (!(width > 0 && height > 0)) {
    return null;
  }

  var canvas = document.createElement('canvas');

  if (!canvas) {
    return null;
  }

  var gl;
  canvas.width = width;
  canvas.height = height;

  try {
    gl = canvas.getContext('webgl', options);
  } catch (e) {
    try {
      gl = canvas.getContext('experimental-webgl', options);
    } catch (e) {
      return null;
    }
  }

  var _getExtension = gl.getExtension;
  var extDestroy = {
    destroy: function destroy() {
      var loseContext = _getExtension.call(gl, 'WEBGL_lose_context');

      if (loseContext) {
        loseContext.loseContext();
      }
    }
  };
  var extResize = {
    resize: function resize(w, h) {
      canvas.width = w;
      canvas.height = h;
    }
  };

  var _supportedExtensions = gl.getSupportedExtensions().slice();

  _supportedExtensions.push('STACKGL_destroy_context', 'STACKGL_resize_drawingbuffer');

  gl.getSupportedExtensions = function () {
    return _supportedExtensions.slice();
  };

  gl.getExtension = function (extName) {
    var name = extName.toLowerCase();

    if (name === 'stackgl_resize_drawingbuffer') {
      return extResize;
    }

    if (name === 'stackgl_destroy_context') {
      return extDestroy;
    }

    return _getExtension.call(gl, extName);
  };

  return gl || null;
}

module.exports = createContext;
},{}],"pGKr":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../../texture'),
    Texture = _require2.Texture;

var GLTextureFloat =
/*#__PURE__*/
function (_Texture) {
  _inherits(GLTextureFloat, _Texture);

  function GLTextureFloat(settings) {
    var _this;

    _classCallCheck(this, GLTextureFloat);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureFloat).call(this, settings));
    _this.type = 'ArrayTexture(1)';
    return _this;
  }

  _createClass(GLTextureFloat, [{
    key: "renderRawOutput",
    value: function renderRawOutput() {
      var gl = this.context;
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
      var result = new Float32Array(this.size[0] * this.size[1] * 4);
      gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.FLOAT, result);
      return result;
    }
  }, {
    key: "renderValues",
    value: function renderValues() {
      return this.renderRawOutput();
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return utils.erectFloat(this.renderValues(), this.output[0]);
    }
  }]);

  return GLTextureFloat;
}(Texture);

module.exports = {
  GLTextureFloat: GLTextureFloat
};
},{"../../../utils":"9h1E","../../../texture":"5wk/"}],"3so0":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray2Float =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray2Float, _GLTextureFloat);

  function GLTextureArray2Float(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray2Float);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray2Float).call(this, settings));
    _this.type = 'ArrayTexture(2)';
    return _this;
  }

  _createClass(GLTextureArray2Float, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureArray2Float;
}(GLTextureFloat);

module.exports = {
  GLTextureArray2Float: GLTextureArray2Float
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"AL2v":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray2Float2D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray2Float2D, _GLTextureFloat);

  function GLTextureArray2Float2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray2Float2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray2Float2D).call(this, settings));
    _this.type = 'ArrayTexture(2)';
    return _this;
  }

  _createClass(GLTextureArray2Float2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureArray2Float2D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray2Float2D: GLTextureArray2Float2D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"5IBC":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray2Float3D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray2Float3D, _GLTextureFloat);

  function GLTextureArray2Float3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray2Float3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray2Float3D).call(this, settings));
    _this.type = 'ArrayTexture(2)';
    return _this;
  }

  _createClass(GLTextureArray2Float3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureArray2Float3D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray2Float3D: GLTextureArray2Float3D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"w34L":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray3Float =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray3Float, _GLTextureFloat);

  function GLTextureArray3Float(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray3Float);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray3Float).call(this, settings));
    _this.type = 'ArrayTexture(3)';
    return _this;
  }

  _createClass(GLTextureArray3Float, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectArray3(this.renderValues(), this.output[0]);
    }
  }]);

  return GLTextureArray3Float;
}(GLTextureFloat);

module.exports = {
  GLTextureArray3Float: GLTextureArray3Float
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"fa9G":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray3Float2D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray3Float2D, _GLTextureFloat);

  function GLTextureArray3Float2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray3Float2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray3Float2D).call(this, settings));
    _this.type = 'ArrayTexture(3)';
    return _this;
  }

  _createClass(GLTextureArray3Float2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureArray3Float2D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray3Float2D: GLTextureArray3Float2D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"zKHH":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray3Float3D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray3Float3D, _GLTextureFloat);

  function GLTextureArray3Float3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray3Float3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray3Float3D).call(this, settings));
    _this.type = 'ArrayTexture(3)';
    return _this;
  }

  _createClass(GLTextureArray3Float3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureArray3Float3D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray3Float3D: GLTextureArray3Float3D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"mDHX":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray4Float =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray4Float, _GLTextureFloat);

  function GLTextureArray4Float(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray4Float);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray4Float).call(this, settings));
    _this.type = 'ArrayTexture(4)';
    return _this;
  }

  _createClass(GLTextureArray4Float, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectArray4(this.renderValues(), this.output[0]);
    }
  }]);

  return GLTextureArray4Float;
}(GLTextureFloat);

module.exports = {
  GLTextureArray4Float: GLTextureArray4Float
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"1FM4":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray4Float2D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray4Float2D, _GLTextureFloat);

  function GLTextureArray4Float2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray4Float2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray4Float2D).call(this, settings));
    _this.type = 'ArrayTexture(4)';
    return _this;
  }

  _createClass(GLTextureArray4Float2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureArray4Float2D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray4Float2D: GLTextureArray4Float2D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"sNHM":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureArray4Float3D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureArray4Float3D, _GLTextureFloat);

  function GLTextureArray4Float3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureArray4Float3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureArray4Float3D).call(this, settings));
    _this.type = 'ArrayTexture(4)';
    return _this;
  }

  _createClass(GLTextureArray4Float3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureArray4Float3D;
}(GLTextureFloat);

module.exports = {
  GLTextureArray4Float3D: GLTextureArray4Float3D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"GvNW":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureFloat2D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureFloat2D, _GLTextureFloat);

  function GLTextureFloat2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureFloat2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureFloat2D).call(this, settings));
    _this.type = 'ArrayTexture(1)';
    return _this;
  }

  _createClass(GLTextureFloat2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureFloat2D;
}(GLTextureFloat);

module.exports = {
  GLTextureFloat2D: GLTextureFloat2D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"b11a":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureFloat3D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureFloat3D, _GLTextureFloat);

  function GLTextureFloat3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureFloat3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureFloat3D).call(this, settings));
    _this.type = 'ArrayTexture(1)';
    return _this;
  }

  _createClass(GLTextureFloat3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureFloat3D;
}(GLTextureFloat);

module.exports = {
  GLTextureFloat3D: GLTextureFloat3D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"AYnK":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureMemoryOptimized =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureMemoryOptimized, _GLTextureFloat);

  function GLTextureMemoryOptimized(settings) {
    var _this;

    _classCallCheck(this, GLTextureMemoryOptimized);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureMemoryOptimized).call(this, settings));
    _this.type = 'MemoryOptimizedNumberTexture';
    return _this;
  }

  _createClass(GLTextureMemoryOptimized, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
    }
  }]);

  return GLTextureMemoryOptimized;
}(GLTextureFloat);

module.exports = {
  GLTextureMemoryOptimized: GLTextureMemoryOptimized
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"WmYa":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureMemoryOptimized2D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureMemoryOptimized2D, _GLTextureFloat);

  function GLTextureMemoryOptimized2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureMemoryOptimized2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureMemoryOptimized2D).call(this, settings));
    _this.type = 'MemoryOptimizedNumberTexture';
    return _this;
  }

  _createClass(GLTextureMemoryOptimized2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureMemoryOptimized2D;
}(GLTextureFloat);

module.exports = {
  GLTextureMemoryOptimized2D: GLTextureMemoryOptimized2D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"DzcW":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./float'),
    GLTextureFloat = _require2.GLTextureFloat;

var GLTextureMemoryOptimized3D =
/*#__PURE__*/
function (_GLTextureFloat) {
  _inherits(GLTextureMemoryOptimized3D, _GLTextureFloat);

  function GLTextureMemoryOptimized3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureMemoryOptimized3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureMemoryOptimized3D).call(this, settings));
    _this.type = 'MemoryOptimizedNumberTexture';
    return _this;
  }

  _createClass(GLTextureMemoryOptimized3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureMemoryOptimized3D;
}(GLTextureFloat);

module.exports = {
  GLTextureMemoryOptimized3D: GLTextureMemoryOptimized3D
};
},{"../../../utils":"9h1E","./float":"pGKr"}],"fg0H":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../../texture'),
    Texture = _require2.Texture;

var GLTextureUnsigned =
/*#__PURE__*/
function (_Texture) {
  _inherits(GLTextureUnsigned, _Texture);

  function GLTextureUnsigned(settings) {
    var _this;

    _classCallCheck(this, GLTextureUnsigned);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureUnsigned).call(this, settings));
    _this.type = 'NumberTexture';
    return _this;
  }

  _createClass(GLTextureUnsigned, [{
    key: "renderRawOutput",
    value: function renderRawOutput() {
      var gl = this.context;
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
      var result = new Uint8Array(this.size[0] * this.size[1] * 4);
      gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
      return result;
    }
  }, {
    key: "renderValues",
    value: function renderValues() {
      return new Float32Array(this.renderRawOutput().buffer);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return utils.erectPackedFloat(this.renderValues(), this.output[0]);
    }
  }]);

  return GLTextureUnsigned;
}(Texture);

module.exports = {
  GLTextureUnsigned: GLTextureUnsigned
};
},{"../../../utils":"9h1E","../../../texture":"5wk/"}],"w0F4":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./unsigned'),
    GLTextureUnsigned = _require2.GLTextureUnsigned;

var GLTextureUnsigned2D =
/*#__PURE__*/
function (_GLTextureUnsigned) {
  _inherits(GLTextureUnsigned2D, _GLTextureUnsigned);

  function GLTextureUnsigned2D(settings) {
    var _this;

    _classCallCheck(this, GLTextureUnsigned2D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureUnsigned2D).call(this, settings));
    _this.type = 'NumberTexture';
    return _this;
  }

  _createClass(GLTextureUnsigned2D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
    }
  }]);

  return GLTextureUnsigned2D;
}(GLTextureUnsigned);

module.exports = {
  GLTextureUnsigned2D: GLTextureUnsigned2D
};
},{"../../../utils":"9h1E","./unsigned":"fg0H"}],"SLHM":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./unsigned'),
    GLTextureUnsigned = _require2.GLTextureUnsigned;

var GLTextureUnsigned3D =
/*#__PURE__*/
function (_GLTextureUnsigned) {
  _inherits(GLTextureUnsigned3D, _GLTextureUnsigned);

  function GLTextureUnsigned3D(settings) {
    var _this;

    _classCallCheck(this, GLTextureUnsigned3D);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureUnsigned3D).call(this, settings));
    _this.type = 'NumberTexture';
    return _this;
  }

  _createClass(GLTextureUnsigned3D, [{
    key: "toArray",
    value: function toArray() {
      return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLTextureUnsigned3D;
}(GLTextureUnsigned);

module.exports = {
  GLTextureUnsigned3D: GLTextureUnsigned3D
};
},{"../../../utils":"9h1E","./unsigned":"fg0H"}],"CIOl":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./unsigned'),
    GLTextureUnsigned = _require.GLTextureUnsigned;

var GLTextureGraphical =
/*#__PURE__*/
function (_GLTextureUnsigned) {
  _inherits(GLTextureGraphical, _GLTextureUnsigned);

  function GLTextureGraphical(settings) {
    var _this;

    _classCallCheck(this, GLTextureGraphical);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTextureGraphical).call(this, settings));
    _this.type = 'ArrayTexture(4)';
    return _this;
  }

  _createClass(GLTextureGraphical, [{
    key: "toArray",
    value: function toArray() {
      return this.renderValues();
    }
  }]);

  return GLTextureGraphical;
}(GLTextureUnsigned);

module.exports = {
  GLTextureGraphical: GLTextureGraphical
};
},{"./unsigned":"fg0H"}],"8fdV":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../kernel'),
    Kernel = _require.Kernel;

var _require2 = require('../../texture'),
    Texture = _require2.Texture;

var _require3 = require('../../utils'),
    utils = _require3.utils;

var _require4 = require('./texture/array-2-float'),
    GLTextureArray2Float = _require4.GLTextureArray2Float;

var _require5 = require('./texture/array-2-float-2d'),
    GLTextureArray2Float2D = _require5.GLTextureArray2Float2D;

var _require6 = require('./texture/array-2-float-3d'),
    GLTextureArray2Float3D = _require6.GLTextureArray2Float3D;

var _require7 = require('./texture/array-3-float'),
    GLTextureArray3Float = _require7.GLTextureArray3Float;

var _require8 = require('./texture/array-3-float-2d'),
    GLTextureArray3Float2D = _require8.GLTextureArray3Float2D;

var _require9 = require('./texture/array-3-float-3d'),
    GLTextureArray3Float3D = _require9.GLTextureArray3Float3D;

var _require10 = require('./texture/array-4-float'),
    GLTextureArray4Float = _require10.GLTextureArray4Float;

var _require11 = require('./texture/array-4-float-2d'),
    GLTextureArray4Float2D = _require11.GLTextureArray4Float2D;

var _require12 = require('./texture/array-4-float-3d'),
    GLTextureArray4Float3D = _require12.GLTextureArray4Float3D;

var _require13 = require('./texture/float'),
    GLTextureFloat = _require13.GLTextureFloat;

var _require14 = require('./texture/float-2d'),
    GLTextureFloat2D = _require14.GLTextureFloat2D;

var _require15 = require('./texture/float-3d'),
    GLTextureFloat3D = _require15.GLTextureFloat3D;

var _require16 = require('./texture/memory-optimized'),
    GLTextureMemoryOptimized = _require16.GLTextureMemoryOptimized;

var _require17 = require('./texture/memory-optimized-2d'),
    GLTextureMemoryOptimized2D = _require17.GLTextureMemoryOptimized2D;

var _require18 = require('./texture/memory-optimized-3d'),
    GLTextureMemoryOptimized3D = _require18.GLTextureMemoryOptimized3D;

var _require19 = require('./texture/unsigned'),
    GLTextureUnsigned = _require19.GLTextureUnsigned;

var _require20 = require('./texture/unsigned-2d'),
    GLTextureUnsigned2D = _require20.GLTextureUnsigned2D;

var _require21 = require('./texture/unsigned-3d'),
    GLTextureUnsigned3D = _require21.GLTextureUnsigned3D;

var _require22 = require('./texture/graphical'),
    GLTextureGraphical = _require22.GLTextureGraphical;
/**
 * @abstract
 * @extends Kernel
 */


var GLKernel =
/*#__PURE__*/
function (_Kernel) {
  _inherits(GLKernel, _Kernel);

  _createClass(GLKernel, [{
    key: "setFixIntegerDivisionAccuracy",

    /**
     * @desc Fix division by factor of 3 FP accuracy bug
     * @param {Boolean} fix - should fix
     */
    value: function setFixIntegerDivisionAccuracy(fix) {
      this.fixIntegerDivisionAccuracy = fix;
      return this;
    }
    /**
     * @desc Toggle output mode
     * @param {String} flag - 'single' or 'unsigned'
     */

  }, {
    key: "setPrecision",
    value: function setPrecision(flag) {
      this.precision = flag;
      return this;
    }
    /**
     * @desc Toggle texture output mode
     * @param {Boolean} flag - true to enable floatTextures
     * @deprecated
     */

  }, {
    key: "setFloatTextures",
    value: function setFloatTextures(flag) {
      utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
      this.floatTextures = flag;
      return this;
    }
    /**
     * A highly readable very forgiving micro-parser for a glsl function that gets argument types
     * @param {String} source
     * @returns {{argumentTypes: String[], argumentNames: String[]}}
     */

  }], [{
    key: "getIsFloatRead",
    value: function getIsFloatRead() {
      var kernelString = "function kernelFunction() {\n      return 1;\n    }";
      var kernel = new this(kernelString, {
        context: this.testContext,
        canvas: this.testCanvas,
        validate: false,
        output: [1],
        precision: 'single',
        returnType: 'Number'
      });
      kernel.build();
      kernel.run();
      var result = kernel.renderOutput();
      kernel.destroy(true);
      return result[0] === 1;
    }
  }, {
    key: "getIsIntegerDivisionAccurate",
    value: function getIsIntegerDivisionAccurate() {
      function kernelFunction(v1, v2) {
        return v1[this.thread.x] / v2[this.thread.x];
      }

      var kernel = new this(kernelFunction.toString(), {
        context: this.testContext,
        canvas: this.testCanvas,
        validate: false,
        output: [2],
        returnType: 'Number',
        precision: 'unsigned'
      });
      var args = [[6, 6030401], [3, 3991]];
      kernel.build.apply(kernel, args);
      kernel.run.apply(kernel, args);
      var result = kernel.renderOutput();
      kernel.destroy(true); // have we not got whole numbers for 6/3 or 6030401/3991
      // add more here if others see this problem

      return result[0] === 2 && result[1] === 1511;
    }
    /**
     * @abstract
     */

  }, {
    key: "setupFeatureChecks",

    /**
     * @abstract
     */
    value: function setupFeatureChecks() {
      throw new Error("\"setupFeatureChecks\" not defined on ".concat(this.name));
    }
  }, {
    key: "nativeFunctionArguments",
    value: function nativeFunctionArguments(source) {
      var argumentTypes = [];
      var argumentNames = [];
      var states = [];
      var isStartingVariableName = /^[a-zA-Z_]/;
      var isVariableChar = /[a-zA-Z_0-9]/;
      var i = 0;
      var argumentName = null;
      var argumentType = null;

      while (i < source.length) {
        var char = source[i];
        var nextChar = source[i + 1];
        var state = states.length > 0 ? states[states.length - 1] : null; // begin MULTI_LINE_COMMENT handling

        if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
          states.push('MULTI_LINE_COMMENT');
          i += 2;
          continue;
        } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
          states.pop();
          i += 2;
          continue;
        } // end MULTI_LINE_COMMENT handling
        // begin COMMENT handling
        else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
            states.push('COMMENT');
            i += 2;
            continue;
          } else if (state === 'COMMENT' && char === '\n') {
            states.pop();
            i++;
            continue;
          } // end COMMENT handling
          // being FUNCTION_ARGUMENTS handling
          else if (state === null && char === '(') {
              states.push('FUNCTION_ARGUMENTS');
              i++;
              continue;
            } else if (state === 'FUNCTION_ARGUMENTS') {
              if (char === ')') {
                states.pop();
                break;
              }

              if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'float';
                argumentName = '';
                i += 6;
                continue;
              } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'int';
                argumentName = '';
                i += 4;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec2';
                argumentName = '';
                i += 5;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec3';
                argumentName = '';
                i += 5;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec4';
                argumentName = '';
                i += 5;
                continue;
              }
            } // end FUNCTION_ARGUMENTS handling
            // begin DECLARE_VARIABLE handling
            else if (state === 'DECLARE_VARIABLE') {
                if (argumentName === '') {
                  if (char === ' ') {
                    i++;
                    continue;
                  }

                  if (!isStartingVariableName.test(char)) {
                    throw new Error('variable name is not expected string');
                  }
                }

                argumentName += char;

                if (!isVariableChar.test(nextChar)) {
                  states.pop();
                  argumentNames.push(argumentName);
                  argumentTypes.push(typeMap[argumentType]);
                }
              } // end DECLARE_VARIABLE handling
        // Progress to next character


        i++;
      }

      if (states.length > 0) {
        throw new Error('GLSL function was not parsable');
      }

      return {
        argumentNames: argumentNames,
        argumentTypes: argumentTypes
      };
    }
  }, {
    key: "nativeFunctionReturnType",
    value: function nativeFunctionReturnType(source) {
      return typeMap[source.match(/int|float|vec[2-4]/)[0]];
    }
  }, {
    key: "combineKernels",
    value: function combineKernels(combinedKernel, lastKernel) {
      combinedKernel.apply(null, arguments);
      var _lastKernel$texSize = lastKernel.texSize,
          texSize = _lastKernel$texSize.texSize,
          context = _lastKernel$texSize.context,
          threadDim = _lastKernel$texSize.threadDim;
      var result;

      if (lastKernel.precision === 'single') {
        var w = texSize[0];
        var h = Math.ceil(texSize[1] / 4);
        result = new Float32Array(w * h * 4 * 4);
        context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
      } else {
        var bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
        context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
        result = new Float32Array(bytes.buffer);
      }

      result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

      if (lastKernel.output.length === 1) {
        return result;
      } else if (lastKernel.output.length === 2) {
        return utils.splitArray(result, lastKernel.output[0]);
      } else if (lastKernel.output.length === 3) {
        var cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
        return cube.map(function (x) {
          return utils.splitArray(x, lastKernel.output[0]);
        });
      }
    }
  }, {
    key: "mode",
    get: function get() {
      return 'gpu';
    }
  }, {
    key: "testCanvas",
    get: function get() {
      throw new Error("\"testCanvas\" not defined on ".concat(this.name));
    }
    /**
     * @abstract
     */

  }, {
    key: "testContext",
    get: function get() {
      throw new Error("\"testContext\" not defined on ".concat(this.name));
    }
    /**
     * @type {IKernelFeatures}
     */

  }, {
    key: "features",
    get: function get() {
      throw new Error("\"features\" not defined on ".concat(this.name));
    }
  }]);

  function GLKernel(source, settings) {
    var _this;

    _classCallCheck(this, GLKernel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLKernel).call(this, source, settings));
    _this.transferValues = null;
    _this.formatValues = null;
    _this.TextureConstructor = null;
    _this.renderOutput = null;
    _this.renderRawOutput = null;
    _this.texSize = null;
    _this.fixIntegerDivisionAccuracy = null;
    _this.translatedSource = null;
    _this.renderStrategy = null;
    _this.compiledFragmentShader = null;
    _this.compiledVertexShader = null;
    return _this;
  }

  _createClass(GLKernel, [{
    key: "translateSource",
    value: function translateSource() {
      throw new Error("\"translateSource\" not defined on ".concat(this.constructor.name));
    }
    /**
     * Picks a render strategy for the now finally parsed kernel
     * @param args
     * @return {null|KernelOutput}
     */

  }, {
    key: "pickRenderStrategy",
    value: function pickRenderStrategy(args) {
      if (this.graphical) {
        this.renderRawOutput = this.readPackedPixelsToUint8Array;

        this.transferValues = function (pixels) {
          return pixels;
        };

        this.TextureConstructor = GLTextureGraphical;
        return null;
      }

      if (this.precision === 'unsigned') {
        this.renderRawOutput = this.readPackedPixelsToUint8Array;
        this.transferValues = this.readPackedPixelsToFloat32Array;

        if (this.pipeline) {
          this.renderOutput = this.renderTexture;

          if (this.subKernels !== null) {
            this.renderKernels = this.renderKernelsToTextures;
          }

          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureUnsigned3D;
                this.renderStrategy = renderStrategy.PackedPixelTo3DFloat;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureUnsigned2D;
                this.renderStrategy = renderStrategy.PackedPixelTo2DFloat;
                return null;
              } else {
                this.TextureConstructor = GLTextureUnsigned;
                this.renderStrategy = renderStrategy.PackedPixelToFloat;
                return null;
              }

              break;

            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
          }
        } else {
          if (this.subKernels !== null) {
            this.renderKernels = this.renderKernelsToArrays;
          }

          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              this.renderOutput = this.renderValues;

              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureUnsigned3D;
                this.renderStrategy = renderStrategy.PackedPixelTo3DFloat;
                this.formatValues = utils.erect3DPackedFloat;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureUnsigned2D;
                this.renderStrategy = renderStrategy.PackedPixelTo2DFloat;
                this.formatValues = utils.erect2DPackedFloat;
                return null;
              } else {
                this.TextureConstructor = GLTextureUnsigned;
                this.renderStrategy = renderStrategy.PackedPixelToFloat;
                this.formatValues = utils.erectPackedFloat;
                return null;
              }

              break;

            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
          }
        }
      } else if (this.precision === 'single') {
        this.renderRawOutput = this.readFloatPixelsToFloat32Array;
        this.transferValues = this.readFloatPixelsToFloat32Array;

        if (this.pipeline) {
          this.renderStrategy = renderStrategy.FloatTexture;
          this.renderOutput = this.renderTexture;

          if (this.subKernels !== null) {
            this.renderKernels = this.renderKernelsToTextures;
          }

          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              if (this.optimizeFloatMemory) {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureMemoryOptimized3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureMemoryOptimized2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureMemoryOptimized;
                  return null;
                }
              } else {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureFloat3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureFloat2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureFloat;
                  return null;
                }
              }

              break;

            case 'Array(2)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray2Float3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray2Float2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray2Float;
                return null;
              }

              break;

            case 'Array(3)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray3Float3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray3Float2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray3Float;
                return null;
              }

              break;

            case 'Array(4)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray4Float3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray4Float2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray4Float;
                return null;
              }

          }
        }

        this.renderOutput = this.renderValues;

        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }

        if (this.optimizeFloatMemory) {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimized3DFloat;
                this.formatValues = utils.erectMemoryOptimized3DFloat;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimized2DFloat;
                this.formatValues = utils.erectMemoryOptimized2DFloat;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                this.renderStrategy = renderStrategy.MemoryOptimizedFloatPixelToMemoryOptimizedFloat;
                this.formatValues = utils.erectMemoryOptimizedFloat;
                return null;
              }

              break;

            case 'Array(2)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray2Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray2;
                this.formatValues = utils.erect3DArray2;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray2Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray2;
                this.formatValues = utils.erect2DArray2;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray2Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray2;
                this.formatValues = utils.erectArray2;
                return null;
              }

              break;

            case 'Array(3)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray3Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray3;
                this.formatValues = utils.erect3DArray3;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray3Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray3;
                this.formatValues = utils.erect2DArray3;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray3Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray3;
                this.formatValues = utils.erectArray3;
                return null;
              }

              break;

            case 'Array(4)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray4Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray4;
                this.formatValues = utils.erect3DArray4;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray4Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray4;
                this.formatValues = utils.erect2DArray4;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray4Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray4;
                this.formatValues = utils.erectArray4;
                return null;
              }

          }
        } else {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DFloat;
                this.formatValues = utils.erect3DFloat;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DFloat;
                this.formatValues = utils.erect2DFloat;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                this.renderStrategy = renderStrategy.FloatPixelToFloat;
                this.formatValues = utils.erectFloat;
                return null;
              }

              break;

            case 'Array(2)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray2Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray2;
                this.formatValues = utils.erect3DArray2;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray2Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray2;
                this.formatValues = utils.erect2DArray2;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray2Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray2;
                this.formatValues = utils.erectArray2;
                return null;
              }

              break;

            case 'Array(3)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray3Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray3;
                this.formatValues = utils.erect3DArray3;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray3Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray3;
                this.formatValues = utils.erect2DArray3;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray3Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray3;
                this.formatValues = utils.erectArray3;
                return null;
              }

              break;

            case 'Array(4)':
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureArray4Float3D;
                this.renderStrategy = renderStrategy.FloatPixelTo3DArray4;
                this.formatValues = utils.erect3DArray4;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureArray4Float2D;
                this.renderStrategy = renderStrategy.FloatPixelTo2DArray4;
                this.formatValues = utils.erect2DArray4;
                return null;
              } else {
                this.TextureConstructor = GLTextureArray4Float;
                this.renderStrategy = renderStrategy.FloatPixelToArray4;
                this.formatValues = utils.erectArray4;
                return null;
              }

          }
        }
      } else {
        throw new Error("unhandled precision of \"".concat(this.precision, "\""));
      }

      throw new Error("unhandled return type \"".concat(this.returnType, "\""));
    }
    /**
     * @abstract
     * @returns String
     */

  }, {
    key: "getKernelString",
    value: function getKernelString() {
      throw new Error("abstract method call");
    }
  }, {
    key: "getMainResultTexture",
    value: function getMainResultTexture() {
      switch (this.returnType) {
        case 'LiteralInteger':
        case 'Float':
        case 'Integer':
        case 'Number':
          return this.getMainResultNumberTexture();

        case 'Array(2)':
          return this.getMainResultArray2Texture();

        case 'Array(3)':
          return this.getMainResultArray3Texture();

        case 'Array(4)':
          return this.getMainResultArray4Texture();

        default:
          throw new Error("unhandled returnType type ".concat(this.returnType));
      }
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultKernelNumberTexture",
    value: function getMainResultKernelNumberTexture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultSubKernelNumberTexture",
    value: function getMainResultSubKernelNumberTexture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultKernelArray2Texture",
    value: function getMainResultKernelArray2Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultSubKernelArray2Texture",
    value: function getMainResultSubKernelArray2Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultKernelArray3Texture",
    value: function getMainResultKernelArray3Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultSubKernelArray3Texture",
    value: function getMainResultSubKernelArray3Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultKernelArray4Texture",
    value: function getMainResultKernelArray4Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultSubKernelArray4Texture",
    value: function getMainResultSubKernelArray4Texture() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultGraphical",
    value: function getMainResultGraphical() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultMemoryOptimizedFloats",
    value: function getMainResultMemoryOptimizedFloats() {
      throw new Error("abstract method call");
    }
    /**
     * @abstract
     * @returns String[]
     */

  }, {
    key: "getMainResultPackedPixels",
    value: function getMainResultPackedPixels() {
      throw new Error("abstract method call");
    }
  }, {
    key: "getMainResultString",
    value: function getMainResultString() {
      if (this.graphical) {
        return this.getMainResultGraphical();
      } else if (this.precision === 'single') {
        if (this.optimizeFloatMemory) {
          return this.getMainResultMemoryOptimizedFloats();
        }

        return this.getMainResultTexture();
      } else {
        return this.getMainResultPackedPixels();
      }
    }
  }, {
    key: "getMainResultNumberTexture",
    value: function getMainResultNumberTexture() {
      return utils.linesToString(this.getMainResultKernelNumberTexture()) + utils.linesToString(this.getMainResultSubKernelNumberTexture());
    }
  }, {
    key: "getMainResultArray2Texture",
    value: function getMainResultArray2Texture() {
      return utils.linesToString(this.getMainResultKernelArray2Texture()) + utils.linesToString(this.getMainResultSubKernelArray2Texture());
    }
  }, {
    key: "getMainResultArray3Texture",
    value: function getMainResultArray3Texture() {
      return utils.linesToString(this.getMainResultKernelArray3Texture()) + utils.linesToString(this.getMainResultSubKernelArray3Texture());
    }
  }, {
    key: "getMainResultArray4Texture",
    value: function getMainResultArray4Texture() {
      return utils.linesToString(this.getMainResultKernelArray4Texture()) + utils.linesToString(this.getMainResultSubKernelArray4Texture());
    }
  }, {
    key: "renderTexture",
    value: function renderTexture() {
      return new this.TextureConstructor({
        texture: this.outputTexture,
        size: this.texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context
      });
    }
  }, {
    key: "readPackedPixelsToUint8Array",
    value: function readPackedPixelsToUint8Array() {
      if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
      var texSize = this.texSize,
          gl = this.context;
      var result = new Uint8Array(texSize[0] * texSize[1] * 4);
      gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
      return result;
    }
  }, {
    key: "readPackedPixelsToFloat32Array",
    value: function readPackedPixelsToFloat32Array() {
      return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
    }
  }, {
    key: "readFloatPixelsToFloat32Array",
    value: function readFloatPixelsToFloat32Array() {
      if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
      var texSize = this.texSize,
          gl = this.context;
      var w = texSize[0];
      var h = texSize[1];
      var result = new Float32Array(w * h * 4);
      gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
      return result;
    }
  }, {
    key: "readMemoryOptimizedFloatPixelsToFloat32Array",
    value: function readMemoryOptimizedFloatPixelsToFloat32Array() {
      if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
      var texSize = this.texSize,
          gl = this.context;
      var w = texSize[0];
      var h = texSize[1];
      var result = new Float32Array(w * h * 4);
      gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
      return result;
    }
    /**
     *
     * @param {Boolean} [flip]
     * @return {Uint8Array}
     */

  }, {
    key: "getPixels",
    value: function getPixels(flip) {
      var gl = this.context,
          output = this.output;

      var _output = _slicedToArray(output, 2),
          width = _output[0],
          height = _output[1];

      var pixels = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels); // flipped by default, so invert

      return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
    }
  }, {
    key: "renderKernelsToArrays",
    value: function renderKernelsToArrays() {
      var result = {
        result: this.renderOutput()
      };

      for (var i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = new this.TextureConstructor({
          texture: this.subKernelOutputTextures[i],
          size: this.texSize,
          dimensions: this.threadDim,
          output: this.output,
          context: this.context
        }).toArray();
      }

      return result;
    }
  }, {
    key: "renderKernelsToTextures",
    value: function renderKernelsToTextures() {
      var result = {
        result: this.renderOutput()
      };

      for (var i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = new this.TextureConstructor({
          texture: this.subKernelOutputTextures[i],
          size: this.texSize,
          dimensions: this.threadDim,
          output: this.output,
          context: this.context
        });
      }

      return result;
    }
  }, {
    key: "setOutput",
    value: function setOutput(output) {
      _get(_getPrototypeOf(GLKernel.prototype), "setOutput", this).call(this, output);

      if (this.program) {
        this.threadDim = [this.output[0], this.output[1] || 1, this.output[2] || 1];
        this.texSize = utils.getKernelTextureSize({
          optimizeFloatMemory: this.optimizeFloatMemory,
          precision: this.precision
        }, this.output);
        var gl = this.context;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        this.updateMaxTexSize();
        this.framebuffer.width = this.texSize[0];
        this.framebuffer.height = this.texSize[1];
        this.context.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
        this.canvas.width = this.maxTexSize[0];
        this.canvas.height = this.maxTexSize[1];

        this._setupOutputTexture();

        if (this.subKernels && this.subKernels.length > 0) {
          this._setupSubOutputTextures();
        }
      }

      return this;
    }
  }, {
    key: "renderValues",
    value: function renderValues() {
      return this.formatValues(this.transferValues(), this.output[0], this.output[1], this.output[2]);
    }
  }]);

  return GLKernel;
}(Kernel);

var renderStrategy = Object.freeze({
  PackedPixelToUint8Array: Symbol('PackedPixelToUint8Array'),
  PackedPixelToFloat: Symbol('PackedPixelToFloat'),
  PackedPixelTo2DFloat: Symbol('PackedPixelTo2DFloat'),
  PackedPixelTo3DFloat: Symbol('PackedPixelTo3DFloat'),
  PackedTexture: Symbol('PackedTexture'),
  FloatPixelToFloat32Array: Symbol('FloatPixelToFloat32Array'),
  FloatPixelToFloat: Symbol('FloatPixelToFloat'),
  FloatPixelTo2DFloat: Symbol('FloatPixelTo2DFloat'),
  FloatPixelTo3DFloat: Symbol('FloatPixelTo3DFloat'),
  FloatPixelToArray2: Symbol('FloatPixelToArray2'),
  FloatPixelTo2DArray2: Symbol('FloatPixelTo2DArray2'),
  FloatPixelTo3DArray2: Symbol('FloatPixelTo3DArray2'),
  FloatPixelToArray3: Symbol('FloatPixelToArray3'),
  FloatPixelTo2DArray3: Symbol('FloatPixelTo2DArray3'),
  FloatPixelTo3DArray3: Symbol('FloatPixelTo3DArray3'),
  FloatPixelToArray4: Symbol('FloatPixelToArray4'),
  FloatPixelTo2DArray4: Symbol('FloatPixelTo2DArray4'),
  FloatPixelTo3DArray4: Symbol('FloatPixelTo3DArray4'),
  FloatTexture: Symbol('FloatTexture'),
  MemoryOptimizedFloatPixelToMemoryOptimizedFloat: Symbol('MemoryOptimizedFloatPixelToFloat'),
  MemoryOptimizedFloatPixelToMemoryOptimized2DFloat: Symbol('MemoryOptimizedFloatPixelTo2DFloat'),
  MemoryOptimizedFloatPixelToMemoryOptimized3DFloat: Symbol('MemoryOptimizedFloatPixelTo3DFloat')
});
var typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)'
};
module.exports = {
  GLKernel: GLKernel,
  renderStrategy: renderStrategy
};
},{"../kernel":"JYjN","../../texture":"5wk/","../../utils":"9h1E","./texture/array-2-float":"3so0","./texture/array-2-float-2d":"AL2v","./texture/array-2-float-3d":"5IBC","./texture/array-3-float":"w34L","./texture/array-3-float-2d":"fa9G","./texture/array-3-float-3d":"zKHH","./texture/array-4-float":"mDHX","./texture/array-4-float-2d":"1FM4","./texture/array-4-float-3d":"sNHM","./texture/float":"pGKr","./texture/float-2d":"GvNW","./texture/float-3d":"b11a","./texture/memory-optimized":"AYnK","./texture/memory-optimized-2d":"WmYa","./texture/memory-optimized-3d":"DzcW","./texture/unsigned":"fg0H","./texture/unsigned-2d":"w0F4","./texture/unsigned-3d":"SLHM","./texture/graphical":"CIOl"}],"TrAu":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../utils'),
    utils = _require.utils;

var _require2 = require('../function-node'),
    FunctionNode = _require2.FunctionNode; // Closure capture for the ast function, prevent collision with existing AST functions
// The prefixes to use


var jsMathPrefix = 'Math.';
var localPrefix = 'this.';
/**
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to toString its respective WebGL code
 * @extends FunctionNode
 * @returns the converted WebGL function string
 */

var WebGLFunctionNode =
/*#__PURE__*/
function (_FunctionNode) {
  _inherits(WebGLFunctionNode, _FunctionNode);

  function WebGLFunctionNode(source, settings) {
    var _this;

    _classCallCheck(this, WebGLFunctionNode);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLFunctionNode).call(this, source, settings));
    _this.fixIntegerDivisionAccuracy = null;

    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      _this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }

    return _this;
  }
  /**
   * @desc Parses the abstract syntax tree for to its *named function*
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   * @returns {Array} the append retArr
   */


  _createClass(WebGLFunctionNode, [{
    key: "astFunction",
    value: function astFunction(ast, retArr) {
      // Setup function return type and name
      if (this.isRootKernel) {
        retArr.push('void');
      } else {
        // looking up return type, this is a little expensive, and can be avoided if returnType is set
        var lastReturn = null;

        if (!this.returnType) {
          var _lastReturn = this.findLastReturn();

          if (_lastReturn) {
            this.returnType = this.getType(ast.body);

            if (this.returnType === 'LiteralInteger') {
              this.returnType = 'Number';
            }
          }
        }

        var returnType = this.returnType;

        if (!returnType) {
          retArr.push('void');
        } else {
          var type = typeMap[returnType];

          if (!type) {
            throw new Error("unknown type ".concat(returnType));
          }

          retArr.push(type);
        }
      }

      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      if (!this.isRootKernel) {
        // Arguments handling
        for (var i = 0; i < this.argumentNames.length; ++i) {
          var argumentName = this.argumentNames[i];

          if (i > 0) {
            retArr.push(', ');
          }

          var argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)]; // The type is too loose ended, here we descide to solidify a type, lets go with float

          if (!argumentType) {
            throw this.astErrorOutput("Unknown argument ".concat(argumentName, " type"), ast);
          }

          if (argumentType === 'LiteralInteger') {
            this.argumentTypes[i] = argumentType = 'Number';
          }

          var _type = typeMap[argumentType];

          if (!_type) {
            throw this.astErrorOutput('Unexpected expression', ast);
          }

          retArr.push(_type);
          retArr.push(' ');
          retArr.push('user_');
          retArr.push(argumentName);
        }
      } // Function opening


      retArr.push(') {\n'); // Body statement iteration

      for (var _i = 0; _i < ast.body.body.length; ++_i) {
        this.astGeneric(ast.body.body[_i], retArr);
        retArr.push('\n');
      } // Function closing


      retArr.push('}\n');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for to *return* statement
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astReturnStatement",
    value: function astReturnStatement(ast, retArr) {
      if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
      var type = this.getType(ast.argument);
      var result = [];

      if (!this.returnType) {
        if (type === 'LiteralInteger' || type === 'Integer') {
          this.returnType = 'Number';
        } else {
          this.returnType = type;
        }
      }

      switch (this.returnType) {
        case 'LiteralInteger':
        case 'Number':
        case 'Float':
          switch (type) {
            case 'Integer':
              result.push('float(');
              this.astGeneric(ast.argument, result);
              result.push(')');
              break;

            case 'LiteralInteger':
              this.castLiteralToFloat(ast.argument, result); // Running astGeneric forces the LiteralInteger to pick a type, and here, if we are returning a float, yet
              // the LiteralInteger has picked to be an integer because of constraints on it we cast it to float.

              if (this.getType(ast) === 'Integer') {
                result.unshift('float(');
                result.push(')');
              }

              break;

            default:
              this.astGeneric(ast.argument, result);
          }

          break;

        case 'Integer':
          switch (type) {
            case 'Float':
            case 'Number':
              this.castValueToInteger(ast.argument, result);
              break;

            case 'LiteralInteger':
              this.castLiteralToInteger(ast.argument, result);
              break;

            default:
              this.astGeneric(ast.argument, result);
          }

          break;

        case 'Array(4)':
        case 'Array(3)':
        case 'Array(2)':
        case 'Input':
          this.astGeneric(ast.argument, result);
          break;

        default:
          throw this.astErrorOutput("unhandled return type ".concat(this.returnType), ast);
      }

      if (this.isRootKernel) {
        retArr.push("kernelResult = ".concat(result.join(''), ";"));
        retArr.push('return;');
      } else if (this.isSubKernel) {
        retArr.push("subKernelResult_".concat(this.name, " = ").concat(result.join(''), ";"));
        retArr.push("return subKernelResult_".concat(this.name, ";"));
      } else {
        retArr.push("return ".concat(result.join(''), ";"));
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *literal value*
     *
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     *
     * @returns {Array} the append retArr
     */

  }, {
    key: "astLiteral",
    value: function astLiteral(ast, retArr) {
      // Reject non numeric literals
      if (isNaN(ast.value)) {
        throw this.astErrorOutput('Non-numeric literal not supported : ' + ast.value, ast);
      }

      if (Number.isInteger(ast.value)) {
        if (this.isState('in-for-loop-init') || this.isState('casting-to-integer')) {
          this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Integer';
          retArr.push("".concat(ast.value));
        } else if (this.isState('casting-to-float')) {
          this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Number';
          retArr.push("".concat(ast.value, ".0"));
        } else {
          this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Number';
          retArr.push("".concat(ast.value, ".0"));
        }
      } else if (this.isState('casting-to-integer')) {
        this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Integer';
        retArr.push(parseInt(ast.raw));
      } else {
        this.literalTypes["".concat(ast.start, ",").concat(ast.end)] = 'Number';
        retArr.push("".concat(ast.value));
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *binary* expression
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astBinaryExpression",
    value: function astBinaryExpression(ast, retArr) {
      if (this.checkAndUpconvertOperator(ast, retArr)) {
        return retArr;
      }

      if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
        retArr.push('div_with_int_check(');

        switch (this.getType(ast.left)) {
          case 'Integer':
            this.castValueToFloat(ast.left, retArr);
            break;

          case 'LiteralInteger':
            this.castLiteralToFloat(ast.left, retArr);
            break;

          default:
            this.astGeneric(ast.left, retArr);
        }

        retArr.push(', ');

        switch (this.getType(ast.right)) {
          case 'Integer':
            this.castValueToFloat(ast.right, retArr);
            break;

          case 'LiteralInteger':
            this.castLiteralToFloat(ast.right, retArr);
            break;

          default:
            this.astGeneric(ast.right, retArr);
        }

        retArr.push(')');
        return retArr;
      }

      retArr.push('(');
      var leftType = this.getType(ast.left) || 'Number';
      var rightType = this.getType(ast.right) || 'Number';

      if (!leftType || !rightType) {
        throw this.astErrorOutput("Unhandled binary expression", ast);
      }

      var key = leftType + ' & ' + rightType;

      switch (key) {
        case 'Integer & Integer':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          break;

        case 'Number & Float':
        case 'Float & Number':
        case 'Float & Float':
        case 'Number & Number':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          break;

        case 'LiteralInteger & LiteralInteger':
          if (this.isState('casting-to-integer')) {
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
          } else {
            this.castLiteralToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castLiteralToFloat(ast.right, retArr);
          }

          break;

        case 'Integer & Float':
        case 'Integer & Number':
          if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
            // if right value is actually a float, don't loose that information, cast left to right rather than the usual right to left
            if (!Number.isInteger(ast.right.value)) {
              this.castValueToFloat(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              break;
            }
          }

          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-integer');

          if (ast.right.type === 'Literal') {
            var literalResult = [];
            this.astGeneric(ast.right, literalResult);
            var literalType = this.getType(ast.right);

            if (literalType === 'Integer') {
              retArr.push(literalResult.join(''));
            } else {
              throw this.astErrorOutput("Unhandled binary expression with literal", ast);
            }
          } else {
            retArr.push('int(');
            this.astGeneric(ast.right, retArr);
            retArr.push(')');
          }

          this.popState('casting-to-integer');
          break;

        case 'Integer & LiteralInteger':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToInteger(ast.right, retArr);
          break;

        case 'Number & Integer':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToFloat(ast.right, retArr);
          break;

        case 'Float & LiteralInteger':
        case 'Number & LiteralInteger':
          if (this.isState('in-for-loop-test')) {
            retArr.push('int(');
            this.astGeneric(ast.left, retArr);
            retArr.push(')');
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castLiteralToInteger(ast.right, retArr);
          } else {
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castLiteralToFloat(ast.right, retArr);
          }

          break;

        case 'LiteralInteger & Float':
        case 'LiteralInteger & Number':
          if (this.isState('in-for-loop-test') || this.isState('in-for-loop-init') || this.isState('casting-to-integer')) {
            this.castLiteralToInteger(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castValueToInteger(ast.right, retArr);
          } else {
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.pushState('casting-to-float');
            this.astGeneric(ast.right, retArr);
            this.popState('casting-to-float');
          }

          break;

        case 'LiteralInteger & Integer':
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          break;

        case 'Boolean & Boolean':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          break;

        case 'Float & Integer':
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToFloat(ast.right, retArr);
          break;

        default:
          throw this.astErrorOutput("Unhandled binary expression between ".concat(key), ast);
      }

      retArr.push(')');
      return retArr;
    }
  }, {
    key: "checkAndUpconvertOperator",
    value: function checkAndUpconvertOperator(ast, retArr) {
      var bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);

      if (bitwiseResult) {
        return bitwiseResult;
      }

      var upconvertableOperators = {
        '%': 'mod',
        '**': 'pow'
      };
      var foundOperator = upconvertableOperators[ast.operator];
      if (!foundOperator) return null;
      retArr.push(foundOperator);
      retArr.push('(');

      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;

        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;

        default:
          this.astGeneric(ast.left, retArr);
      }

      retArr.push(',');

      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;

        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;

        default:
          this.astGeneric(ast.right, retArr);
      }

      retArr.push(')');
      return retArr;
    }
  }, {
    key: "checkAndUpconvertBitwiseOperators",
    value: function checkAndUpconvertBitwiseOperators(ast, retArr) {
      var upconvertableOperators = {
        '&': 'bitwiseAnd',
        '|': 'bitwiseOr',
        '^': 'bitwiseXOR',
        '<<': 'bitwiseZeroFillLeftShift',
        '>>': 'bitwiseSignedRightShift',
        '>>>': 'bitwiseZeroFillRightShift'
      };
      var foundOperator = upconvertableOperators[ast.operator];
      if (!foundOperator) return null;
      retArr.push(foundOperator);
      retArr.push('(');
      var leftType = this.getType(ast.left);

      switch (leftType) {
        case 'Number':
        case 'Float':
          this.castValueToInteger(ast.left, retArr);
          break;

        case 'LiteralInteger':
          this.castLiteralToInteger(ast.left, retArr);
          break;

        default:
          this.astGeneric(ast.left, retArr);
      }

      retArr.push(',');
      var rightType = this.getType(ast.right);

      switch (rightType) {
        case 'Number':
        case 'Float':
          this.castValueToInteger(ast.right, retArr);
          break;

        case 'LiteralInteger':
          this.castLiteralToInteger(ast.right, retArr);
          break;

        default:
          this.astGeneric(ast.right, retArr);
      }

      retArr.push(')');
      return retArr;
    }
  }, {
    key: "checkAndUpconvertBitwiseUnary",
    value: function checkAndUpconvertBitwiseUnary(ast, retArr) {
      var upconvertableOperators = {
        '~': 'bitwiseNot'
      };
      var foundOperator = upconvertableOperators[ast.operator];
      if (!foundOperator) return null;
      retArr.push(foundOperator);
      retArr.push('(');

      switch (this.getType(ast.argument)) {
        case 'Number':
        case 'Float':
          this.castValueToInteger(ast.argument, retArr);
          break;

        case 'LiteralInteger':
          this.castLiteralToInteger(ast.argument, retArr);
          break;

        default:
          this.astGeneric(ast.argument, retArr);
      }

      retArr.push(')');
      return retArr;
    }
    /**
     *
     * @param {Object} ast
     * @param {Array} retArr
     * @return {String[]}
     */

  }, {
    key: "castLiteralToInteger",
    value: function castLiteralToInteger(ast, retArr) {
      this.pushState('casting-to-integer');
      this.astGeneric(ast, retArr);
      this.popState('casting-to-integer');
      return retArr;
    }
    /**
     *
     * @param {Object} ast
     * @param {Array} retArr
     * @return {String[]}
     */

  }, {
    key: "castLiteralToFloat",
    value: function castLiteralToFloat(ast, retArr) {
      this.pushState('casting-to-float');
      this.astGeneric(ast, retArr);
      this.popState('casting-to-float');
      return retArr;
    }
    /**
     *
     * @param {Object} ast
     * @param {Array} retArr
     * @return {String[]}
     */

  }, {
    key: "castValueToInteger",
    value: function castValueToInteger(ast, retArr) {
      this.pushState('casting-to-integer');
      retArr.push('int(');
      this.astGeneric(ast, retArr);
      retArr.push(')');
      this.popState('casting-to-integer');
      return retArr;
    }
    /**
     *
     * @param {Object} ast
     * @param {Array} retArr
     * @return {String[]}
     */

  }, {
    key: "castValueToFloat",
    value: function castValueToFloat(ast, retArr) {
      this.pushState('casting-to-float');
      retArr.push('float(');
      this.astGeneric(ast, retArr);
      retArr.push(')');
      this.popState('casting-to-float');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *identifier* expression
     * @param {Object} idtNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astIdentifierExpression",
    value: function astIdentifierExpression(idtNode, retArr) {
      if (idtNode.type !== 'Identifier') {
        throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
      }

      var type = this.getType(idtNode);

      if (idtNode.name === 'Infinity') {
        // https://stackoverflow.com/a/47543127/1324039
        retArr.push('3.402823466e+38');
      } else if (type === 'Boolean') {
        if (this.argumentNames.indexOf(idtNode.name) > -1) {
          retArr.push("bool(user_".concat(idtNode.name, ")"));
        } else {
          retArr.push("user_".concat(idtNode.name));
        }
      } else {
        var userArgumentName = this.getKernelArgumentName(idtNode.name);

        if (userArgumentName) {
          retArr.push("user_".concat(userArgumentName));
        } else {
          retArr.push("user_".concat(idtNode.name));
        }
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *for-loop* expression
     * @param {Object} forNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed webgl string
     */

  }, {
    key: "astForStatement",
    value: function astForStatement(forNode, retArr) {
      if (forNode.type !== 'ForStatement') {
        throw this.astErrorOutput('Invalid for statement', forNode);
      }

      var initArr = [];
      var testArr = [];
      var updateArr = [];
      var bodyArr = [];
      var isSafe = null;

      if (forNode.init) {
        this.pushState('in-for-loop-init');
        this.astGeneric(forNode.init, initArr);

        for (var i = 0; i < initArr.length; i++) {
          if (initArr[i].includes && initArr[i].includes(',')) {
            isSafe = false;
          }
        }

        this.popState('in-for-loop-init');
      } else {
        isSafe = false;
      }

      if (forNode.test) {
        this.pushState('in-for-loop-test');
        this.astGeneric(forNode.test, testArr);
        this.popState('in-for-loop-test');
      } else {
        isSafe = false;
      }

      if (forNode.update) {
        this.astGeneric(forNode.update, updateArr);
      } else {
        isSafe = false;
      }

      if (forNode.body) {
        this.pushState('loop-body');
        this.astGeneric(forNode.body, bodyArr);
        this.popState('loop-body');
      } // have all parts, now make them safe


      if (isSafe === null) {
        isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
      }

      if (isSafe) {
        retArr.push("for (".concat(initArr.join(''), ";").concat(testArr.join(''), ";").concat(updateArr.join(''), "){\n"));
        retArr.push(bodyArr.join(''));
        retArr.push('}\n');
      } else {
        var iVariableName = this.getInternalVariableName('safeI');

        if (initArr.length > 0) {
          retArr.push(initArr.join(''), ';\n');
        }

        retArr.push("for (int ".concat(iVariableName, "=0;").concat(iVariableName, "<LOOP_MAX;").concat(iVariableName, "++){\n"));

        if (testArr.length > 0) {
          retArr.push("if (!".concat(testArr.join(''), ") break;\n"));
        }

        retArr.push(bodyArr.join(''));
        retArr.push("\n".concat(updateArr.join(''), ";"));
        retArr.push('}\n');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *while* loop
     * @param {Object} whileNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed webgl string
     */

  }, {
    key: "astWhileStatement",
    value: function astWhileStatement(whileNode, retArr) {
      if (whileNode.type !== 'WhileStatement') {
        throw this.astErrorOutput('Invalid while statement', whileNode);
      }

      var iVariableName = this.getInternalVariableName('safeI');
      retArr.push("for (int ".concat(iVariableName, "=0;").concat(iVariableName, "<LOOP_MAX;").concat(iVariableName, "++){\n"));
      retArr.push('if (!');
      this.astGeneric(whileNode.test, retArr);
      retArr.push(') break;\n');
      this.astGeneric(whileNode.body, retArr);
      retArr.push('}\n');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *do while* loop
     * @param {Object} doWhileNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the parsed webgl string
     */

  }, {
    key: "astDoWhileStatement",
    value: function astDoWhileStatement(doWhileNode, retArr) {
      if (doWhileNode.type !== 'DoWhileStatement') {
        throw this.astErrorOutput('Invalid while statement', doWhileNode);
      }

      var iVariableName = this.getInternalVariableName('safeI');
      retArr.push("for (int ".concat(iVariableName, "=0;").concat(iVariableName, "<LOOP_MAX;").concat(iVariableName, "++){\n"));
      this.astGeneric(doWhileNode.body, retArr);
      retArr.push('if (!');
      this.astGeneric(doWhileNode.test, retArr);
      retArr.push(') break;\n');
      retArr.push('}\n');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Assignment* Expression
     * @param {Object} assNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astAssignmentExpression",
    value: function astAssignmentExpression(assNode, retArr) {
      var declaration = this.getDeclaration(assNode.left);

      if (declaration && !declaration.assignable) {
        throw new this.astErrorOutput("Variable ".concat(assNode.left.name, " is not assignable here"), assNode);
      } // TODO: casting needs implemented here


      if (assNode.operator === '%=') {
        this.astGeneric(assNode.left, retArr);
        retArr.push('=');
        retArr.push('mod(');
        this.astGeneric(assNode.left, retArr);
        retArr.push(',');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else if (assNode.operator === '**=') {
        this.astGeneric(assNode.left, retArr);
        retArr.push('=');
        retArr.push('pow(');
        this.astGeneric(assNode.left, retArr);
        retArr.push(',');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        var leftType = this.getType(assNode.left);
        var rightType = this.getType(assNode.right);
        this.astGeneric(assNode.left, retArr);
        retArr.push(assNode.operator);

        if (leftType !== 'Integer' && rightType === 'Integer') {
          retArr.push('float(');
          this.astGeneric(assNode.right, retArr);
          retArr.push(')');
        } else {
          this.astGeneric(assNode.right, retArr);
        }

        return retArr;
      }
    }
    /**
     * @desc Parses the abstract syntax tree for *Block* statement
     * @param {Object} bNode - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astBlockStatement",
    value: function astBlockStatement(bNode, retArr) {
      if (this.isState('loop-body')) {
        this.pushState('block-body'); // this prevents recursive removal of braces

        for (var i = 0; i < bNode.body.length; i++) {
          this.astGeneric(bNode.body[i], retArr);
        }

        this.popState('block-body');
      } else {
        retArr.push('{\n');

        for (var _i2 = 0; _i2 < bNode.body.length; _i2++) {
          this.astGeneric(bNode.body[_i2], retArr);
        }

        retArr.push('}\n');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Variable Declaration*
     * @param {Object} varDecNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astVariableDeclaration",
    value: function astVariableDeclaration(varDecNode, retArr) {
      if (varDecNode.kind === 'var') {
        this.varWarn();
      }

      var declarations = varDecNode.declarations;

      if (!declarations || !declarations[0] || !declarations[0].init) {
        throw this.astErrorOutput('Unexpected expression', varDecNode);
      }

      var result = [];
      var lastType = null;
      var inForLoopInit = this.isState('in-for-loop-init');

      for (var i = 0; i < declarations.length; i++) {
        var declaration = declarations[i];
        var init = declaration.init;
        var info = this.getDeclaration(declaration.id);
        var valueType = info.valueType;
        var actualType = this.getType(declaration.init);
        var dependencies = info.dependencies;
        var type = inForLoopInit ? 'Integer' : actualType;

        if (type === 'LiteralInteger') {
          // We had the choice to go either float or int, choosing float
          type = 'Number';
        }

        var markupType = typeMap[type];

        if (!markupType) {
          throw this.astErrorOutput("Markup type ".concat(markupType, " not handled"), varDecNode);
        }

        var declarationResult = [];

        if (actualType === 'Integer' && type === 'Integer' && !inForLoopInit) {
          // Since we are assigning to a float, ensure valueType is reset to that
          info.valueType = 'Number';

          if (i === 0 || lastType === null) {
            declarationResult.push('float ');
          } else if (type !== lastType) {
            throw new Error('Unhandled declaration');
          } else {
            declarationResult.push(',');
          }

          lastType = type;
          declarationResult.push("user_".concat(declaration.id.name, "="));
          declarationResult.push('float(');
          this.astGeneric(init, declarationResult);
          declarationResult.push(')');
        } else {
          // Since we are assigning to a float, ensure valueType is reset to that
          info.valueType = type;

          if (i === 0 || lastType === null) {
            declarationResult.push("".concat(markupType, " "));
          } else if (type !== lastType) {
            result.push(';');
            declarationResult.push("".concat(markupType, " "));
          } else {
            declarationResult.push(',');
          }

          lastType = type;
          declarationResult.push("user_".concat(declaration.id.name, "="));

          if (actualType === 'Number' && type === 'Integer') {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          } else {
            this.astGeneric(init, declarationResult);
          }
        }

        result.push(declarationResult.join(''));
      }

      retArr.push(result.join(''));

      if (!inForLoopInit) {
        retArr.push(';');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *If* Statement
     * @param {Object} ifNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astIfStatement",
    value: function astIfStatement(ifNode, retArr) {
      retArr.push('if (');
      this.astGeneric(ifNode.test, retArr);
      retArr.push(')');

      if (ifNode.consequent.type === 'BlockStatement') {
        this.astGeneric(ifNode.consequent, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.consequent, retArr);
        retArr.push('\n}\n');
      }

      if (ifNode.alternate) {
        retArr.push('else ');

        if (ifNode.alternate.type === 'BlockStatement') {
          this.astGeneric(ifNode.alternate, retArr);
        } else {
          retArr.push(' {\n');
          this.astGeneric(ifNode.alternate, retArr);
          retArr.push('\n}\n');
        }
      }

      return retArr;
    }
  }, {
    key: "astSwitchStatement",
    value: function astSwitchStatement(ast, retArr) {
      if (ast.type !== 'SwitchStatement') {
        throw this.astErrorOutput('Invalid switch statement', ast);
      }

      var discriminant = ast.discriminant,
          cases = ast.cases;
      var type = this.getType(discriminant);
      var varName = "switchDiscriminant".concat(ast.start, "_").concat(ast.end);

      switch (type) {
        case 'Float':
        case 'Number':
          retArr.push("float ".concat(varName, " = "));
          this.astGeneric(discriminant, retArr);
          retArr.push(';\n');
          break;

        case 'Integer':
          retArr.push("int ".concat(varName, " = "));
          this.astGeneric(discriminant, retArr);
          retArr.push(';\n');
          break;
      } // switch with just a default:


      if (cases.length === 1 && !cases[0].test) {
        this.astGeneric(cases[0].consequent, retArr);
        return retArr;
      } // regular switches:


      var fallingThrough = false;
      var defaultResult = [];
      var movingDefaultToEnd = false;
      var pastFirstIf = false;

      for (var i = 0; i < cases.length; i++) {
        // default
        if (!cases[i].test) {
          if (cases.length > i + 1) {
            movingDefaultToEnd = true;
            this.astGeneric(cases[i].consequent, defaultResult);
            continue;
          } else {
            retArr.push(' else {\n');
          }
        } else {
          // all others
          if (i === 0 || !pastFirstIf) {
            pastFirstIf = true;
            retArr.push("if (".concat(varName, " == "));
          } else {
            if (fallingThrough) {
              retArr.push("".concat(varName, " == "));
              fallingThrough = false;
            } else {
              retArr.push(" else if (".concat(varName, " == "));
            }
          }

          if (type === 'Integer') {
            var testType = this.getType(cases[i].test);

            switch (testType) {
              case 'Number':
              case 'Float':
                this.castValueToInteger(cases[i].test, retArr);
                break;

              case 'LiteralInteger':
                this.castLiteralToInteger(cases[i].test, retArr);
                break;
            }
          } else if (type === 'Float') {
            var _testType = this.getType(cases[i].test);

            switch (_testType) {
              case 'LiteralInteger':
                this.castLiteralToFloat(cases[i].test, retArr);
                break;

              case 'Integer':
                this.castValueToFloat(cases[i].test, retArr);
                break;
            }
          } else {
            throw new Error('unhanlded');
          }

          if (!cases[i].consequent || cases[i].consequent.length === 0) {
            fallingThrough = true;
            retArr.push(' || ');
            continue;
          }

          retArr.push(") {\n");
        }

        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('\n}');
      }

      if (movingDefaultToEnd) {
        retArr.push(' else {');
        retArr.push(defaultResult.join(''));
        retArr.push('}');
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *This* expression
     * @param {Object} tNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astThisExpression",
    value: function astThisExpression(tNode, retArr) {
      retArr.push('this');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Member* Expression
     * @param {Object} mNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astMemberExpression",
    value: function astMemberExpression(mNode, retArr) {
      var _this$getMemberExpres = this.getMemberExpressionDetails(mNode),
          property = _this$getMemberExpres.property,
          name = _this$getMemberExpres.name,
          signature = _this$getMemberExpres.signature,
          origin = _this$getMemberExpres.origin,
          type = _this$getMemberExpres.type,
          xProperty = _this$getMemberExpres.xProperty,
          yProperty = _this$getMemberExpres.yProperty,
          zProperty = _this$getMemberExpres.zProperty;

      switch (signature) {
        case 'value.thread.value':
        case 'this.thread.value':
          if (name !== 'x' && name !== 'y' && name !== 'z') {
            throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
          }

          retArr.push("threadId.".concat(name));
          return retArr;

        case 'this.output.value':
          if (this.dynamicOutput) {
            switch (name) {
              case 'x':
                if (this.isState('casting-to-float')) {
                  retArr.push('float(uOutputDim.x)');
                } else {
                  retArr.push('uOutputDim.x');
                }

                break;

              case 'y':
                if (this.isState('casting-to-float')) {
                  retArr.push('float(uOutputDim.y)');
                } else {
                  retArr.push('uOutputDim.y');
                }

                break;

              case 'z':
                if (this.isState('casting-to-float')) {
                  retArr.push('float(uOutputDim.z)');
                } else {
                  retArr.push('uOutputDim.z');
                }

                break;

              default:
                throw this.astErrorOutput('Unexpected expression', mNode);
            }
          } else {
            switch (name) {
              case 'x':
                if (this.isState('casting-to-integer')) {
                  retArr.push(this.output[0]);
                } else {
                  retArr.push(this.output[0], '.0');
                }

                break;

              case 'y':
                if (this.isState('casting-to-integer')) {
                  retArr.push(this.output[1]);
                } else {
                  retArr.push(this.output[1], '.0');
                }

                break;

              case 'z':
                if (this.isState('casting-to-integer')) {
                  retArr.push(this.output[2]);
                } else {
                  retArr.push(this.output[2], '.0');
                }

                break;

              default:
                throw this.astErrorOutput('Unexpected expression', mNode);
            }
          }

          return retArr;

        case 'value':
          throw this.astErrorOutput('Unexpected expression', mNode);

        case 'value[]':
        case 'value[][]':
        case 'value[][][]':
        case 'value[][][][]':
        case 'value.value':
          if (origin === 'Math') {
            retArr.push(Math[name]);
            return retArr;
          }

          switch (property) {
            case 'r':
              retArr.push("user_".concat(name, ".r"));
              return retArr;

            case 'g':
              retArr.push("user_".concat(name, ".g"));
              return retArr;

            case 'b':
              retArr.push("user_".concat(name, ".b"));
              return retArr;

            case 'a':
              retArr.push("user_".concat(name, ".a"));
              return retArr;
          }

          break;

        case 'this.constants.value':
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;

        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;

        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;

        default:
          throw this.astErrorOutput('Unexpected expression', mNode);
      }

      if (mNode.computed === false) {
        // handle simple types
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'Boolean':
            retArr.push("".concat(origin, "_").concat(name));
            return retArr;
        }
      } // handle more complex types
      // argument may have come from a parent


      var synonymName = this.getKernelArgumentName(name);
      var markupName = "".concat(origin, "_").concat(synonymName || name);

      switch (type) {
        case 'Array(2)':
        case 'Array(3)':
        case 'Array(4)':
          // Get from local vec4
          this.astGeneric(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(xProperty));
          retArr.push(']');
          break;

        case 'HTMLImageArray':
          retArr.push("getImage3D(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        case 'ArrayTexture(1)':
          retArr.push("getFloatFromSampler2D(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        case 'ArrayTexture(2)':
          retArr.push("getVec2FromSampler2D(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        case 'ArrayTexture(3)':
          retArr.push("getVec3FromSampler2D(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        case 'ArrayTexture(4)':
        case 'HTMLImage':
          retArr.push("getVec4FromSampler2D(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        case 'NumberTexture':
        case 'Array':
        case 'Array2D':
        case 'Array3D':
        case 'Array4D':
        case 'Input':
        case 'Number':
        case 'Float':
        case 'Integer':
          if (this.precision === 'single') {
            // bitRatio is always 4 here, javascript doesn't yet have 8 or 16 bit support
            // TODO: make 8 or 16 bit work anyway!
            retArr.push("getMemoryOptimized32(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
          } else {
            var bitRatio = origin === 'user' ? this.lookupFunctionArgumentBitRatio(this.name, name) : this.constantBitRatios[name];

            switch (bitRatio) {
              case 1:
                retArr.push("get8(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
                break;

              case 2:
                retArr.push("get16(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
                break;

              case 4:
              case 0:
                retArr.push("get32(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
                break;

              default:
                throw new Error("unhandled bit ratio of ".concat(bitRatio));
            }

            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
          }

          break;

        case 'MemoryOptimizedNumberTexture':
          retArr.push("getMemoryOptimized32(".concat(markupName, ", ").concat(markupName, "Size, ").concat(markupName, "Dim, "));
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
          break;

        default:
          throw new Error("unhandled member expression \"".concat(type, "\""));
      }

      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *call* expression
     * @param {Object} ast - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns  {Array} the append retArr
     */

  }, {
    key: "astCallExpression",
    value: function astCallExpression(ast, retArr) {
      if (!ast.callee) {
        throw this.astErrorOutput('Unknown CallExpression', ast);
      }

      var functionName = null;
      var isMathFunction = this.isAstMathFunction(ast); // Its a math operator or this.something(), remove the prefix

      if (isMathFunction || ast.callee.object && ast.callee.object.type === 'ThisExpression') {
        functionName = ast.callee.property.name;
      } // Issue #212, BABEL!
      else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
          functionName = ast.callee.expressions[1].property.name;
        } else {
          functionName = ast.callee.name;
        }

      if (!functionName) {
        throw this.astErrorOutput("Unhandled function, couldn't find name", ast);
      } // if this if grows to more than one, lets use a switch


      if (functionName === 'atan2') {
        functionName = 'atan';
      } // Register the function into the called registry


      if (this.calledFunctions.indexOf(functionName) < 0) {
        this.calledFunctions.push(functionName);
      }

      if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
        for (var i = 0; i < this.plugins.length; i++) {
          var plugin = this.plugins[i];

          if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
            retArr.push(plugin.functionReplace);
            return retArr;
          }
        }
      } // track the function was called


      if (this.onFunctionCall) {
        this.onFunctionCall(this.name, functionName, ast.arguments);
      } // Call the function


      retArr.push(functionName); // Open arguments space

      retArr.push('('); // Add the arguments

      if (isMathFunction) {
        for (var _i3 = 0; _i3 < ast.arguments.length; ++_i3) {
          var argument = ast.arguments[_i3];
          var argumentType = this.getType(argument);

          if (_i3 > 0) {
            retArr.push(', ');
          }

          switch (argumentType) {
            case 'Integer':
              this.castValueToFloat(argument, retArr);
              break;

            default:
              this.astGeneric(argument, retArr);
              break;
          }
        }
      } else {
        var targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];

        for (var _i4 = 0; _i4 < ast.arguments.length; ++_i4) {
          var _argument = ast.arguments[_i4];
          var targetType = targetTypes[_i4];

          if (_i4 > 0) {
            retArr.push(', ');
          }

          var _argumentType = this.getType(_argument);

          if (!targetType) {
            this.triggerImplyArgumentType(functionName, _i4, _argumentType, this);
            targetType = _argumentType;
          }

          switch (_argumentType) {
            case 'Number':
            case 'Float':
              if (targetType === 'Integer') {
                retArr.push('int(');
                this.astGeneric(_argument, retArr);
                retArr.push(')');
                continue;
              } else if (targetType === 'Number' || targetType === 'Float') {
                this.astGeneric(_argument, retArr);
                continue;
              } else if (targetType === 'LiteralInteger') {
                this.castLiteralToFloat(_argument, retArr);
                continue;
              }

              break;

            case 'Integer':
              if (targetType === 'Number' || targetType === 'Float') {
                retArr.push('float(');
                this.astGeneric(_argument, retArr);
                retArr.push(')');
                continue;
              } else if (targetType === 'Integer') {
                this.astGeneric(_argument, retArr);
                continue;
              }

              break;

            case 'LiteralInteger':
              if (targetType === 'Integer') {
                this.castLiteralToInteger(_argument, retArr);
                continue;
              } else if (targetType === 'Number' || targetType === 'Float') {
                this.castLiteralToFloat(_argument, retArr);
                continue;
              } else if (targetType === 'LiteralInteger') {
                this.astGeneric(_argument, retArr);
                continue;
              }

              break;

            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              if (targetType === _argumentType) {
                this.astGeneric(_argument, retArr);
                continue;
              }

              break;

            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
            case 'Array':
            case 'Input':
              if (targetType === _argumentType) {
                this.triggerTrackArgumentSynonym(this.name, _argument.name, functionName, _i4);
                this.astGeneric(_argument, retArr);
                continue;
              }

              break;
          }

          throw this.astErrorOutput("Unhandled argument combination of ".concat(_argumentType, " and ").concat(targetType, " for argument named \"").concat(_argument.name, "\""), ast);
        }
      } // Close arguments space


      retArr.push(')');
      return retArr;
    }
    /**
     * @desc Parses the abstract syntax tree for *Array* Expression
     * @param {Object} arrNode - the AST object to parse
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */

  }, {
    key: "astArrayExpression",
    value: function astArrayExpression(arrNode, retArr) {
      var arrLen = arrNode.elements.length;
      retArr.push('vec' + arrLen + '(');

      for (var i = 0; i < arrLen; ++i) {
        if (i > 0) {
          retArr.push(', ');
        }

        var subNode = arrNode.elements[i];
        this.astGeneric(subNode, retArr);
      }

      retArr.push(')');
      return retArr;
    }
  }, {
    key: "memberExpressionXYZ",
    value: function memberExpressionXYZ(x, y, z, retArr) {
      if (z) {
        retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
      } else {
        retArr.push('0, ');
      }

      if (y) {
        retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
      } else {
        retArr.push('0, ');
      }

      retArr.push(this.memberExpressionPropertyMarkup(x));
      return retArr;
    }
  }, {
    key: "memberExpressionPropertyMarkup",
    value: function memberExpressionPropertyMarkup(property) {
      if (!property) {
        throw new Error('Property not set');
      }

      var type = this.getType(property);
      var result = [];

      switch (type) {
        case 'Number':
        case 'Float':
          this.castValueToInteger(property, result);
          break;

        case 'LiteralInteger':
          this.castLiteralToInteger(property, result);
          break;

        default:
          this.astGeneric(property, result);
      }

      return result.join('');
    }
  }]);

  return WebGLFunctionNode;
}(FunctionNode);

var typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D'
};
var operatorMap = {
  '===': '==',
  '!==': '!='
};
module.exports = {
  WebGLFunctionNode: WebGLFunctionNode
};
},{"../../utils":"9h1E","../function-node":"oNAw"}],"DqSa":[function(require,module,exports) {
var source = "\n\nuniform highp float triangle_noise_seed;\nhighp float triangle_noise_shift = 0.000001;\n\n//https://www.shadertoy.com/view/4t2SDh\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n  return clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\nfloat n4rand( vec2 n )\n{\n  float t = fract( triangle_noise_seed + triangle_noise_shift );\n  float nrnd0 = nrand( n + 0.07*t );\n  float nrnd1 = nrand( n + 0.11*t );  \n  float nrnd2 = nrand( n + 0.13*t );\n  float nrnd3 = nrand( n + 0.17*t );\n  float result = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n  triangle_noise_shift = result + 0.000001;\n  return result;\n}";
var name = 'triangle-noise-noise';
var functionMatch = 'Math.random()';
var functionReplace = 'n4rand(vTexCoord)';
var functionReturnType = 'Number';

var onBeforeRun = function onBeforeRun(kernel) {
  kernel.setUniform1f('triangle_noise_seed', Math.random());
};
/**
 *
 * @type IPlugin
 */


module.exports = {
  name: name,
  onBeforeRun: onBeforeRun,
  functionMatch: functionMatch,
  functionReplace: functionReplace,
  functionReturnType: functionReturnType,
  source: source
};
},{}],"+HoT":[function(require,module,exports) {
var fragmentShader = "__HEADER__;\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst int LOOP_MAX = __LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nvarying vec2 vTexCoord;\n\nvec4 round(vec4 x) {\n  return floor(x + 0.5);\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n\nconst int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - y * (x / y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  int n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n      result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  }\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x / y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) {\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int index) {\n  int channel = integerMod(index, 2);\n  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;\n  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;\n  return 0.0;\n}\n\nfloat decode8(vec4 texel, int index) {\n  int channel = integerMod(index, 4);\n  if (channel == 0) return texel.r * 255.0;\n  if (channel == 1) return texel.g * 255.0;\n  if (channel == 2) return texel.b * 255.0;\n  if (channel == 3) return texel.a * 255.0;\n  return 0.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  texel.rg = integerMod(texel.rg, 256.0);\n  texel.b = integerMod(texel.b, 128.0);\n  texel.a = exponent*0.5 + 63.5;\n  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  texel = floor(texel);\n  texel *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return texel;\n}\n\n// https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n  float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, -value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  result.b = result.b + exponent*128.0;\n\n  result.g = floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x * 2;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\n  return decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int channel = integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  if (channel == 0) return texel.r;\n  if (channel == 1) return texel.g;\n  if (channel == 2) return texel.b;\n  if (channel == 3) return texel.a;\n  return 0.0;\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture2D(tex, st / vec2(texSize));\n}\n\nfloat getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], result[1]);\n}\n\nvec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec3(result[0], result[1], result[2]);\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, y, x);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\nvoid color(sampler2D image) {\n  actualColor = texture2D(image, vTexCoord);\n}\n\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}";
module.exports = {
  fragmentShader: fragmentShader
};
},{}],"gebY":[function(require,module,exports) {
var vertexShader = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nattribute vec2 aPos;\nattribute vec2 aTexCoord;\n\nvarying vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}";
module.exports = {
  vertexShader: vertexShader
};
},{}],"1vBd":[function(require,module,exports) {
/**
 *
 * @param {WebGLRenderingContext} gl
 * @param {IGLWiretapOptions} [options]
 * @returns {GLWiretapProxy}
 */
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { // need arguments from this, fyi
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); // flush out errors
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

/**
 *
 * @param extension
 * @param {IGLExtensionWiretapOptions} options
 * @returns {*}
 */
function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}(${Array.from(arg).join(',')})`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  // wrapped in object, so track-able
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],"n+CM":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('gl-wiretap'),
    glWiretap = _require.glWiretap;

var _require2 = require('../../utils'),
    utils = _require2.utils;

function toStringWithoutUtils(fn) {
  return fn.toString().replace('=>', '').replace(/^function /, '').replace(/utils[.]/g, '/*utils.*/');
}
/**
 *
 * @param {Kernel} Kernel
 * @param {KernelVariable[]} args
 * @param {Kernel} originKernel
 * @param {string} [setupContextString]
 * @param {string} [destroyContextString]
 * @returns {string}
 */


function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  var postResult = [];
  var context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: function onReadPixels(targetName) {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push("    const result = { result: ".concat(getRenderString(targetName, kernel), " };"));
          subKernelsResultVariableSetup = true;
        } else {
          var property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push("    result".concat(isNaN(property) ? '.' + property : "[".concat(property, "]"), " = ").concat(getRenderString(targetName, kernel), ";"));
        }

        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }

        return;
      }

      if (targetName) {
        postResult.push("    return ".concat(getRenderString(targetName, kernel), ";"));
      } else {
        postResult.push("    return null;");
      }
    },
    onUnrecognizedArgumentLookup: function onUnrecognizedArgumentLookup(argument) {
      for (var i = 0; i < kernel.kernelConstants.length; i++) {
        var value = kernel.kernelConstants[i];

        if (value.type === 'HTMLImageArray') {
          var constant = kernel.constants[value.name];
          var variable = "uploadValue_".concat(value.name, "[").concat(constant.indexOf(value.uploadValue), "]");
          context.insertVariable(variable, kernel.constants);
          return variable;
        } else if (value.uploadValue === argument) {
          var _variable = "uploadValue_".concat(value.name);

          context.insertVariable(_variable, value);
          return _variable;
        }
      }
    }
  });
  var subKernelsResultVariableSetup = false;
  var subKernelsResultIndex = 0;
  var source = originKernel.source,
      canvas = originKernel.canvas,
      output = originKernel.output,
      pipeline = originKernel.pipeline,
      graphical = originKernel.graphical,
      loopMaxIterations = originKernel.loopMaxIterations,
      constants = originKernel.constants,
      optimizeFloatMemory = originKernel.optimizeFloatMemory,
      precision = originKernel.precision,
      fixIntegerDivisionAccuracy = originKernel.fixIntegerDivisionAccuracy,
      functions = originKernel.functions,
      nativeFunctions = originKernel.nativeFunctions,
      subKernels = originKernel.subKernels,
      immutable = originKernel.immutable,
      kernelArguments = originKernel.kernelArguments,
      kernelConstants = originKernel.kernelConstants;
  var kernel = new Kernel(source, {
    canvas: canvas,
    context: context,
    checkContext: false,
    output: output,
    pipeline: pipeline,
    graphical: graphical,
    loopMaxIterations: loopMaxIterations,
    constants: constants,
    optimizeFloatMemory: optimizeFloatMemory,
    precision: precision,
    fixIntegerDivisionAccuracy: fixIntegerDivisionAccuracy,
    functions: functions,
    nativeFunctions: nativeFunctions,
    subKernels: subKernels,
    immutable: immutable
  });
  var result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();
  var upgradedArguments = Array.from(args).map(function (arg) {
    switch (_typeof(arg)) {
      case 'number':
      case 'boolean':
        return new arg.constructor(arg);
    }

    return arg;
  });
  kernel.kernelArguments.forEach(function (kernelArgument, i) {
    switch (kernelArgument.type) {
      // primitives
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
        context.insertVariable("uploadValue_".concat(kernelArgument.name), upgradedArguments[i]);
        break;
      // non-primitives

      case 'Array':
        context.insertVariable("uploadValue_".concat(kernelArgument.name), upgradedArguments[i]);
        break;

      case 'HTMLImage':
        context.insertVariable("uploadValue_".concat(kernelArgument.name), upgradedArguments[i]);
        break;

      case 'HTMLImageArray':
        for (var imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          var arg = args[i];
          context.insertVariable("uploadValue_".concat(kernelArgument.name, "[").concat(imageIndex, "]"), arg[imageIndex]);
        }

        break;

      case 'Input':
        context.insertVariable("uploadValue_".concat(kernelArgument.name), kernelArgument.uploadValue);
        break;

      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable("uploadValue_".concat(kernelArgument.name), upgradedArguments[i].texture);
        break;

      default:
        throw new Error("unhandled kernelArgumentType insertion for glWiretap of type ".concat(kernelArgument.type));
    }
  });
  result.push('/** start of injected functions **/');
  result.push("function ".concat(toStringWithoutUtils(utils.flattenTo)));
  result.push("function ".concat(toStringWithoutUtils(utils.flatten2dArrayTo)));
  result.push("function ".concat(toStringWithoutUtils(utils.flatten3dArrayTo)));
  result.push("function ".concat(toStringWithoutUtils(utils.isArray)));

  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push("  const renderOutput = function ".concat(toStringWithoutUtils(kernel.formatValues), ";"));
  }

  result.push('/** end of injected functions **/');
  result.push("  const innerKernel = function (".concat(kernel.kernelArguments.map(function (kernelArgument) {
    return kernelArgument.varName;
  }).join(', '), ") {"));
  context.setIndent(4);
  kernel.run.apply(kernel, upgradedArguments);

  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }

  result.push('/** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(function (kernelArgument) {
    result.push(kernelArgument.getStringValueHandler());
  });
  result.push('/** end setup uploads for kernel values **/');
  result.push(context.toString());

  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    var results = kernel.renderKernels();
    var textureName = context.getContextVariableName(kernel.outputTexture);
    result.push("    return {\n      result: {\n        texture: ".concat(textureName, ",\n        type: '").concat(results.result.type, "',\n        toArray: ").concat(getToArrayString(results.result, textureName), "\n      },"));
    var _subKernels = kernel.subKernels,
        subKernelOutputTextures = kernel.subKernelOutputTextures;

    for (var i = 0; i < _subKernels.length; i++) {
      var texture = subKernelOutputTextures[i];
      var subKernel = _subKernels[i];
      var subKernelResult = results[subKernel.property];
      var subKernelTextureName = context.getContextVariableName(texture);
      result.push("\n      ".concat(subKernel.property, ": {\n        texture: ").concat(subKernelTextureName, ",\n        type: '").concat(subKernelResult.type, "',\n        toArray: ").concat(getToArrayString(subKernelResult, subKernelTextureName), "\n      },"));
    }

    result.push("    };");
  }

  result.push("    ".concat(destroyContextString ? '\n' + destroyContextString + '    ' : ''));
  result.push(postResult.join('\n'));
  result.push('  };');

  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push("innerKernel.getPixels = getPixels;");
  }

  result.push('  return innerKernel;');
  var constantsUpload = [];
  kernelConstants.forEach(function (kernelConstant) {
    constantsUpload.push("".concat(kernelConstant.getStringValueHandler()));
  });
  return "function kernel(settings) {\n  const { context, constants } = settings;\n  ".concat(constantsUpload.join(''), "\n  ").concat(setupContextString ? setupContextString : '', "\n").concat(result.join('\n'), "\n}");
}

function getRenderString(targetName, kernel) {
  var readBackValue = kernel.precision === 'single' ? targetName : "new Float32Array(".concat(targetName, ".buffer)");

  if (kernel.output[2]) {
    return "renderOutput(".concat(readBackValue, ", ").concat(kernel.output[0], ", ").concat(kernel.output[1], ", ").concat(kernel.output[2], ")");
  }

  if (kernel.output[1]) {
    return "renderOutput(".concat(readBackValue, ", ").concat(kernel.output[0], ", ").concat(kernel.output[1], ")");
  }

  return "renderOutput(".concat(readBackValue, ", ").concat(kernel.output[0], ")");
}

function getGetPixelsString(kernel) {
  var getPixels = kernel.getPixels.toString();
  var useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString("".concat(useFunctionKeyword ? 'function ' : '').concat(getPixels), {
    findDependency: function findDependency(object, name) {
      if (object === 'utils') {
        return "const ".concat(name, " = ").concat(utils[name].toString(), ";");
      }

      return null;
    },
    thisLookup: function thisLookup(property) {
      if (property === 'context') {
        return null;
      }

      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }

      throw new Error("unhandled thisLookup ".concat(property));
    }
  });
}

function getToArrayString(kernelResult, textureName) {
  var toArray = kernelResult.toArray.toString();
  var useFunctionKeyword = !/^function/.test(toArray);
  var flattenedFunctions = utils.flattenFunctionToString("".concat(useFunctionKeyword ? 'function ' : '').concat(toArray), {
    findDependency: function findDependency(object, name) {
      if (object === 'utils') {
        return "const ".concat(name, " = ").concat(utils[name].toString(), ";");
      } else if (object === 'this') {
        return "".concat(useFunctionKeyword ? 'function ' : '').concat(kernelResult[name].toString());
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: function thisLookup(property) {
      if (property === 'texture') {
        return textureName;
      }

      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }

      throw new Error("unhandled thisLookup ".concat(property));
    }
  });
  return "() => {\n  ".concat(flattenedFunctions, "\n  return toArray();\n  }");
}

module.exports = {
  glKernelString: glKernelString
};
},{"gl-wiretap":"1vBd","../../utils":"9h1E"}],"jqVX":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('../utils'),
    utils = _require.utils;
/**
 * @class KernelValue
 */


var KernelValue =
/*#__PURE__*/
function () {
  /**
   *
   * @param {IKernelArgumentSettings} settings
   */
  function KernelValue(value, settings) {
    _classCallCheck(this, KernelValue);

    var name = settings.name,
        kernel = settings.kernel,
        context = settings.context,
        checkContext = settings.checkContext,
        onRequestContextHandle = settings.onRequestContextHandle,
        onUpdateValueMismatch = settings.onUpdateValueMismatch,
        origin = settings.origin,
        strictIntegers = settings.strictIntegers;

    if (!name) {
      throw new Error('name not set');
    }

    if (!origin) {
      throw new Error('origin not set');
    }

    if (origin !== 'user' && origin !== 'constants') {
      throw new Error("origin must be \"user\" or \"constants\" value is \"".concat(origin, "\""));
    }

    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }

    this.name = name;
    this.origin = origin;
    this.id = "".concat(this.origin, "_").concat(name);
    this.varName = origin === 'constants' ? "constants.".concat(name) : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = utils.getVariableType(value, strictIntegers);
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
  }

  _createClass(KernelValue, [{
    key: "getSource",
    value: function getSource() {
      throw new Error("\"getSource\" not defined on ".concat(this.constructor.name));
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      throw new Error("\"updateValue\" not defined on ".concat(this.constructor.name));
    }
  }]);

  return KernelValue;
}();

module.exports = {
  KernelValue: KernelValue
};
},{"../utils":"9h1E"}],"JG6C":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../../input'),
    Input = _require2.Input;

var _require3 = require('../../kernel-value'),
    KernelValue = _require3.KernelValue;

var WebGLKernelValue =
/*#__PURE__*/
function (_KernelValue) {
  _inherits(WebGLKernelValue, _KernelValue);

  /**
   *
   * @param {IWebGLKernerlValueSettings} settings
   */
  function WebGLKernelValue(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValue);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValue).call(this, value, settings));
    _this.dimensionsId = null;
    _this.sizeId = null;
    _this.initialValueConstructor = value.constructor;
    _this.onRequestTexture = settings.onRequestTexture;
    _this.onRequestIndex = settings.onRequestIndex;
    _this.uploadValue = null;
    _this.textureSize = null;
    _this.bitRatio = null;
    return _this;
  }

  _createClass(WebGLKernelValue, [{
    key: "requestTexture",
    value: function requestTexture() {
      this.texture = this.onRequestTexture();
      this.setupTexture();
    }
  }, {
    key: "setupTexture",
    value: function setupTexture() {
      this.contextHandle = this.onRequestContextHandle();
      this.index = this.onRequestIndex();
      this.dimensionsId = this.id + 'Dim';
      this.sizeId = this.id + 'Size';
    }
  }, {
    key: "getTransferArrayType",
    value: function getTransferArrayType(value) {
      if (Array.isArray(value[0])) {
        return this.getTransferArrayType(value[0]);
      }

      switch (value.constructor) {
        case Array:
        case Int32Array:
        case Int16Array:
        case Int8Array:
          return Float32Array;

        case Uint8ClampedArray:
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Float32Array:
        case Float64Array:
          return value.constructor;
      }

      console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
      return value.constructor;
    }
    /**
     * @desc Adds kernel parameters to the Value Texture,
     * binding it to the context, etc.
     *
     * @param {Array|Float32Array|Uint16Array} value - The actual Value supplied to the kernel
     * @param {Number} length - the expected total length of the output array
     * @param {Object} [Type]
     * @returns {Float32Array|Uint16Array|Uint8Array} flattened array to transfer
     */

  }, {
    key: "formatArrayTransfer",
    value: function formatArrayTransfer(value, length, Type) {
      if (utils.isArray(value[0]) || this.optimizeFloatMemory) {
        // not already flat
        var valuesFlat = new Float32Array(length);
        utils.flattenTo(value, valuesFlat);
        return valuesFlat;
      } else {
        switch (value.constructor) {
          case Uint8ClampedArray:
          case Uint8Array:
          case Int8Array:
          case Uint16Array:
          case Int16Array:
          case Float32Array:
          case Int32Array:
            {
              var _valuesFlat = new (Type || value.constructor)(length);

              utils.flattenTo(value, _valuesFlat);
              return _valuesFlat;
            }

          default:
            {
              var _valuesFlat2 = new Float32Array(length);

              utils.flattenTo(value, _valuesFlat2);
              return _valuesFlat2;
            }
        }
      }
    }
    /**
     * bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4
     * @param value
     * @returns {number}
     */

  }, {
    key: "getBitRatio",
    value: function getBitRatio(value) {
      if (Array.isArray(value[0])) {
        return this.getBitRatio(value[0]);
      } else if (value.constructor === Input) {
        return this.getBitRatio(value.value);
      }

      switch (value.constructor) {
        case Uint8ClampedArray:
        case Uint8Array:
        case Int8Array:
          return 1;

        case Uint16Array:
        case Int16Array:
          return 2;

        case Float32Array:
        case Int32Array:
        default:
          return 4;
      }
    }
    /**
     * Used for when we want a string output of our kernel, so we can still input values to the kernel
     */

  }, {
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      throw new Error("\"getStringValueHandler\" not implemented on ".concat(this.constructor.name));
    }
  }]);

  return WebGLKernelValue;
}(KernelValue);

module.exports = {
  WebGLKernelValue: WebGLKernelValue
};
},{"../../../utils":"9h1E","../../../input":"ryqg","../../kernel-value":"jqVX"}],"BLnS":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueBoolean =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueBoolean, _WebGLKernelValue);

  function WebGLKernelValueBoolean(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueBoolean);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueBoolean).call(this, value, settings));
    _this.uploadValue = value;
    return _this;
  }

  _createClass(WebGLKernelValueBoolean, [{
    key: "getSource",
    value: function getSource(value) {
      if (this.origin === 'constants') {
        return "const bool ".concat(this.id, " = ").concat(value, ";\n");
      }

      return "uniform bool ".concat(this.id, ";\n");
    }
  }, {
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ";\n");
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (this.origin === 'constants') return;
      this.kernel.setUniform1i(this.id, this.uploadValue = value);
    }
  }]);

  return WebGLKernelValueBoolean;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueBoolean: WebGLKernelValueBoolean
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"wbNy":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueFloat =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueFloat, _WebGLKernelValue);

  function WebGLKernelValueFloat(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueFloat);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueFloat).call(this, value, settings));
    _this.uploadValue = value;
    return _this;
  }

  _createClass(WebGLKernelValueFloat, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ";\n");
    }
  }, {
    key: "getSource",
    value: function getSource(value) {
      if (this.origin === 'constants') {
        if (Number.isInteger(value)) {
          return "const float ".concat(this.id, " = ").concat(value, ".0;\n");
        }

        return "const float ".concat(this.id, " = ").concat(value, ";\n");
      }

      return "uniform float ".concat(this.id, ";\n");
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (this.origin === 'constants') return;
      this.kernel.setUniform1f(this.id, this.uploadValue = value);
    }
  }]);

  return WebGLKernelValueFloat;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueFloat: WebGLKernelValueFloat
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"NBAu":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueInteger =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueInteger, _WebGLKernelValue);

  function WebGLKernelValueInteger(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueInteger);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueInteger).call(this, value, settings));
    _this.uploadValue = value;
    return _this;
  }

  _createClass(WebGLKernelValueInteger, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ";\n");
    }
  }, {
    key: "getSource",
    value: function getSource(value) {
      if (this.origin === 'constants') {
        return "const int ".concat(this.id, " = ").concat(parseInt(value), ";\n");
      }

      return "uniform int ".concat(this.id, ";\n");
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (this.origin === 'constants') return;
      this.kernel.setUniform1i(this.id, this.uploadValue = value);
    }
  }]);

  return WebGLKernelValueInteger;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueInteger: WebGLKernelValueInteger
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"CVjZ":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueHTMLImage =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueHTMLImage, _WebGLKernelValue);

  function WebGLKernelValueHTMLImage(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueHTMLImage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueHTMLImage).call(this, value, settings));
    var width = value.width,
        height = value.height;
    _this.dimensions = [width, height, 1];

    _this.requestTexture();

    _this.textureSize = [width, height];
    _this.uploadValue = value;
    return _this;
  }

  _createClass(WebGLKernelValueHTMLImage, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ";\n");
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(inputImage) {
      if (inputImage.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueHTMLImage;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueHTMLImage: WebGLKernelValueHTMLImage
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"IMc3":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./html-image'),
    WebGLKernelValueHTMLImage = _require2.WebGLKernelValueHTMLImage;

var WebGLKernelValueDynamicInput =
/*#__PURE__*/
function (_WebGLKernelValueHTML) {
  _inherits(WebGLKernelValueDynamicInput, _WebGLKernelValueHTML);

  function WebGLKernelValueDynamicInput() {
    _classCallCheck(this, WebGLKernelValueDynamicInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicInput).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      var width = value.width,
          height = value.height;
      this.dimensions = [width, height, 1];
      this.textureSize = [width, height];
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicInput.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicInput;
}(WebGLKernelValueHTMLImage);

module.exports = {
  WebGLKernelValueDynamicInput: WebGLKernelValueDynamicInput
};
},{"../../../utils":"9h1E","./html-image":"CVjZ"}],"r9Fn":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueSingleInput =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueSingleInput, _WebGLKernelValue);

  function WebGLKernelValueSingleInput(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueSingleInput);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueSingleInput).call(this, value, settings));

    _this.requestTexture();

    _this.bitRatio = 4;
    _this.dimensions = value.size;
    _this.textureSize = utils.getMemoryOptimizedFloatTextureSize(_this.dimensions, _this.bitRatio);
    _this.uploadArrayLength = _this.textureSize[0] * _this.textureSize[1] * _this.bitRatio;
    _this.uploadValue = new Float32Array(_this.uploadArrayLength);
    return _this;
  }

  _createClass(WebGLKernelValueSingleInput, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return utils.linesToString(["const uploadValue_".concat(this.name, " = new Float32Array(").concat(this.uploadArrayLength, ")"), "flattenTo(".concat(this.varName, ".value, uploadValue_").concat(this.name, ")")]);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(input) {
      if (input.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      utils.flattenTo(input.value, this.uploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueSingleInput;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueSingleInput: WebGLKernelValueSingleInput
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"4OWe":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./single-input'),
    WebGLKernelValueSingleInput = _require2.WebGLKernelValueSingleInput;

var WebGLKernelValueDynamicSingleInput =
/*#__PURE__*/
function (_WebGLKernelValueSing) {
  _inherits(WebGLKernelValueDynamicSingleInput, _WebGLKernelValueSing);

  function WebGLKernelValueDynamicSingleInput() {
    _classCallCheck(this, WebGLKernelValueDynamicSingleInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicSingleInput).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicSingleInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      this.dimensions = value.size;
      this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
      this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
      this.uploadValue = new Float32Array(this.uploadArrayLength);
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicSingleInput.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicSingleInput;
}(WebGLKernelValueSingleInput);

module.exports = {
  WebGLKernelValueDynamicSingleInput: WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":"9h1E","./single-input":"r9Fn"}],"OXpa":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueUnsignedInput =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueUnsignedInput, _WebGLKernelValue);

  function WebGLKernelValueUnsignedInput(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueUnsignedInput);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueUnsignedInput).call(this, value, settings));

    _this.requestTexture();

    _this.bitRatio = _this.getBitRatio(value);
    _this.dimensions = value.size;
    _this.textureSize = utils.getMemoryOptimizedPackedTextureSize(_this.dimensions, _this.bitRatio);
    _this.uploadArrayLength = _this.textureSize[0] * _this.textureSize[1] * (4 / _this.bitRatio);
    _this.TranserArrayType = _this.getTransferArrayType(value.value);
    _this.preUploadValue = new _this.TranserArrayType(_this.uploadArrayLength);
    _this.uploadValue = new Uint8Array(_this.preUploadValue.buffer);
    return _this;
  }

  _createClass(WebGLKernelValueUnsignedInput, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return utils.linesToString(["const preUploadValue_".concat(this.name, " = new ").concat(this.TranserArrayType.name, "(").concat(this.uploadArrayLength, ")"), "const uploadValue_".concat(this.name, " = new Uint8Array(preUploadValue_").concat(this.name, ".buffer)"), "flattenTo(".concat(this.varName, ".value, preUploadValue_").concat(this.name, ")")]);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(input) {
      if (input.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      utils.flattenTo(input.value, this.preUploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueUnsignedInput;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueUnsignedInput: WebGLKernelValueUnsignedInput
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"GnEs":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./unsigned-input'),
    WebGLKernelValueUnsignedInput = _require2.WebGLKernelValueUnsignedInput;

var WebGLKernelValueDynamicUnsignedInput =
/*#__PURE__*/
function (_WebGLKernelValueUnsi) {
  _inherits(WebGLKernelValueDynamicUnsignedInput, _WebGLKernelValueUnsi);

  function WebGLKernelValueDynamicUnsignedInput() {
    _classCallCheck(this, WebGLKernelValueDynamicUnsignedInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicUnsignedInput).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicUnsignedInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      this.dimensions = value.size;
      this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
      this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
      var Type = this.getTransferArrayType(value.value);
      this.preUploadValue = new Type(this.uploadArrayLength);
      this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicUnsignedInput.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicUnsignedInput;
}(WebGLKernelValueUnsignedInput);

module.exports = {
  WebGLKernelValueDynamicUnsignedInput: WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":"9h1E","./unsigned-input":"OXpa"}],"3kTt":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueMemoryOptimizedNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueMemoryOptimizedNumberTexture, _WebGLKernelValue);

  function WebGLKernelValueMemoryOptimizedNumberTexture(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueMemoryOptimizedNumberTexture);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueMemoryOptimizedNumberTexture).call(this, value, settings));

    _this.setupTexture();

    _this.dimensions = value.dimensions;
    _this.textureSize = value.size;
    _this.uploadValue = value.texture;
    return _this;
  }

  _createClass(WebGLKernelValueMemoryOptimizedNumberTexture, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ".texture;\n");
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(inputTexture) {
      if (inputTexture.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      if (this.checkContext && inputTexture.context !== this.context) {
        throw new Error("Value ".concat(this.name, " (").concat(this.type, ") must be from same context"));
      }

      var gl = this.context;
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueMemoryOptimizedNumberTexture;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture: WebGLKernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"+AO5":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./memory-optimized-number-texture'),
    WebGLKernelValueMemoryOptimizedNumberTexture = _require2.WebGLKernelValueMemoryOptimizedNumberTexture;

var WebGLKernelValueDynamicMemoryOptimizedNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueMemo) {
  _inherits(WebGLKernelValueDynamicMemoryOptimizedNumberTexture, _WebGLKernelValueMemo);

  function WebGLKernelValueDynamicMemoryOptimizedNumberTexture() {
    _classCallCheck(this, WebGLKernelValueDynamicMemoryOptimizedNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicMemoryOptimizedNumberTexture).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicMemoryOptimizedNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(inputTexture) {
      this.dimensions = inputTexture.dimensions;
      this.textureSize = inputTexture.size;
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicMemoryOptimizedNumberTexture.prototype), "updateValue", this).call(this, inputTexture);
    }
  }]);

  return WebGLKernelValueDynamicMemoryOptimizedNumberTexture;
}(WebGLKernelValueMemoryOptimizedNumberTexture);

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture: WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":"9h1E","./memory-optimized-number-texture":"3kTt"}],"uSF4":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueNumberTexture, _WebGLKernelValue);

  function WebGLKernelValueNumberTexture(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueNumberTexture);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueNumberTexture).call(this, value, settings));

    _this.setupTexture();

    var textureSize = value.size,
        dimensions = value.dimensions;
    _this.bitRatio = _this.getBitRatio(value);
    _this.dimensions = dimensions;
    _this.textureSize = textureSize;
    _this.uploadValue = value.texture;
    return _this;
  }

  _createClass(WebGLKernelValueNumberTexture, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ".texture;\n");
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(inputTexture) {
      if (inputTexture.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      if (this.checkContext && inputTexture.context !== this.context) {
        throw new Error("Value ".concat(this.name, " (").concat(this.type, ") must be from same context"));
      }

      var gl = this.context;
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueNumberTexture;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueNumberTexture: WebGLKernelValueNumberTexture
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"jP0H":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./number-texture'),
    WebGLKernelValueNumberTexture = _require2.WebGLKernelValueNumberTexture;

var WebGLKernelValueDynamicNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueNumb) {
  _inherits(WebGLKernelValueDynamicNumberTexture, _WebGLKernelValueNumb);

  function WebGLKernelValueDynamicNumberTexture() {
    _classCallCheck(this, WebGLKernelValueDynamicNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicNumberTexture).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      this.dimensions = inputTexture.dimensions;
      this.textureSize = inputTexture.size;
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicNumberTexture.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicNumberTexture;
}(WebGLKernelValueNumberTexture);

module.exports = {
  WebGLKernelValueDynamicNumberTexture: WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":"9h1E","./number-texture":"uSF4"}],"gng4":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueSingleArray =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueSingleArray, _WebGLKernelValue);

  function WebGLKernelValueSingleArray(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueSingleArray);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueSingleArray).call(this, value, settings));

    _this.requestTexture();

    _this.bitRatio = 4;
    _this.dimensions = utils.getDimensions(value, true);
    _this.textureSize = utils.getMemoryOptimizedFloatTextureSize(_this.dimensions, _this.bitRatio);
    _this.uploadArrayLength = _this.textureSize[0] * _this.textureSize[1] * _this.bitRatio;
    _this.uploadValue = new Float32Array(_this.uploadArrayLength);
    return _this;
  }

  _createClass(WebGLKernelValueSingleArray, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return utils.linesToString(["const uploadValue_".concat(this.name, " = new Float32Array(").concat(this.uploadArrayLength, ")"), "flattenTo(".concat(this.varName, ", uploadValue_").concat(this.name, ")")]);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (value.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      utils.flattenTo(value, this.uploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueSingleArray;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueSingleArray: WebGLKernelValueSingleArray
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"GjxE":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./single-array'),
    WebGLKernelValueSingleArray = _require2.WebGLKernelValueSingleArray;

var WebGLKernelValueDynamicSingleArray =
/*#__PURE__*/
function (_WebGLKernelValueSing) {
  _inherits(WebGLKernelValueDynamicSingleArray, _WebGLKernelValueSing);

  function WebGLKernelValueDynamicSingleArray() {
    _classCallCheck(this, WebGLKernelValueDynamicSingleArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicSingleArray).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicSingleArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      this.dimensions = utils.getDimensions(value, true);
      this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
      this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
      this.uploadValue = new Float32Array(this.uploadArrayLength);
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicSingleArray.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicSingleArray;
}(WebGLKernelValueSingleArray);

module.exports = {
  WebGLKernelValueDynamicSingleArray: WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":"9h1E","./single-array":"gng4"}],"0lYd":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGLKernelValueUnsignedArray =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGLKernelValueUnsignedArray, _WebGLKernelValue);

  function WebGLKernelValueUnsignedArray(value, settings) {
    var _this;

    _classCallCheck(this, WebGLKernelValueUnsignedArray);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueUnsignedArray).call(this, value, settings));

    _this.requestTexture();

    _this.bitRatio = _this.getBitRatio(value);
    _this.dimensions = utils.getDimensions(value, true);
    _this.textureSize = utils.getMemoryOptimizedPackedTextureSize(_this.dimensions, _this.bitRatio);
    _this.uploadArrayLength = _this.textureSize[0] * _this.textureSize[1] * (4 / _this.bitRatio);
    _this.TranserArrayType = _this.getTransferArrayType(value);
    _this.preUploadValue = new _this.TranserArrayType(_this.uploadArrayLength);
    _this.uploadValue = new Uint8Array(_this.preUploadValue.buffer);
    return _this;
  }

  _createClass(WebGLKernelValueUnsignedArray, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return utils.linesToString(["const preUploadValue_".concat(this.name, " = new ").concat(this.TranserArrayType.name, "(").concat(this.uploadArrayLength, ")"), "const uploadValue_".concat(this.name, " = new Uint8Array(preUploadValue_").concat(this.name, ".buffer)"), "flattenTo(".concat(this.varName, ", preUploadValue_").concat(this.name, ")")]);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (value.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      utils.flattenTo(value, this.preUploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGLKernelValueUnsignedArray;
}(WebGLKernelValue);

module.exports = {
  WebGLKernelValueUnsignedArray: WebGLKernelValueUnsignedArray
};
},{"../../../utils":"9h1E","./index":"JG6C"}],"/+VX":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('./unsigned-array'),
    WebGLKernelValueUnsignedArray = _require2.WebGLKernelValueUnsignedArray;

var WebGLKernelValueDynamicUnsignedArray =
/*#__PURE__*/
function (_WebGLKernelValueUnsi) {
  _inherits(WebGLKernelValueDynamicUnsignedArray, _WebGLKernelValueUnsi);

  function WebGLKernelValueDynamicUnsignedArray() {
    _classCallCheck(this, WebGLKernelValueDynamicUnsignedArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernelValueDynamicUnsignedArray).apply(this, arguments));
  }

  _createClass(WebGLKernelValueDynamicUnsignedArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      this.dimensions = utils.getDimensions(value, true);
      this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
      this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
      var Type = this.getTransferArrayType(value);
      this.preUploadValue = new Type(this.uploadArrayLength);
      this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGLKernelValueDynamicUnsignedArray.prototype), "updateValue", this).call(this, value);
    }
  }]);

  return WebGLKernelValueDynamicUnsignedArray;
}(WebGLKernelValueUnsignedArray);

module.exports = {
  WebGLKernelValueDynamicUnsignedArray: WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":"9h1E","./unsigned-array":"0lYd"}],"3ijO":[function(require,module,exports) {
var _require = require('./kernel-value/boolean'),
    WebGLKernelValueBoolean = _require.WebGLKernelValueBoolean;

var _require2 = require('./kernel-value/float'),
    WebGLKernelValueFloat = _require2.WebGLKernelValueFloat;

var _require3 = require('./kernel-value/integer'),
    WebGLKernelValueInteger = _require3.WebGLKernelValueInteger;

var _require4 = require('./kernel-value/html-image'),
    WebGLKernelValueHTMLImage = _require4.WebGLKernelValueHTMLImage;

var _require5 = require('./kernel-value/dynamic-html-image'),
    WebGLKernelValueDynamicHTMLImage = _require5.WebGLKernelValueDynamicHTMLImage;

var _require6 = require('./kernel-value/single-input'),
    WebGLKernelValueSingleInput = _require6.WebGLKernelValueSingleInput;

var _require7 = require('./kernel-value/dynamic-single-input'),
    WebGLKernelValueDynamicSingleInput = _require7.WebGLKernelValueDynamicSingleInput;

var _require8 = require('./kernel-value/unsigned-input'),
    WebGLKernelValueUnsignedInput = _require8.WebGLKernelValueUnsignedInput;

var _require9 = require('./kernel-value/dynamic-unsigned-input'),
    WebGLKernelValueDynamicUnsignedInput = _require9.WebGLKernelValueDynamicUnsignedInput;

var _require10 = require('./kernel-value/memory-optimized-number-texture'),
    WebGLKernelValueMemoryOptimizedNumberTexture = _require10.WebGLKernelValueMemoryOptimizedNumberTexture;

var _require11 = require('./kernel-value/dynamic-memory-optimized-number-texture'),
    WebGLKernelValueDynamicMemoryOptimizedNumberTexture = _require11.WebGLKernelValueDynamicMemoryOptimizedNumberTexture;

var _require12 = require('./kernel-value/number-texture'),
    WebGLKernelValueNumberTexture = _require12.WebGLKernelValueNumberTexture;

var _require13 = require('./kernel-value/dynamic-number-texture'),
    WebGLKernelValueDynamicNumberTexture = _require13.WebGLKernelValueDynamicNumberTexture;

var _require14 = require('./kernel-value/single-array'),
    WebGLKernelValueSingleArray = _require14.WebGLKernelValueSingleArray;

var _require15 = require('./kernel-value/dynamic-single-array'),
    WebGLKernelValueDynamicSingleArray = _require15.WebGLKernelValueDynamicSingleArray;

var _require16 = require('./kernel-value/unsigned-array'),
    WebGLKernelValueUnsignedArray = _require16.WebGLKernelValueUnsignedArray;

var _require17 = require('./kernel-value/dynamic-unsigned-array'),
    WebGLKernelValueDynamicUnsignedArray = _require17.WebGLKernelValueDynamicUnsignedArray;

var kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false
    }
  }
};

function lookupKernelValueType(type, dynamic, precision) {
  if (!type) {
    throw new Error('type missing');
  }

  if (!dynamic) {
    throw new Error('dynamic missing');
  }

  if (!precision) {
    throw new Error('precision missing');
  }

  var types = kernelValueMaps[precision][dynamic];

  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error("Could not find a KernelValue for ".concat(type));
  }

  return types[type];
}

module.exports = {
  lookupKernelValueType: lookupKernelValueType
};
},{"./kernel-value/boolean":"BLnS","./kernel-value/float":"wbNy","./kernel-value/integer":"NBAu","./kernel-value/html-image":"CVjZ","./kernel-value/dynamic-html-image":"IMc3","./kernel-value/single-input":"r9Fn","./kernel-value/dynamic-single-input":"4OWe","./kernel-value/unsigned-input":"OXpa","./kernel-value/dynamic-unsigned-input":"GnEs","./kernel-value/memory-optimized-number-texture":"3kTt","./kernel-value/dynamic-memory-optimized-number-texture":"+AO5","./kernel-value/number-texture":"uSF4","./kernel-value/dynamic-number-texture":"jP0H","./kernel-value/single-array":"gng4","./kernel-value/dynamic-single-array":"GjxE","./kernel-value/unsigned-array":"0lYd","./kernel-value/dynamic-unsigned-array":"/+VX"}],"uiFz":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../gl/kernel'),
    GLKernel = _require.GLKernel;

var _require2 = require('../function-builder'),
    FunctionBuilder = _require2.FunctionBuilder;

var _require3 = require('./function-node'),
    WebGLFunctionNode = _require3.WebGLFunctionNode;

var _require4 = require('../../utils'),
    utils = _require4.utils;

var triangleNoise = require('../../plugins/triangle-noise');

var _require5 = require('./fragment-shader'),
    fragmentShader = _require5.fragmentShader;

var _require6 = require('./vertex-shader'),
    vertexShader = _require6.vertexShader;

var _require7 = require('../gl/kernel-string'),
    glKernelString = _require7.glKernelString;

var _require8 = require('./kernel-value-maps'),
    _lookupKernelValueType = _require8.lookupKernelValueType;

var isSupported = null;
var testCanvas = null;
var testContext = null;
var testExtensions = null;
var features = null;
var plugins = [triangleNoise];
var canvases = [];
var maxTexSizes = {};
/**
 * @desc Kernel Implementation for WebGL.
 * <p>This builds the shaders and runs them on the GPU,
 * the outputs the result back as float(enabled by default) and Texture.</p>
 *
 * @prop {Object} textureCache - webGl Texture cache
 * @prop {Object} programUniformLocationCache - Location of program variables in memory
 * @prop {Object} framebuffer - Webgl frameBuffer
 * @prop {Object} buffer - WebGL buffer
 * @prop {Object} program - The webGl Program
 * @prop {Object} functionBuilder - Function Builder instance bound to this Kernel
 * @prop {Boolean} pipeline - Set output type to FAST mode (GPU to GPU via Textures), instead of float
 * @prop {String} endianness - Endian information like Little-endian, Big-endian.
 * @prop {Array} argumentTypes - Types of parameters sent to the Kernel
 * @prop {String} compiledFragmentShader - Compiled fragment shader string
 * @prop {String} compiledVertexShader - Compiled Vertical shader string
 * @extends GLKernel
 */

var WebGLKernel =
/*#__PURE__*/
function (_GLKernel) {
  _inherits(WebGLKernel, _GLKernel);

  _createClass(WebGLKernel, null, [{
    key: "setupFeatureChecks",
    value: function setupFeatureChecks() {
      if (typeof document !== 'undefined') {
        testCanvas = document.createElement('canvas');
      } else if (typeof OffscreenCanvas !== 'undefined') {
        testCanvas = new OffscreenCanvas(0, 0);
      }

      if (!testCanvas) return;
      testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers')
      };
      features = this.getFeatures();
    }
  }, {
    key: "isContextMatch",
    value: function isContextMatch(context) {
      if (typeof WebGLRenderingContext !== 'undefined') {
        return context instanceof WebGLRenderingContext;
      }

      return false;
    }
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      var isDrawBuffers = this.getIsDrawBuffers();
      return Object.freeze({
        isFloatRead: this.getIsFloatRead(),
        isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
        isTextureFloat: this.getIsTextureFloat(),
        isDrawBuffers: isDrawBuffers,
        kernelMap: isDrawBuffers,
        channelCount: this.getChannelCount()
      });
    }
  }, {
    key: "getIsTextureFloat",
    value: function getIsTextureFloat() {
      return Boolean(testExtensions.OES_texture_float);
    }
  }, {
    key: "getIsDrawBuffers",
    value: function getIsDrawBuffers() {
      return Boolean(testExtensions.WEBGL_draw_buffers);
    }
  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return testExtensions.WEBGL_draw_buffers ? testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
    }
  }, {
    key: "lookupKernelValueType",
    value: function lookupKernelValueType(type, dynamic, precision) {
      return _lookupKernelValueType(type, dynamic, precision);
    }
  }, {
    key: "isSupported",
    get: function get() {
      if (isSupported !== null) {
        return isSupported;
      }

      this.setupFeatureChecks();
      isSupported = this.isContextMatch(testContext);
      return isSupported;
    }
  }, {
    key: "testCanvas",
    get: function get() {
      return testCanvas;
    }
  }, {
    key: "testContext",
    get: function get() {
      return testContext;
    }
  }, {
    key: "features",
    get: function get() {
      return features;
    }
  }, {
    key: "fragmentShader",
    get: function get() {
      return fragmentShader;
    }
  }, {
    key: "vertexShader",
    get: function get() {
      return vertexShader;
    }
    /**
     *
     * @param {String} source
     * @param {IKernelSettings} settings
     */

  }]);

  function WebGLKernel(source, settings) {
    var _this;

    _classCallCheck(this, WebGLKernel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLKernel).call(this, source, settings));
    _this.program = null;
    _this.pipeline = settings.pipeline;
    _this.endianness = utils.systemEndianness();
    _this.extensions = {};
    _this.subKernelOutputTextures = null;
    _this.kernelArguments = null;
    _this.argumentTextureCount = 0;
    _this.constantTextureCount = 0;
    _this.compiledFragmentShader = null;
    _this.compiledVertexShader = null;
    _this.fragShader = null;
    _this.vertShader = null;
    _this.drawBuffersMap = null;
    _this.outputTexture = null;
    /**
     *
     * @type {Int32Array|null}
     */

    _this.maxTexSize = null;
    _this.switchingKernels = false;
    _this.onRequestSwitchKernel = null;

    _this.mergeSettings(source.settings || settings);
    /**
     * The thread dimensions, x, y and z
     * @type {Array|null}
     */


    _this.threadDim = null;
    _this.framebuffer = null;
    _this.buffer = null;
    _this.textureCache = {};
    _this.programUniformLocationCache = {};
    _this.uniform1fCache = {};
    _this.uniform1iCache = {};
    _this.uniform2fCache = {};
    _this.uniform2fvCache = {};
    _this.uniform2ivCache = {};
    _this.uniform3fvCache = {};
    _this.uniform3ivCache = {};
    return _this;
  }

  _createClass(WebGLKernel, [{
    key: "initCanvas",
    value: function initCanvas() {
      if (typeof document !== 'undefined') {
        var canvas = document.createElement('canvas'); // Default width and height, to fix webgl issue in safari

        canvas.width = 2;
        canvas.height = 2;
        return canvas;
      } else if (typeof OffscreenCanvas !== 'undefined') {
        return new OffscreenCanvas(0, 0);
      }
    }
  }, {
    key: "initContext",
    value: function initContext() {
      var settings = {
        alpha: false,
        depth: false,
        antialias: false
      };
      return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
    }
  }, {
    key: "initPlugins",
    value: function initPlugins(settings) {
      // default plugins
      var pluginsToUse = [];
      var source = this.source;

      if (typeof source === 'string') {
        for (var i = 0; i < plugins.length; i++) {
          var plugin = plugins[i];

          if (source.match(plugin.functionMatch)) {
            pluginsToUse.push(plugin);
          }
        }
      } else if (_typeof(source) === 'object') {
        // `source` is from object, json
        if (settings.pluginNames) {
          var _loop = function _loop(_i) {
            var plugin = plugins[_i];
            var usePlugin = settings.pluginNames.some(function (pluginName) {
              return pluginName === plugin.name;
            });

            if (usePlugin) {
              pluginsToUse.push(plugin);
            }
          };

          //TODO: in context of JSON support, pluginNames may not exist here
          for (var _i = 0; _i < plugins.length; _i++) {
            _loop(_i);
          }
        }
      }

      return pluginsToUse;
    }
  }, {
    key: "initExtensions",
    value: function initExtensions() {
      this.extensions = {
        OES_texture_float: this.context.getExtension('OES_texture_float'),
        OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float')
      };
    }
  }, {
    key: "validateSettings",
    value: function validateSettings() {
      if (!this.validate) {
        this.texSize = utils.getKernelTextureSize({
          optimizeFloatMemory: this.optimizeFloatMemory,
          precision: this.precision
        }, this.output);
        return;
      }

      var features = this.constructor.features;

      if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
        throw new Error('Float textures are not supported');
      } else if (this.precision === 'single' && !features.isFloatRead) {
        throw new Error('Single precision not supported');
      } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
        this.precision = features.isFloatRead ? 'single' : 'unsigned';
      }

      if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
        throw new Error('could not instantiate draw buffers extension');
      }

      if (this.fixIntegerDivisionAccuracy === null) {
        this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
      } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
        this.fixIntegerDivisionAccuracy = false;
      }

      this.checkOutput();

      if (!this.output || this.output.length === 0) {
        if (arguments.length !== 1) {
          throw new Error('Auto output only supported for kernels with only one input');
        }

        var argType = utils.getVariableType(arguments[0], this.strictIntegers);

        if (argType === 'Array') {
          this.output = utils.getDimensions(argType);
        } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
          this.output = arguments[0].output;
        } else {
          throw new Error('Auto output not supported for input type: ' + argType);
        }
      }

      if (this.graphical) {
        if (this.output.length !== 2) {
          throw new Error('Output must have 2 dimensions on graphical mode');
        }

        if (this.precision === 'precision') {
          this.precision = 'unsigned';
          console.warn('Cannot use graphical mode and single precision at the same time');
        }

        this.texSize = utils.clone(this.output);
        return;
      } else if (this.precision === null && features.isTextureFloat) {
        this.precision = 'single';
      }

      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision
      }, this.output);
    }
  }, {
    key: "updateMaxTexSize",
    value: function updateMaxTexSize() {
      var texSize = this.texSize,
          canvas = this.canvas;

      if (this.maxTexSize === null) {
        var canvasIndex = canvases.indexOf(canvas);

        if (canvasIndex === -1) {
          canvasIndex = canvases.length;
          canvases.push(canvas);
          maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
        }

        this.maxTexSize = maxTexSizes[canvasIndex];
      }

      if (this.maxTexSize[0] < texSize[0]) {
        this.maxTexSize[0] = texSize[0];
      }

      if (this.maxTexSize[1] < texSize[1]) {
        this.maxTexSize[1] = texSize[1];
      }
    } // TODO: move channel checks to new place

  }, {
    key: "_oldtranslateSource",
    value: function _oldtranslateSource() {
      var functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
      }); // need this line to automatically get returnType

      var translatedSource = functionBuilder.getPrototypeString('kernel');

      if (!this.returnType) {
        this.returnType = functionBuilder.getKernelResultType();
      }

      var requiredChannels = 0;
      var returnTypes = functionBuilder.getReturnTypes();

      for (var i = 0; i < returnTypes.length; i++) {
        switch (returnTypes[i]) {
          case 'Float':
          case 'Number':
          case 'Integer':
            requiredChannels++;
            break;

          case 'Array(2)':
            requiredChannels += 2;
            break;

          case 'Array(3)':
            requiredChannels += 3;
            break;

          case 'Array(4)':
            requiredChannels += 4;
            break;
        }
      }

      if (features && requiredChannels > features.channelCount) {
        throw new Error('Too many channels!');
      }

      return this.translatedSource = translatedSource;
    }
  }, {
    key: "setupArguments",
    value: function setupArguments(args) {
      var _this2 = this;

      this.kernelArguments = [];
      this.argumentTextureCount = 0;
      var needsArgumentTypes = this.argumentTypes === null; // TODO: remove

      if (needsArgumentTypes) {
        this.argumentTypes = [];
      }

      this.argumentSizes = [];
      this.argumentBitRatios = []; // TODO: end remove

      if (args.length < this.argumentNames.length) {
        throw new Error('not enough arguments for kernel');
      } else if (args.length > this.argumentNames.length) {
        throw new Error('too many arguments for kernel');
      }

      var gl = this.context;
      var textureIndexes = 0;

      for (var index = 0; index < args.length; index++) {
        var value = args[index];
        var name = this.argumentNames[index];
        var type = void 0;

        if (needsArgumentTypes) {
          type = utils.getVariableType(value, this.strictIntegers);
          this.argumentTypes.push(type);
        } else {
          type = this.argumentTypes[index];
        }

        var KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision);

        if (KernelValue === null) {
          return this.requestFallback(args);
        }

        var kernelArgument = new KernelValue(value, {
          name: name,
          origin: 'user',
          context: gl,
          checkContext: this.checkContext,
          kernel: this,
          strictIntegers: this.strictIntegers,
          onRequestTexture: function onRequestTexture() {
            return _this2.context.createTexture();
          },
          onRequestIndex: function onRequestIndex() {
            return textureIndexes++;
          },
          onUpdateValueMismatch: function onUpdateValueMismatch() {
            _this2.switchingKernels = true;
          },
          onRequestContextHandle: function onRequestContextHandle() {
            return gl.TEXTURE0 + _this2.constantTextureCount + _this2.argumentTextureCount++;
          }
        });
        this.kernelArguments.push(kernelArgument);
        this.argumentSizes.push(kernelArgument.textureSize);
        this.argumentBitRatios[index] = kernelArgument.bitRatio;
      }
    }
  }, {
    key: "setupConstants",
    value: function setupConstants(args) {
      var _this3 = this;

      var gl = this.context;
      this.kernelConstants = [];
      this.constantTypes = {};
      this.constantBitRatios = {};
      var textureIndexes = 0;

      for (var name in this.constants) {
        var value = this.constants[name];
        var type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
        var KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision);

        if (KernelValue === null) {
          return this.requestFallback(args);
        }

        var kernelValue = new KernelValue(value, {
          name: name,
          origin: 'constants',
          context: this.context,
          checkContext: this.checkContext,
          kernel: this,
          strictIntegers: this.strictIntegers,
          onRequestTexture: function onRequestTexture() {
            return _this3.context.createTexture();
          },
          onRequestIndex: function onRequestIndex() {
            return textureIndexes++;
          },
          onRequestContextHandle: function onRequestContextHandle() {
            return gl.TEXTURE0 + _this3.constantTextureCount++;
          }
        });
        this.constantBitRatios[name] = kernelValue.bitRatio;
        this.kernelConstants.push(kernelValue);
      }
    }
  }, {
    key: "build",
    value: function build() {
      this.initExtensions();
      this.validateSettings();
      this.setupConstants(arguments);
      if (this.fallbackRequested) return;
      this.setupArguments(arguments);
      if (this.fallbackRequested) return;
      this.updateMaxTexSize();
      this.translateSource();
      var failureResult = this.pickRenderStrategy(arguments);

      if (failureResult) {
        return failureResult;
      }

      var texSize = this.texSize,
          gl = this.context,
          canvas = this.canvas;
      gl.enable(gl.SCISSOR_TEST);

      if (this.pipeline && this.precision === 'single') {
        gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
        canvas.width = this.maxTexSize[0];
        canvas.height = this.maxTexSize[1];
      } else {
        gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
        canvas.width = this.maxTexSize[0];
        canvas.height = this.maxTexSize[1];
      }

      var threadDim = this.threadDim = Array.from(this.output);

      while (threadDim.length < 3) {
        threadDim.push(1);
      }

      var compiledVertexShader = this.getVertexShader(arguments);
      var vertShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertShader, compiledVertexShader);
      gl.compileShader(vertShader);
      this.vertShader = vertShader;
      var compiledFragmentShader = this.getFragmentShader(arguments);
      var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragShader, compiledFragmentShader);
      gl.compileShader(fragShader);
      this.fragShader = fragShader;

      if (this.debug) {
        console.log('GLSL Shader Output:');
        console.log(compiledFragmentShader);
      }

      if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
        throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
      }

      if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
        throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
      }

      var program = this.program = gl.createProgram();
      gl.attachShader(program, vertShader);
      gl.attachShader(program, fragShader);
      gl.linkProgram(program);
      this.framebuffer = gl.createFramebuffer();
      this.framebuffer.width = texSize[0];
      this.framebuffer.height = texSize[1];
      var vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      var texCoords = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      var texCoordOffset = vertices.byteLength;
      var buffer = this.buffer;

      if (!buffer) {
        buffer = this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
      } else {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      }

      gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
      gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);
      var aPosLoc = gl.getAttribLocation(this.program, 'aPos');
      gl.enableVertexAttribArray(aPosLoc);
      gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
      var aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
      gl.enableVertexAttribArray(aTexCoordLoc);
      gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      var i = 0;
      gl.useProgram(this.program);

      for (var p in this.constants) {
        this.kernelConstants[i++].updateValue(this.constants[p]);
      }

      if (!this.immutable) {
        this._setupOutputTexture();

        if (this.subKernels !== null && this.subKernels.length > 0) {
          this._setupSubOutputTextures();
        }
      }
    }
  }, {
    key: "translateSource",
    value: function translateSource() {
      var functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
      });
      this.translatedSource = functionBuilder.getPrototypeString('kernel');

      if (!this.graphical && !this.returnType) {
        this.returnType = functionBuilder.getKernelResultType();
      }

      if (this.subKernels && this.subKernels.length > 0) {
        for (var i = 0; i < this.subKernels.length; i++) {
          var subKernel = this.subKernels[i];

          if (!subKernel.returnType) {
            subKernel.returnType = functionBuilder.getSubKernelResultType(i);
          }
        }
      }
    }
  }, {
    key: "run",
    value: function run() {
      var kernelArguments = this.kernelArguments;
      var texSize = this.texSize;
      var gl = this.context;
      gl.useProgram(this.program);
      gl.scissor(0, 0, texSize[0], texSize[1]);

      if (this.dynamicOutput) {
        this.setUniform3iv('uOutputDim', this.threadDim);
        this.setUniform2iv('uTexSize', texSize);
      }

      this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);
      this.switchingKernels = false;

      for (var i = 0; i < kernelArguments.length; i++) {
        // this will be handled in renderOutput
        if (this.switchingKernels) return;
        kernelArguments[i].updateValue(arguments[i]);
      }

      if (this.plugins) {
        for (var _i2 = 0; _i2 < this.plugins.length; _i2++) {
          var plugin = this.plugins[_i2];

          if (plugin.onBeforeRun) {
            plugin.onBeforeRun(this);
          }
        }
      }

      if (this.graphical) {
        if (this.pipeline) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

          if (!this.outputTexture || this.immutable) {
            this._setupOutputTexture();
          }

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          return new this.TextureConstructor({
            texture: this.outputTexture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context
          });
        }

        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

      if (this.immutable) {
        this._setupOutputTexture();
      }

      if (this.subKernels !== null) {
        if (this.immutable) {
          this._setupSubOutputTextures();
        }

        this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
      }

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()
     * @returns {Object} Output Texture Cache
     */

  }, {
    key: "getOutputTexture",
    value: function getOutputTexture() {
      return this.outputTexture;
    }
    /**
     * @desc Setup and replace output texture
     */

  }, {
    key: "_setupOutputTexture",
    value: function _setupOutputTexture() {
      var gl = this.context;
      var texSize = this.texSize;
      var texture = this.outputTexture = this.context.createTexture();
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // if (this.precision === 'single') {
      //   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      // } else {
      //   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      // }

      if (this.precision === 'single') {
        if (this.pipeline) {
          // TODO: investigate if webgl1 can handle gl.RED usage in gl.texImage2D, otherwise, simplify the below
          switch (this.returnType) {
            case 'Number':
            case 'Float':
            case 'Integer':
              if (this.optimizeFloatMemory) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
              } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
              }

              break;

            case 'Array(2)':
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
              break;

            case 'Array(3)':
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
              break;

            case 'Array(4)':
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
              break;

            default:
              if (!this.graphical) {
                throw new Error('Unhandled return type');
              }

          }
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
        }
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    }
    /**
     * @desc Setup and replace sub-output textures
     */

  }, {
    key: "_setupSubOutputTextures",
    value: function _setupSubOutputTextures() {
      var gl = this.context;
      var texSize = this.texSize;
      this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
      this.subKernelOutputTextures = [];

      for (var i = 0; i < this.subKernels.length; i++) {
        var texture = this.context.createTexture();
        this.subKernelOutputTextures.push(texture);
        this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
        gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        if (this.precision === 'single') {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
      }
    }
    /**
     * @desc This uses *getTextureCache** to get the Texture Cache of the argument supplied
     * @param {String} name - Name of the argument
     */

  }, {
    key: "getArgumentTexture",
    value: function getArgumentTexture(name) {
      return this.getTextureCache("ARGUMENT_".concat(name));
    }
    /**
     * @desc Returns the Texture Cache of the supplied parameter (can be kernel, sub-kernel or argument)
     * @param {String} name - Name of the subkernel, argument, or kernel.
     * @returns {Object} Texture cache
     */

  }, {
    key: "getTextureCache",
    value: function getTextureCache(name) {
      if (this.textureCache.hasOwnProperty(name)) {
        return this.textureCache[name];
      }

      return this.textureCache[name] = this.context.createTexture();
    }
    /**
     * @desc removes a texture from the kernel's cache
     * @param {String} name - Name of texture
     */

  }, {
    key: "detachTextureCache",
    value: function detachTextureCache(name) {
      delete this.textureCache[name];
    }
  }, {
    key: "setUniform1f",
    value: function setUniform1f(name, value) {
      if (this.uniform1fCache.hasOwnProperty(name)) {
        var cache = this.uniform1fCache[name];

        if (value === cache) {
          return;
        }
      }

      this.uniform1fCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform1f(loc, value);
    }
  }, {
    key: "setUniform1i",
    value: function setUniform1i(name, value) {
      if (this.uniform1iCache.hasOwnProperty(name)) {
        var cache = this.uniform1iCache[name];

        if (value === cache) {
          return;
        }
      }

      this.uniform1iCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform1i(loc, value);
    }
  }, {
    key: "setUniform2f",
    value: function setUniform2f(name, value1, value2) {
      if (this.uniform2fCache.hasOwnProperty(name)) {
        var cache = this.uniform2fCache[name];

        if (value1 === cache[0] && value2 === cache[1]) {
          return;
        }
      }

      this.uniform2fCache[name] = [value1, value2];
      var loc = this.getUniformLocation(name);
      this.context.uniform2f(loc, value1, value2);
    }
  }, {
    key: "setUniform2fv",
    value: function setUniform2fv(name, value) {
      if (this.uniform2fvCache.hasOwnProperty(name)) {
        var cache = this.uniform2fvCache[name];

        if (value[0] === cache[0] && value[1] === cache[1]) {
          return;
        }
      }

      this.uniform2fvCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform2fv(loc, value);
    }
  }, {
    key: "setUniform2iv",
    value: function setUniform2iv(name, value) {
      if (this.uniform2ivCache.hasOwnProperty(name)) {
        var cache = this.uniform2ivCache[name];

        if (value[0] === cache[0] && value[1] === cache[1]) {
          return;
        }
      }

      this.uniform2ivCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform2iv(loc, value);
    }
  }, {
    key: "setUniform3fv",
    value: function setUniform3fv(name, value) {
      if (this.uniform3fvCache.hasOwnProperty(name)) {
        var cache = this.uniform3fvCache[name];

        if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {
          return;
        }
      }

      this.uniform3fvCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform3fv(loc, value);
    }
  }, {
    key: "setUniform3iv",
    value: function setUniform3iv(name, value) {
      if (this.uniform3ivCache.hasOwnProperty(name)) {
        var cache = this.uniform3ivCache[name];

        if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {
          return;
        }
      }

      this.uniform3ivCache[name] = value;
      var loc = this.getUniformLocation(name);
      this.context.uniform3iv(loc, value);
    }
    /**
     * @desc Return WebGlUniformLocation for various variables
     * related to webGl program, such as user-defined variables,
     * as well as, dimension sizes, etc.
     */

  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(name) {
      if (this.programUniformLocationCache.hasOwnProperty(name)) {
        return this.programUniformLocationCache[name];
      }

      return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
    }
    /**
     * @desc Generate Shader artifacts for the kernel program.
     * The final object contains HEADER, KERNEL, MAIN_RESULT, and others.
     *
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {Object} An object containing the Shader Artifacts(CONSTANTS, HEADER, KERNEL, etc.)
     */

  }, {
    key: "_getFragShaderArtifactMap",
    value: function _getFragShaderArtifactMap(args) {
      return {
        HEADER: this._getHeaderString(),
        LOOP_MAX: this._getLoopMaxString(),
        PLUGINS: this._getPluginsString(),
        CONSTANTS: this._getConstantsString(),
        DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
        ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
        DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
        MAIN_CONSTANTS: this._getMainConstantsString(),
        MAIN_ARGUMENTS: this._getMainArgumentsString(args),
        KERNEL: this.getKernelString(),
        MAIN_RESULT: this.getMainResultString()
      };
    }
    /**
     * @desc Get the header string for the program.
     * This returns an empty string if no sub-kernels are defined.
     *
     * @returns {String} result
     */

  }, {
    key: "_getHeaderString",
    value: function _getHeaderString() {
      return this.subKernels !== null ? '#extension GL_EXT_draw_buffers : require\n' : '';
    }
    /**
     * @desc Get the maximum loop size String.
     * @returns {String} result
     */

  }, {
    key: "_getLoopMaxString",
    value: function _getLoopMaxString() {
      return this.loopMaxIterations ? " ".concat(parseInt(this.loopMaxIterations), ";\n") : ' 1000;\n';
    }
  }, {
    key: "_getPluginsString",
    value: function _getPluginsString() {
      var _this4 = this;

      if (!this.plugins) return '\n';
      return this.plugins.map(function (plugin) {
        return plugin.source && _this4.source.match(plugin.functionMatch) ? plugin.source : '';
      }).join('\n');
    }
    /**
     * @desc Generate transpiled glsl Strings for constant parameters sent to a kernel
     * @returns {String} result
     */

  }, {
    key: "_getConstantsString",
    value: function _getConstantsString() {
      var result = [];
      var threadDim = this.threadDim,
          texSize = this.texSize;

      if (this.dynamicOutput) {
        result.push('uniform ivec3 uOutputDim', 'uniform ivec2 uTexSize');
      } else {
        result.push("ivec3 uOutputDim = ivec3(".concat(threadDim[0], ", ").concat(threadDim[1], ", ").concat(threadDim[2], ")"), "ivec2 uTexSize = ivec2(".concat(texSize[0], ", ").concat(texSize[1], ")"));
      }

      return utils.linesToString(result);
    }
    /**
     * @desc Get texture coordinate string for the program
     * @returns {String} result
     */

  }, {
    key: "_getTextureCoordinate",
    value: function _getTextureCoordinate() {
      var subKernels = this.subKernels;

      if (subKernels === null || subKernels.length < 1) {
        return 'varying vec2 vTexCoord;\n';
      } else {
        return 'out vec2 vTexCoord;\n';
      }
    }
    /**
     * @desc Get Decode32 endianness string for little-endian and big-endian
     * @returns {String} result
     */

  }, {
    key: "_getDecode32EndiannessString",
    value: function _getDecode32EndiannessString() {
      return this.endianness === 'LE' ? '' : '  texel.rgba = texel.abgr;\n';
    }
    /**
     * @desc Get Encode32 endianness string for little-endian and big-endian
     * @returns {String} result
     */

  }, {
    key: "_getEncode32EndiannessString",
    value: function _getEncode32EndiannessString() {
      return this.endianness === 'LE' ? '' : '  texel.rgba = texel.abgr;\n';
    }
    /**
     * @desc if fixIntegerDivisionAccuracy provide method to replace /
     * @returns {String} result
     */

  }, {
    key: "_getDivideWithIntegerCheckString",
    value: function _getDivideWithIntegerCheckString() {
      return this.fixIntegerDivisionAccuracy ? "float div_with_int_check(float x, float y) {\n  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\n    return float(int(x)/int(y));\n  }\n  return x / y;\n}" : '';
    }
    /**
     * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {String} result
     */

  }, {
    key: "_getMainArgumentsString",
    value: function _getMainArgumentsString(args) {
      var results = [];
      var argumentNames = this.argumentNames;

      for (var i = 0; i < argumentNames.length; i++) {
        results.push(this.kernelArguments[i].getSource(args[i]));
      }

      return results.join('');
    }
  }, {
    key: "_getMainConstantsString",
    value: function _getMainConstantsString() {
      var result = [];
      var constants = this.constants;

      if (constants) {
        var i = 0;

        for (var name in constants) {
          result.push(this.kernelConstants[i++].getSource(this.constants[name]));
        }
      }

      return result.join('');
    }
    /**
     * @desc Get Kernel program string (in *glsl*) for a kernel.
     * @returns {String} result
     */

  }, {
    key: "getKernelString",
    value: function getKernelString() {
      var kernelResultDeclaration;

      switch (this.returnType) {
        case 'Array(2)':
          kernelResultDeclaration = 'vec2 kernelResult';
          break;

        case 'Array(3)':
          kernelResultDeclaration = 'vec3 kernelResult';
          break;

        case 'Array(4)':
          kernelResultDeclaration = 'vec4 kernelResult';
          break;

        case 'LiteralInteger':
        case 'Float':
        case 'Number':
        case 'Integer':
          kernelResultDeclaration = 'float kernelResult';
          break;

        default:
          if (this.graphical) {
            kernelResultDeclaration = 'float kernelResult';
          } else {
            throw new Error("unrecognized output type \"".concat(this.returnType, "\""));
          }

      }

      var result = [];
      var subKernels = this.subKernels;

      if (subKernels !== null) {
        result.push(kernelResultDeclaration);

        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            for (var i = 0; i < subKernels.length; i++) {
              var subKernel = subKernels[i];
              result.push(subKernel.returnType === 'Integer' ? "int subKernelResult_".concat(subKernel.name, " = 0") : "float subKernelResult_".concat(subKernel.name, " = 0.0"));
            }

            break;

          case 'Array(2)':
            for (var _i3 = 0; _i3 < subKernels.length; _i3++) {
              result.push("vec2 subKernelResult_".concat(subKernels[_i3].name));
            }

            break;

          case 'Array(3)':
            for (var _i4 = 0; _i4 < subKernels.length; _i4++) {
              result.push("vec3 subKernelResult_".concat(subKernels[_i4].name));
            }

            break;

          case 'Array(4)':
            for (var _i5 = 0; _i5 < subKernels.length; _i5++) {
              result.push("vec4 subKernelResult_".concat(subKernels[_i5].name));
            }

            break;
        }
      } else {
        result.push(kernelResultDeclaration);
      }

      return utils.linesToString(result) + this.translatedSource;
    }
  }, {
    key: "getMainResultGraphical",
    value: function getMainResultGraphical() {
      return utils.linesToString(['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragColor = actualColor']);
    }
  }, {
    key: "getMainResultPackedPixels",
    value: function getMainResultPackedPixels() {
      switch (this.returnType) {
        case 'LiteralInteger':
        case 'Number':
        case 'Integer':
        case 'Float':
          return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();

        default:
          throw new Error("packed output only usable with Numbers, \"".concat(this.returnType, "\" specified"));
      }
    }
    /**
     * @return {String}
     */

  }, {
    key: "getMainResultKernelPackedPixels",
    value: function getMainResultKernelPackedPixels() {
      return utils.linesToString(['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', "  gl_FragData[0] = ".concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(kernelResult)")]);
    }
    /**
     * @return {String}
     */

  }, {
    key: "getMainResultSubKernelPackedPixels",
    value: function getMainResultSubKernelPackedPixels() {
      var result = [];
      if (!this.subKernels) return '';

      for (var i = 0; i < this.subKernels.length; i++) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  gl_FragData[".concat(i + 1, "] = ").concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(float(subKernelResult_").concat(this.subKernels[i].name, "))"));
        } else {
          result.push("  gl_FragData[".concat(i + 1, "] = ").concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(subKernelResult_").concat(this.subKernels[i].name, ")"));
        }
      }

      return utils.linesToString(result);
    }
  }, {
    key: "getMainResultMemoryOptimizedFloats",
    value: function getMainResultMemoryOptimizedFloats() {
      var result = ['  index *= 4'];

      switch (this.returnType) {
        case 'Number':
        case 'Integer':
        case 'Float':
          var channels = ['r', 'g', 'b', 'a'];

          for (var i = 0; i < channels.length; i++) {
            var channel = channels[i];
            this.getMainResultKernelMemoryOptimizedFloats(result, channel);
            this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);

            if (i + 1 < channels.length) {
              result.push('  index += 1');
            }
          }

          break;

        default:
          throw new Error("optimized output only usable with Numbers, ".concat(this.returnType, " specified"));
      }

      return utils.linesToString(result);
    }
  }, {
    key: "getMainResultKernelMemoryOptimizedFloats",
    value: function getMainResultKernelMemoryOptimizedFloats(result, channel) {
      result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', "  gl_FragData[0].".concat(channel, " = kernelResult"));
    }
  }, {
    key: "getMainResultSubKernelMemoryOptimizedFloats",
    value: function getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; i++) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  gl_FragData[".concat(i + 1, "].").concat(channel, " = float(subKernelResult_").concat(this.subKernels[i].name, ")"));
        } else {
          result.push("  gl_FragData[".concat(i + 1, "].").concat(channel, " = subKernelResult_").concat(this.subKernels[i].name));
        }
      }
    }
  }, {
    key: "getMainResultKernelNumberTexture",
    value: function getMainResultKernelNumberTexture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragData[0][0] = kernelResult'];
    }
  }, {
    key: "getMainResultSubKernelNumberTexture",
    value: function getMainResultSubKernelNumberTexture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  gl_FragData[".concat(i + 1, "][0] = float(subKernelResult_").concat(subKernel.name, ")"));
        } else {
          result.push("  gl_FragData[".concat(i + 1, "][0] = subKernelResult_").concat(subKernel.name));
        }
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray2Texture",
    value: function getMainResultKernelArray2Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragData[0][0] = kernelResult[0]', '  gl_FragData[0][1] = kernelResult[1]'];
    }
  }, {
    key: "getMainResultSubKernelArray2Texture",
    value: function getMainResultSubKernelArray2Texture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        result.push("  gl_FragData[".concat(i + 1, "][0] = subKernelResult_").concat(this.subKernels[i].name, "[0]"), "  gl_FragData[".concat(i + 1, "][1] = subKernelResult_").concat(this.subKernels[i].name, "[1]"));
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray3Texture",
    value: function getMainResultKernelArray3Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragData[0][0] = kernelResult[0]', '  gl_FragData[0][1] = kernelResult[1]', '  gl_FragData[0][2] = kernelResult[2]'];
    }
  }, {
    key: "getMainResultSubKernelArray3Texture",
    value: function getMainResultSubKernelArray3Texture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        result.push("  gl_FragData[".concat(i + 1, "][0] = subKernelResult_").concat(this.subKernels[i].name, "[0]"), "  gl_FragData[".concat(i + 1, "][1] = subKernelResult_").concat(this.subKernels[i].name, "[1]"), "  gl_FragData[".concat(i + 1, "][2] = subKernelResult_").concat(this.subKernels[i].name, "[2]"));
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray4Texture",
    value: function getMainResultKernelArray4Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragData[0] = kernelResult'];
    }
  }, {
    key: "getMainResultSubKernelArray4Texture",
    value: function getMainResultSubKernelArray4Texture() {
      var result = [];
      if (!this.subKernels) return result;

      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (var i = 0; i < this.subKernels.length; ++i) {
            var subKernel = this.subKernels[i];

            if (subKernel.returnType === 'Integer') {
              result.push("  gl_FragData[".concat(i + 1, "] = float(subKernelResult_").concat(this.subKernels[i].name, ")"));
            } else {
              result.push("  gl_FragData[".concat(i + 1, "] = subKernelResult_").concat(this.subKernels[i].name));
            }
          }

          break;

        case 'Array(2)':
          for (var _i6 = 0; _i6 < this.subKernels.length; ++_i6) {
            result.push("  gl_FragData[".concat(_i6 + 1, "][0] = subKernelResult_").concat(this.subKernels[_i6].name, "[0]"), "  gl_FragData[".concat(_i6 + 1, "][1] = subKernelResult_").concat(this.subKernels[_i6].name, "[1]"));
          }

          break;

        case 'Array(3)':
          for (var _i7 = 0; _i7 < this.subKernels.length; ++_i7) {
            result.push("  gl_FragData[".concat(_i7 + 1, "][0] = subKernelResult_").concat(this.subKernels[_i7].name, "[0]"), "  gl_FragData[".concat(_i7 + 1, "][1] = subKernelResult_").concat(this.subKernels[_i7].name, "[1]"), "  gl_FragData[".concat(_i7 + 1, "][2] = subKernelResult_").concat(this.subKernels[_i7].name, "[2]"));
          }

          break;

        case 'Array(4)':
          for (var _i8 = 0; _i8 < this.subKernels.length; ++_i8) {
            result.push("  gl_FragData[".concat(_i8 + 1, "][0] = subKernelResult_").concat(this.subKernels[_i8].name, "[0]"), "  gl_FragData[".concat(_i8 + 1, "][1] = subKernelResult_").concat(this.subKernels[_i8].name, "[1]"), "  gl_FragData[".concat(_i8 + 1, "][2] = subKernelResult_").concat(this.subKernels[_i8].name, "[2]"), "  gl_FragData[".concat(_i8 + 1, "][3] = subKernelResult_").concat(this.subKernels[_i8].name, "[3]"));
          }

          break;
      }

      return result;
    }
    /**
     * @param {String} src - Shader string
     * @param {Object} map - Variables/Constants associated with shader
     */

  }, {
    key: "replaceArtifacts",
    value: function replaceArtifacts(src, map) {
      return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z])*)__;\n/g, function (match, artifact) {
        if (map.hasOwnProperty(artifact)) {
          return map[artifact];
        }

        throw "unhandled artifact ".concat(artifact);
      });
    }
    /**
     * @desc Get the fragment shader String.
     * If the String hasn't been compiled yet,
     * then this method compiles it as well
     *
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {string} Fragment Shader string
     */

  }, {
    key: "getFragmentShader",
    value: function getFragmentShader(args) {
      if (this.compiledFragmentShader !== null) {
        return this.compiledFragmentShader;
      }

      return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
    }
    /**
     * @desc Get the vertical shader String
     * @param {Array|IArguments} args - The actual parameters sent to the Kernel
     * @returns {string} Vertical Shader string
     */

  }, {
    key: "getVertexShader",
    value: function getVertexShader(args) {
      if (this.compiledVertexShader !== null) {
        return this.compiledVertexShader;
      }

      return this.compiledVertexShader = this.constructor.vertexShader;
    }
    /**
     * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
     */

  }, {
    key: "toString",
    value: function toString() {
      var setupContextString = utils.linesToString(["const gl = context"]);
      return glKernelString(this.constructor, arguments, this, setupContextString);
    }
  }, {
    key: "destroy",
    value: function destroy(removeCanvasReferences) {
      if (this.outputTexture) {
        this.context.deleteTexture(this.outputTexture);
      }

      if (this.buffer) {
        this.context.deleteBuffer(this.buffer);
      }

      if (this.framebuffer) {
        this.context.deleteFramebuffer(this.framebuffer);
      }

      if (this.vertShader) {
        this.context.deleteShader(this.vertShader);
      }

      if (this.fragShader) {
        this.context.deleteShader(this.fragShader);
      }

      if (this.program) {
        this.context.deleteProgram(this.program);
      }

      var keys = Object.keys(this.textureCache);

      for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        this.context.deleteTexture(this.textureCache[name]);
      }

      if (this.subKernelOutputTextures) {
        for (var _i9 = 0; _i9 < this.subKernelOutputTextures.length; _i9++) {
          this.context.deleteTexture(this.subKernelOutputTextures[_i9]);
        }
      }

      if (removeCanvasReferences) {
        var idx = canvases.indexOf(this.canvas);

        if (idx >= 0) {
          canvases[idx] = null;
          maxTexSizes[idx] = null;
        }
      }

      this.destroyExtensions();
      delete this.context;
      delete this.canvas;
    }
  }, {
    key: "destroyExtensions",
    value: function destroyExtensions() {
      this.extensions.OES_texture_float = null;
      this.extensions.OES_texture_float_linear = null;
      this.extensions.OES_element_index_uint = null;
      this.extensions.WEBGL_draw_buffers = null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = _get(_getPrototypeOf(WebGLKernel.prototype), "toJSON", this).call(this);

      json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
      return json;
    }
  }], [{
    key: "destroyContext",
    value: function destroyContext(context) {
      var extension = context.getExtension('WEBGL_lose_context');

      if (extension) {
        extension.loseContext();
      }
    }
  }]);

  return WebGLKernel;
}(GLKernel);

module.exports = {
  WebGLKernel: WebGLKernel
};
},{"../gl/kernel":"8fdV","../function-builder":"HOQD","./function-node":"TrAu","../../utils":"9h1E","../../plugins/triangle-noise":"DqSa","./fragment-shader":"+HoT","./vertex-shader":"gebY","../gl/kernel-string":"n+CM","./kernel-value-maps":"3ijO"}],"5Ni1":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var getContext = require('gl');

var _require = require('../web-gl/kernel'),
    WebGLKernel = _require.WebGLKernel;

var _require2 = require('../gl/kernel-string'),
    glKernelString = _require2.glKernelString;

var isSupported = null;
var testCanvas = null;
var testContext = null;
var testExtensions = null;
var features = null;

var HeadlessGLKernel =
/*#__PURE__*/
function (_WebGLKernel) {
  _inherits(HeadlessGLKernel, _WebGLKernel);

  function HeadlessGLKernel() {
    _classCallCheck(this, HeadlessGLKernel);

    return _possibleConstructorReturn(this, _getPrototypeOf(HeadlessGLKernel).apply(this, arguments));
  }

  _createClass(HeadlessGLKernel, [{
    key: "initCanvas",
    value: function initCanvas() {
      return {};
    }
  }, {
    key: "initContext",
    value: function initContext() {
      var context = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      return context;
    }
  }, {
    key: "initExtensions",
    value: function initExtensions() {
      this.extensions = {
        STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
        OES_texture_float: this.context.getExtension('OES_texture_float'),
        OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers')
      };
    }
  }, {
    key: "build",
    value: function build() {
      _get(_getPrototypeOf(HeadlessGLKernel.prototype), "build", this).apply(this, arguments);

      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }, {
    key: "destroyExtensions",
    value: function destroyExtensions() {
      this.extensions.STACKGL_resize_drawingbuffer = null;
      this.extensions.STACKGL_destroy_context = null;
      this.extensions.OES_texture_float = null;
      this.extensions.OES_texture_float_linear = null;
      this.extensions.OES_element_index_uint = null;
      this.extensions.WEBGL_draw_buffers = null;
    }
  }, {
    key: "toString",

    /**
     * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
     */
    value: function toString() {
      var setupContextString = "const gl = context || require('gl')(1, 1);\n";
      var destroyContextString = "if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n";
      return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
    }
  }, {
    key: "setOutput",
    value: function setOutput(output) {
      _get(_getPrototypeOf(HeadlessGLKernel.prototype), "setOutput", this).call(this, output);

      if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
        this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
      }
    }
  }], [{
    key: "setupFeatureChecks",
    value: function setupFeatureChecks() {
      testCanvas = null;
      testExtensions = null;
      if (typeof getContext !== 'function') return;

      try {
        // just in case, edge cases
        testContext = getContext(2, 2, {
          preserveDrawingBuffer: true
        });
        if (!testContext || !testContext.getExtension) return;
        testExtensions = {
          STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
          STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
          OES_texture_float: testContext.getExtension('OES_texture_float'),
          OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
          OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
          WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers')
        };
        features = this.getFeatures();
      } catch (e) {
        console.warn(e);
      }
    }
  }, {
    key: "isContextMatch",
    value: function isContextMatch(context) {
      try {
        return context.getParameter(context.RENDERER) === 'ANGLE';
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      var isDrawBuffers = this.getIsDrawBuffers();
      return Object.freeze({
        isFloatRead: this.getIsFloatRead(),
        isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
        isTextureFloat: this.getIsTextureFloat(),
        isDrawBuffers: isDrawBuffers,
        kernelMap: isDrawBuffers,
        channelCount: this.getChannelCount()
      });
    }
  }, {
    key: "getIsTextureFloat",
    value: function getIsTextureFloat() {
      return Boolean(testExtensions.OES_texture_float);
    }
  }, {
    key: "getIsDrawBuffers",
    value: function getIsDrawBuffers() {
      return Boolean(testExtensions.WEBGL_draw_buffers);
    }
  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return testExtensions.WEBGL_draw_buffers ? testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
    }
  }, {
    key: "destroyContext",
    value: function destroyContext(context) {
      var extension = context.getExtension('STACKGL_destroy_context');

      if (extension && extension.destroy) {
        extension.destroy();
      }
    }
  }, {
    key: "isSupported",
    get: function get() {
      if (isSupported !== null) return isSupported;
      this.setupFeatureChecks();
      isSupported = testContext !== null;
      return isSupported;
    }
  }, {
    key: "testCanvas",
    get: function get() {
      return testCanvas;
    }
  }, {
    key: "testContext",
    get: function get() {
      return testContext;
    }
  }, {
    key: "features",
    get: function get() {
      return features;
    }
  }]);

  return HeadlessGLKernel;
}(WebGLKernel);

module.exports = {
  HeadlessGLKernel: HeadlessGLKernel
};
},{"gl":"dVPj","../web-gl/kernel":"uiFz","../gl/kernel-string":"n+CM"}],"IZrg":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../web-gl/function-node'),
    WebGLFunctionNode = _require.WebGLFunctionNode;
/**
 * @class WebGL2FunctionNode
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to toString its respective webGL code.
 * @extends WebGLFunctionNode
 * @returns the converted webGL function string
 */


var WebGL2FunctionNode =
/*#__PURE__*/
function (_WebGLFunctionNode) {
  _inherits(WebGL2FunctionNode, _WebGLFunctionNode);

  function WebGL2FunctionNode() {
    _classCallCheck(this, WebGL2FunctionNode);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2FunctionNode).apply(this, arguments));
  }

  _createClass(WebGL2FunctionNode, [{
    key: "astIdentifierExpression",

    /**
     * @desc Parses the abstract syntax tree for *identifier* expression
     * @param {Object} idtNode - An ast Node
     * @param {Array} retArr - return array string
     * @returns {Array} the append retArr
     */
    value: function astIdentifierExpression(idtNode, retArr) {
      if (idtNode.type !== 'Identifier') {
        throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
      }

      var type = this.getType(idtNode);

      if (idtNode.name === 'Infinity') {
        retArr.push('intBitsToFloat(2139095039)');
      } else if (type === 'Boolean') {
        if (this.argumentNames.indexOf(idtNode.name) > -1) {
          retArr.push("bool(user_".concat(idtNode.name, ")"));
        } else {
          retArr.push("user_".concat(idtNode.name));
        }
      } else {
        var userArgumentName = this.getKernelArgumentName(idtNode.name);

        if (userArgumentName) {
          retArr.push("user_".concat(userArgumentName));
        } else {
          retArr.push("user_".concat(idtNode.name));
        }
      }

      return retArr;
    }
  }]);

  return WebGL2FunctionNode;
}(WebGLFunctionNode);

module.exports = {
  WebGL2FunctionNode: WebGL2FunctionNode
};
},{"../web-gl/function-node":"TrAu"}],"3K6r":[function(require,module,exports) {
var fragmentShader = "#version 300 es\n__HEADER__;\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst int LOOP_MAX = __LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nin vec2 vTexCoord;\n\nconst int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - y * (x / y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  int n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n      result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  }\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x/y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) {\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int index) {\n  int channel = integerMod(index, 2);\n  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;\n}\n\nfloat decode8(vec4 texel, int index) {\n  int channel = integerMod(index, 4);\n  return texel[channel] * 255.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  texel.rg = integerMod(texel.rg, 256.0);\n  texel.b = integerMod(texel.b, 128.0);\n  texel.a = exponent*0.5 + 63.5;\n  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  texel = floor(texel);\n  texel *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return texel;\n}\n\n// https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n  float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, -value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  result.b = result.b + exponent*128.0;\n\n  result.g = floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));\n  int w = texSize.x * 2;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\n  return decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + (texDim.x * (xyz.y + (texDim.y * xyz.z)));\n  int channel = integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  index = index / 4;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  return texel[channel];\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture(tex, st / vec2(texSize));\n}\n\nvec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture(tex, vec3(st / vec2(texSize), z));\n}\n\nfloat getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], result[1]);\n}\n\nvec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec3(result[0], result[1], result[2]);\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, y, x);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}";
module.exports = {
  fragmentShader: fragmentShader
};
},{}],"sORU":[function(require,module,exports) {
var vertexShader = "#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nin vec2 aPos;\nin vec2 aTexCoord;\n\nout vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}";
module.exports = {
  vertexShader: vertexShader
};
},{}],"vOTn":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../web-gl/kernel-value/boolean'),
    WebGLKernelValueBoolean = _require.WebGLKernelValueBoolean;

var WebGL2KernelValueBoolean =
/*#__PURE__*/
function (_WebGLKernelValueBool) {
  _inherits(WebGL2KernelValueBoolean, _WebGLKernelValueBool);

  function WebGL2KernelValueBoolean() {
    _classCallCheck(this, WebGL2KernelValueBoolean);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueBoolean).apply(this, arguments));
  }

  return WebGL2KernelValueBoolean;
}(WebGLKernelValueBoolean);

module.exports = {
  WebGL2KernelValueBoolean: WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":"BLnS"}],"KCWZ":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/float'),
    WebGLKernelValueFloat = _require2.WebGLKernelValueFloat;

var WebGL2KernelValueFloat =
/*#__PURE__*/
function (_WebGLKernelValueFloa) {
  _inherits(WebGL2KernelValueFloat, _WebGLKernelValueFloa);

  function WebGL2KernelValueFloat() {
    _classCallCheck(this, WebGL2KernelValueFloat);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueFloat).apply(this, arguments));
  }

  return WebGL2KernelValueFloat;
}(WebGLKernelValueFloat);

module.exports = {
  WebGL2KernelValueFloat: WebGL2KernelValueFloat
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/float":"wbNy"}],"JoFh":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/integer'),
    WebGLKernelValueInteger = _require2.WebGLKernelValueInteger;

var WebGL2KernelValueInteger =
/*#__PURE__*/
function (_WebGLKernelValueInte) {
  _inherits(WebGL2KernelValueInteger, _WebGLKernelValueInte);

  function WebGL2KernelValueInteger() {
    _classCallCheck(this, WebGL2KernelValueInteger);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueInteger).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueInteger, [{
    key: "getSource",
    value: function getSource(value) {
      if (this.origin === 'constants') {
        return "const highp int ".concat(this.id, " = ").concat(parseInt(value), ";\n");
      }

      return "uniform highp int ".concat(this.id, ";\n");
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (this.origin === 'constants') return;
      this.kernel.setUniform1i(this.id, this.uploadValue = value);
    }
  }]);

  return WebGL2KernelValueInteger;
}(WebGLKernelValueInteger);

module.exports = {
  WebGL2KernelValueInteger: WebGL2KernelValueInteger
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/integer":"NBAu"}],"/1EU":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/html-image'),
    WebGLKernelValueHTMLImage = _require2.WebGLKernelValueHTMLImage;

var WebGL2KernelValueHTMLImage =
/*#__PURE__*/
function (_WebGLKernelValueHTML) {
  _inherits(WebGL2KernelValueHTMLImage, _WebGLKernelValueHTML);

  function WebGL2KernelValueHTMLImage() {
    _classCallCheck(this, WebGL2KernelValueHTMLImage);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueHTMLImage).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueHTMLImage, [{
    key: "getSource",
    value: function getSource() {
      // TODO: Do we really need highp?
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }]);

  return WebGL2KernelValueHTMLImage;
}(WebGLKernelValueHTMLImage);

module.exports = {
  WebGL2KernelValueHTMLImage: WebGL2KernelValueHTMLImage
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/html-image":"CVjZ"}],"lCGu":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-html-image'),
    WebGLKernelValueDynamicInput = _require2.WebGLKernelValueDynamicInput;

var WebGL2KernelValueDynamicInput =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicInput, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicInput() {
    _classCallCheck(this, WebGL2KernelValueDynamicInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicInput).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicInput;
}(WebGLKernelValueDynamicInput);

module.exports = {
  WebGL2KernelValueDynamicInput: WebGL2KernelValueDynamicInput
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-html-image":"IMc3"}],"saba":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/index'),
    WebGLKernelValue = _require2.WebGLKernelValue;

var WebGL2KernelValueHtmlImageArray =
/*#__PURE__*/
function (_WebGLKernelValue) {
  _inherits(WebGL2KernelValueHtmlImageArray, _WebGLKernelValue);

  function WebGL2KernelValueHtmlImageArray(value, settings) {
    var _this;

    _classCallCheck(this, WebGL2KernelValueHtmlImageArray);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueHtmlImageArray).call(this, value, settings));

    _this.requestTexture();

    _this.dimensions = [value[0].width, value[0].height, value.length];
    _this.textureSize = [value[0].width, value[0].height];
    return _this;
  }

  _createClass(WebGL2KernelValueHtmlImageArray, [{
    key: "getStringValueHandler",
    value: function getStringValueHandler() {
      return "const uploadValue_".concat(this.name, " = ").concat(this.varName, ";\n");
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2DArray ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(images) {
      var gl = this.context;
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the images into the texture.

      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, images[0].width, images[0].height, images.length, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      for (var i = 0; i < images.length; i++) {
        var xOffset = 0;
        var yOffset = 0;
        var imageDepth = 1;
        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, xOffset, yOffset, i, images[i].width, images[i].height, imageDepth, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = images[i]);
      }

      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGL2KernelValueHtmlImageArray;
}(WebGLKernelValue);

module.exports = {
  WebGL2KernelValueHtmlImageArray: WebGL2KernelValueHtmlImageArray
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/index":"JG6C"}],"yfRm":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./html-image-array'),
    WebGL2KernelValueHtmlImageArray = _require.WebGL2KernelValueHtmlImageArray;

var WebGL2KernelValueDynamicHtmlImageArray =
/*#__PURE__*/
function (_WebGL2KernelValueHtm) {
  _inherits(WebGL2KernelValueDynamicHtmlImageArray, _WebGL2KernelValueHtm);

  function WebGL2KernelValueDynamicHtmlImageArray() {
    _classCallCheck(this, WebGL2KernelValueDynamicHtmlImageArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicHtmlImageArray).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicHtmlImageArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2DArray ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(images) {
      this.dimensions = [images[0].width, images[0].height, images.length];
      this.textureSize = [images[0].width, images[0].height];
      this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
      this.kernel.setUniform2iv(this.sizeId, this.textureSize);

      _get(_getPrototypeOf(WebGL2KernelValueDynamicHtmlImageArray.prototype), "updateValue", this).call(this, images);
    }
  }]);

  return WebGL2KernelValueDynamicHtmlImageArray;
}(WebGL2KernelValueHtmlImageArray);

module.exports = {
  WebGL2KernelValueDynamicHtmlImageArray: WebGL2KernelValueDynamicHtmlImageArray
};
},{"./html-image-array":"saba"}],"pRA1":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/single-input'),
    WebGLKernelValueSingleInput = _require2.WebGLKernelValueSingleInput;

var WebGL2KernelValueSingleInput =
/*#__PURE__*/
function (_WebGLKernelValueSing) {
  _inherits(WebGL2KernelValueSingleInput, _WebGLKernelValueSing);

  function WebGL2KernelValueSingleInput() {
    _classCallCheck(this, WebGL2KernelValueSingleInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueSingleInput).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueSingleInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(input) {
      var gl = this.context;
      utils.flattenTo(input.value, this.uploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGL2KernelValueSingleInput;
}(WebGLKernelValueSingleInput);

module.exports = {
  WebGL2KernelValueSingleInput: WebGL2KernelValueSingleInput
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/single-input":"r9Fn"}],"WL6K":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-single-input'),
    WebGLKernelValueDynamicSingleInput = _require2.WebGLKernelValueDynamicSingleInput;

var WebGL2KernelValueDynamicSingleInput =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicSingleInput, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicSingleInput() {
    _classCallCheck(this, WebGL2KernelValueDynamicSingleInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicSingleInput).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicSingleInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicSingleInput;
}(WebGLKernelValueDynamicSingleInput);

module.exports = {
  WebGL2KernelValueDynamicSingleInput: WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-single-input":"4OWe"}],"I8TL":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/unsigned-input'),
    WebGLKernelValueUnsignedInput = _require2.WebGLKernelValueUnsignedInput;

var WebGL2KernelValueUnsignedInput =
/*#__PURE__*/
function (_WebGLKernelValueUnsi) {
  _inherits(WebGL2KernelValueUnsignedInput, _WebGLKernelValueUnsi);

  function WebGL2KernelValueUnsignedInput() {
    _classCallCheck(this, WebGL2KernelValueUnsignedInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueUnsignedInput).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueUnsignedInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }]);

  return WebGL2KernelValueUnsignedInput;
}(WebGLKernelValueUnsignedInput);

module.exports = {
  WebGL2KernelValueUnsignedInput: WebGL2KernelValueUnsignedInput
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/unsigned-input":"OXpa"}],"RRw4":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-unsigned-input'),
    WebGLKernelValueDynamicUnsignedInput = _require2.WebGLKernelValueDynamicUnsignedInput;

var WebGL2KernelValueDynamicUnsignedInput =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicUnsignedInput, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicUnsignedInput() {
    _classCallCheck(this, WebGL2KernelValueDynamicUnsignedInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicUnsignedInput).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicUnsignedInput, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicUnsignedInput;
}(WebGLKernelValueDynamicUnsignedInput);

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput: WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-unsigned-input":"GnEs"}],"5kiI":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/memory-optimized-number-texture'),
    WebGLKernelValueMemoryOptimizedNumberTexture = _require2.WebGLKernelValueMemoryOptimizedNumberTexture;

var WebGL2KernelValueMemoryOptimizedNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueMemo) {
  _inherits(WebGL2KernelValueMemoryOptimizedNumberTexture, _WebGLKernelValueMemo);

  function WebGL2KernelValueMemoryOptimizedNumberTexture() {
    _classCallCheck(this, WebGL2KernelValueMemoryOptimizedNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueMemoryOptimizedNumberTexture).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueMemoryOptimizedNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      //TODO: do we really need highp?
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }]);

  return WebGL2KernelValueMemoryOptimizedNumberTexture;
}(WebGLKernelValueMemoryOptimizedNumberTexture);

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture: WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/memory-optimized-number-texture":"3kTt"}],"bVQc":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture'),
    WebGLKernelValueDynamicMemoryOptimizedNumberTexture = _require2.WebGLKernelValueDynamicMemoryOptimizedNumberTexture;

var WebGL2KernelValueDynamicMemoryOptimizedNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicMemoryOptimizedNumberTexture, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicMemoryOptimizedNumberTexture() {
    _classCallCheck(this, WebGL2KernelValueDynamicMemoryOptimizedNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicMemoryOptimizedNumberTexture).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicMemoryOptimizedNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform sampler2D ".concat(this.id), "uniform ivec2 ".concat(this.sizeId), "uniform ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicMemoryOptimizedNumberTexture;
}(WebGLKernelValueDynamicMemoryOptimizedNumberTexture);

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":"+AO5"}],"fqbc":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/number-texture'),
    WebGLKernelValueNumberTexture = _require2.WebGLKernelValueNumberTexture;

var WebGL2KernelValueNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueNumb) {
  _inherits(WebGL2KernelValueNumberTexture, _WebGLKernelValueNumb);

  function WebGL2KernelValueNumberTexture() {
    _classCallCheck(this, WebGL2KernelValueNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueNumberTexture).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      //TODO: Do we really need highp?
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }]);

  return WebGL2KernelValueNumberTexture;
}(WebGLKernelValueNumberTexture);

module.exports = {
  WebGL2KernelValueNumberTexture: WebGL2KernelValueNumberTexture
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/number-texture":"uSF4"}],"uEZM":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-number-texture'),
    WebGLKernelValueDynamicNumberTexture = _require2.WebGLKernelValueDynamicNumberTexture;

var WebGL2KernelValueDynamicNumberTexture =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicNumberTexture, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicNumberTexture() {
    _classCallCheck(this, WebGL2KernelValueDynamicNumberTexture);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicNumberTexture).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicNumberTexture, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicNumberTexture;
}(WebGLKernelValueDynamicNumberTexture);

module.exports = {
  WebGL2KernelValueDynamicNumberTexture: WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-number-texture":"jP0H"}],"rmIQ":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/single-array'),
    WebGLKernelValueSingleArray = _require2.WebGLKernelValueSingleArray;

var WebGL2KernelValueSingleArray =
/*#__PURE__*/
function (_WebGLKernelValueSing) {
  _inherits(WebGL2KernelValueSingleArray, _WebGLKernelValueSing);

  function WebGL2KernelValueSingleArray() {
    _classCallCheck(this, WebGL2KernelValueSingleArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueSingleArray).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueSingleArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      if (value.constructor !== this.initialValueConstructor) {
        this.onUpdateValueMismatch();
        return;
      }

      var gl = this.context;
      utils.flattenTo(value, this.uploadValue);
      gl.activeTexture(this.contextHandle);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
      this.kernel.setUniform1i(this.id, this.index);
    }
  }]);

  return WebGL2KernelValueSingleArray;
}(WebGLKernelValueSingleArray);

module.exports = {
  WebGL2KernelValueSingleArray: WebGL2KernelValueSingleArray
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/single-array":"gng4"}],"ZJ10":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-single-array'),
    WebGLKernelValueDynamicSingleArray = _require2.WebGLKernelValueDynamicSingleArray;

var WebGL2KernelValueDynamicSingleArray =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicSingleArray, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicSingleArray() {
    _classCallCheck(this, WebGL2KernelValueDynamicSingleArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicSingleArray).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicSingleArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicSingleArray;
}(WebGLKernelValueDynamicSingleArray);

module.exports = {
  WebGL2KernelValueDynamicSingleArray: WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-single-array":"GjxE"}],"NUqB":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/unsigned-array'),
    WebGLKernelValueUnsignedArray = _require2.WebGLKernelValueUnsignedArray;

var WebGL2KernelValueUnsignedArray =
/*#__PURE__*/
function (_WebGLKernelValueUnsi) {
  _inherits(WebGL2KernelValueUnsignedArray, _WebGLKernelValueUnsi);

  function WebGL2KernelValueUnsignedArray() {
    _classCallCheck(this, WebGL2KernelValueUnsignedArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueUnsignedArray).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueUnsignedArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "highp ivec2 ".concat(this.sizeId, " = ivec2(").concat(this.textureSize[0], ", ").concat(this.textureSize[1], ")"), "highp ivec3 ".concat(this.dimensionsId, " = ivec3(").concat(this.dimensions[0], ", ").concat(this.dimensions[1], ", ").concat(this.dimensions[2], ")")]);
    }
  }]);

  return WebGL2KernelValueUnsignedArray;
}(WebGLKernelValueUnsignedArray);

module.exports = {
  WebGL2KernelValueUnsignedArray: WebGL2KernelValueUnsignedArray
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/unsigned-array":"0lYd"}],"MivH":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../../../utils'),
    utils = _require.utils;

var _require2 = require('../../web-gl/kernel-value/dynamic-unsigned-array'),
    WebGLKernelValueDynamicUnsignedArray = _require2.WebGLKernelValueDynamicUnsignedArray;

var WebGL2KernelValueDynamicUnsignedArray =
/*#__PURE__*/
function (_WebGLKernelValueDyna) {
  _inherits(WebGL2KernelValueDynamicUnsignedArray, _WebGLKernelValueDyna);

  function WebGL2KernelValueDynamicUnsignedArray() {
    _classCallCheck(this, WebGL2KernelValueDynamicUnsignedArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2KernelValueDynamicUnsignedArray).apply(this, arguments));
  }

  _createClass(WebGL2KernelValueDynamicUnsignedArray, [{
    key: "getSource",
    value: function getSource() {
      return utils.linesToString(["uniform highp sampler2D ".concat(this.id), "uniform highp ivec2 ".concat(this.sizeId), "uniform highp ivec3 ".concat(this.dimensionsId)]);
    }
  }]);

  return WebGL2KernelValueDynamicUnsignedArray;
}(WebGLKernelValueDynamicUnsignedArray);

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray: WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":"9h1E","../../web-gl/kernel-value/dynamic-unsigned-array":"/+VX"}],"Y9kF":[function(require,module,exports) {
var _require = require('./kernel-value/boolean'),
    WebGL2KernelValueBoolean = _require.WebGL2KernelValueBoolean;

var _require2 = require('./kernel-value/float'),
    WebGL2KernelValueFloat = _require2.WebGL2KernelValueFloat;

var _require3 = require('./kernel-value/integer'),
    WebGL2KernelValueInteger = _require3.WebGL2KernelValueInteger;

var _require4 = require('./kernel-value/html-image'),
    WebGL2KernelValueHTMLImage = _require4.WebGL2KernelValueHTMLImage;

var _require5 = require('./kernel-value/dynamic-html-image'),
    WebGL2KernelValueDynamicHTMLImage = _require5.WebGL2KernelValueDynamicHTMLImage;

var _require6 = require('./kernel-value/html-image-array'),
    WebGL2KernelValueHtmlImageArray = _require6.WebGL2KernelValueHtmlImageArray;

var _require7 = require('./kernel-value/dynamic-html-image-array'),
    WebGL2KernelValueDynamicHtmlImageArray = _require7.WebGL2KernelValueDynamicHtmlImageArray;

var _require8 = require('./kernel-value/single-input'),
    WebGL2KernelValueSingleInput = _require8.WebGL2KernelValueSingleInput;

var _require9 = require('./kernel-value/dynamic-single-input'),
    WebGL2KernelValueDynamicSingleInput = _require9.WebGL2KernelValueDynamicSingleInput;

var _require10 = require('./kernel-value/unsigned-input'),
    WebGL2KernelValueUnsignedInput = _require10.WebGL2KernelValueUnsignedInput;

var _require11 = require('./kernel-value/dynamic-unsigned-input'),
    WebGL2KernelValueDynamicUnsignedInput = _require11.WebGL2KernelValueDynamicUnsignedInput;

var _require12 = require('./kernel-value/memory-optimized-number-texture'),
    WebGL2KernelValueMemoryOptimizedNumberTexture = _require12.WebGL2KernelValueMemoryOptimizedNumberTexture;

var _require13 = require('./kernel-value/dynamic-memory-optimized-number-texture'),
    WebGL2KernelValueDynamicMemoryOptimizedNumberTexture = _require13.WebGL2KernelValueDynamicMemoryOptimizedNumberTexture;

var _require14 = require('./kernel-value/number-texture'),
    WebGL2KernelValueNumberTexture = _require14.WebGL2KernelValueNumberTexture;

var _require15 = require('./kernel-value/dynamic-number-texture'),
    WebGL2KernelValueDynamicNumberTexture = _require15.WebGL2KernelValueDynamicNumberTexture;

var _require16 = require('./kernel-value/single-array'),
    WebGL2KernelValueSingleArray = _require16.WebGL2KernelValueSingleArray;

var _require17 = require('./kernel-value/dynamic-single-array'),
    WebGL2KernelValueDynamicSingleArray = _require17.WebGL2KernelValueDynamicSingleArray;

var _require18 = require('./kernel-value/unsigned-array'),
    WebGL2KernelValueUnsignedArray = _require18.WebGL2KernelValueUnsignedArray;

var _require19 = require('./kernel-value/dynamic-unsigned-array'),
    WebGL2KernelValueDynamicUnsignedArray = _require19.WebGL2KernelValueDynamicUnsignedArray;

var kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHtmlImageArray
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHtmlImageArray
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHtmlImageArray
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHtmlImageArray
    }
  }
};

function lookupKernelValueType(type, dynamic, precision) {
  if (!type) {
    throw new Error('type missing');
  }

  if (!dynamic) {
    throw new Error('dynamic missing');
  }

  if (!precision) {
    throw new Error('precision missing');
  }

  var types = kernelValueMaps[precision][dynamic];

  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error("Could not find a KernelValue for ".concat(type));
  }

  return types[type];
}

module.exports = {
  lookupKernelValueType: lookupKernelValueType
};
},{"./kernel-value/boolean":"vOTn","./kernel-value/float":"KCWZ","./kernel-value/integer":"JoFh","./kernel-value/html-image":"/1EU","./kernel-value/dynamic-html-image":"lCGu","./kernel-value/html-image-array":"saba","./kernel-value/dynamic-html-image-array":"yfRm","./kernel-value/single-input":"pRA1","./kernel-value/dynamic-single-input":"WL6K","./kernel-value/unsigned-input":"I8TL","./kernel-value/dynamic-unsigned-input":"RRw4","./kernel-value/memory-optimized-number-texture":"5kiI","./kernel-value/dynamic-memory-optimized-number-texture":"bVQc","./kernel-value/number-texture":"fqbc","./kernel-value/dynamic-number-texture":"uEZM","./kernel-value/single-array":"rmIQ","./kernel-value/dynamic-single-array":"ZJ10","./kernel-value/unsigned-array":"NUqB","./kernel-value/dynamic-unsigned-array":"MivH"}],"sSW8":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('../web-gl/kernel'),
    WebGLKernel = _require.WebGLKernel;

var _require2 = require('./function-node'),
    WebGL2FunctionNode = _require2.WebGL2FunctionNode;

var _require3 = require('../function-builder'),
    FunctionBuilder = _require3.FunctionBuilder;

var _require4 = require('../../utils'),
    utils = _require4.utils;

var _require5 = require('./fragment-shader'),
    fragmentShader = _require5.fragmentShader;

var _require6 = require('./vertex-shader'),
    vertexShader = _require6.vertexShader;

var _require7 = require('./kernel-value-maps'),
    _lookupKernelValueType = _require7.lookupKernelValueType;

var isSupported = null;
var testCanvas = null;
var testContext = null;
var testExtensions = null;
/**
 *
 * @type {{
 *   isFloatRead: Boolean,
 *   isIntegerDivisionAccurate: Boolean,
 *   kernelMap: Boolean,
 *   isTextureFloat: Boolean,
 * }|null}
 */

var features = null;
/**
 * @extends WebGLKernel
 */

var WebGL2Kernel =
/*#__PURE__*/
function (_WebGLKernel) {
  _inherits(WebGL2Kernel, _WebGLKernel);

  function WebGL2Kernel() {
    _classCallCheck(this, WebGL2Kernel);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebGL2Kernel).apply(this, arguments));
  }

  _createClass(WebGL2Kernel, [{
    key: "initContext",
    value: function initContext() {
      var settings = {
        alpha: false,
        depth: false,
        antialias: false
      };
      var context = this.canvas.getContext('webgl2', settings);
      return context;
    }
  }, {
    key: "initExtensions",
    value: function initExtensions() {
      this.extensions = {
        EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
        OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear')
      };
    }
  }, {
    key: "validateSettings",
    value: function validateSettings() {
      if (!this.validate) {
        this.texSize = utils.getKernelTextureSize({
          optimizeFloatMemory: this.optimizeFloatMemory,
          precision: this.precision
        }, this.output);
        return;
      }

      var features = this.constructor.features;

      if (this.precision === 'single' && !features.isFloatRead) {
        throw new Error('Float texture outputs are not supported');
      } else if (!this.graphical && this.precision === null) {
        this.precision = features.isFloatRead ? 'single' : 'unsigned';
      }

      if (this.fixIntegerDivisionAccuracy === null) {
        this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
      } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
        this.fixIntegerDivisionAccuracy = false;
      }

      this.checkOutput();

      if (!this.output || this.output.length === 0) {
        if (arguments.length !== 1) {
          throw new Error('Auto output only supported for kernels with only one input');
        }

        var argType = utils.getVariableType(arguments[0], this.strictIntegers);

        switch (argType) {
          case 'Array':
            this.output = utils.getDimensions(argType);
            break;

          case 'NumberTexture':
          case 'MemoryOptimizedNumberTexture':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
            this.output = arguments[0].output;
            break;

          default:
            throw new Error('Auto output not supported for input type: ' + argType);
        }
      }

      if (this.graphical) {
        if (this.output.length !== 2) {
          throw new Error('Output must have 2 dimensions on graphical mode');
        }

        if (this.precision === 'single') {
          console.warn('Cannot use graphical mode and single precision at the same time');
          this.precision = 'unsigned';
        }

        this.texSize = utils.clone(this.output);
        return;
      } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
        this.precision = 'single';
      }

      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision
      }, this.output);
    }
  }, {
    key: "translateSource",
    value: function translateSource() {
      var functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
      });
      this.translatedSource = functionBuilder.getPrototypeString('kernel');

      if (!this.graphical && !this.returnType) {
        this.returnType = functionBuilder.getKernelResultType();
      }

      if (this.subKernels && this.subKernels.length > 0) {
        for (var i = 0; i < this.subKernels.length; i++) {
          var subKernel = this.subKernels[i];

          if (!subKernel.returnType) {
            subKernel.returnType = functionBuilder.getSubKernelResultType(i);
          }
        }
      }
    }
  }, {
    key: "run",
    value: function run() {
      var kernelArguments = this.kernelArguments,
          texSize = this.texSize;
      var gl = this.context;
      gl.useProgram(this.program);
      gl.scissor(0, 0, texSize[0], texSize[1]);

      if (this.dynamicOutput) {
        this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
        this.setUniform2iv('uTexSize', texSize);
      }

      this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

      for (var i = 0; i < kernelArguments.length; i++) {
        if (this.switchingKernels) return;
        kernelArguments[i].updateValue(arguments[i]);
      }

      if (this.plugins) {
        for (var _i = 0; _i < this.plugins.length; _i++) {
          var plugin = this.plugins[_i];

          if (plugin.onBeforeRun) {
            plugin.onBeforeRun(this);
          }
        }
      }

      if (this.graphical) {
        if (this.pipeline) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

          if (!this.outputTexture || this.immutable) {
            this._setupOutputTexture();
          }

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          return new this.TextureConstructor({
            texture: this.outputTexture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context
          });
        }

        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

      if (this.immutable) {
        this._setupOutputTexture();
      }

      if (this.subKernels !== null) {
        if (this.immutable) {
          this._setupSubOutputTextures();
        }

        gl.drawBuffers(this.drawBuffersMap);
      }

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  }, {
    key: "drawBuffers",
    value: function drawBuffers() {
      this.context.drawBuffers(this.drawBuffersMap);
    }
  }, {
    key: "getOutputTexture",
    value: function getOutputTexture() {
      return this.outputTexture;
    }
  }, {
    key: "_setupOutputTexture",
    value: function _setupOutputTexture() {
      var texSize = this.texSize;
      var gl = this.context;
      var texture = this.outputTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      if (this.precision === 'single') {
        if (this.pipeline) {
          switch (this.returnType) {
            case 'Number':
            case 'Float':
            case 'Integer':
              if (this.optimizeFloatMemory) {
                gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, texSize[0], texSize[1]);
              } else {
                gl.texStorage2D(gl.TEXTURE_2D, 1, gl.R32F, texSize[0], texSize[1]);
              }

              break;

            case 'Array(2)':
              gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RG32F, texSize[0], texSize[1]);
              break;

            case 'Array(3)': // there is _no_ 3 channel format which is guaranteed to be color-renderable

            case 'Array(4)':
              gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, texSize[0], texSize[1]);
              break;

            default:
              throw new Error('Unhandled return type');
          }
        } else {
          gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, texSize[0], texSize[1]);
        }
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    }
  }, {
    key: "_setupSubOutputTextures",
    value: function _setupSubOutputTextures() {
      var texSize = this.texSize;
      var gl = this.context;
      this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
      this.subKernelOutputTextures = [];

      for (var i = 0; i < this.subKernels.length; i++) {
        var texture = this.context.createTexture();
        this.subKernelOutputTextures.push(texture);
        this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
        gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // TODO: upgrade this

        if (this.precision === 'single') {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
      }
    }
    /**
     *
     * @desc Get the header string for the program.
     * This returns an empty string if no sub-kernels are defined.
     *
     * @returns {String} result
     */

  }, {
    key: "_getHeaderString",
    value: function _getHeaderString() {
      return '';
    }
    /**
     * @desc Get texture coordinate string for the program
     * @returns {String} result
     */

  }, {
    key: "_getTextureCoordinate",
    value: function _getTextureCoordinate() {
      var subKernels = this.subKernels;

      if (subKernels === null || subKernels.length < 1) {
        return 'in highp vec2 vTexCoord;\n';
      } else {
        return 'out highp vec2 vTexCoord;\n';
      }
    }
    /**
     * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {String} result
     */

  }, {
    key: "_getMainArgumentsString",
    value: function _getMainArgumentsString(args) {
      var result = [];
      var argumentNames = this.argumentNames;

      for (var i = 0; i < argumentNames.length; i++) {
        result.push(this.kernelArguments[i].getSource(args[i]));
      }

      return result.join('');
    }
    /**
     * @desc Get Kernel program string (in *glsl*) for a kernel.
     * @returns {String} result
     */

  }, {
    key: "getKernelString",
    value: function getKernelString() {
      var kernelResultDeclaration;

      switch (this.returnType) {
        case 'Array(2)':
          kernelResultDeclaration = 'vec2 kernelResult';
          break;

        case 'Array(3)':
          kernelResultDeclaration = 'vec3 kernelResult';
          break;

        case 'Array(4)':
          kernelResultDeclaration = 'vec4 kernelResult';
          break;

        case 'LiteralInteger':
        case 'Float':
        case 'Number':
        case 'Integer':
          kernelResultDeclaration = 'float kernelResult';
          break;

        default:
          if (this.graphical) {
            kernelResultDeclaration = 'float kernelResult';
          } else {
            throw new Error("unrecognized output type \"".concat(this.returnType, "\""));
          }

      }

      var result = [];
      var subKernels = this.subKernels;

      if (subKernels !== null) {
        result.push(kernelResultDeclaration, 'layout(location = 0) out vec4 data0');

        for (var i = 0; i < subKernels.length; i++) {
          var subKernel = subKernels[i];
          result.push(subKernel.returnType === 'Integer' ? "int subKernelResult_".concat(subKernel.name, " = 0") : "float subKernelResult_".concat(subKernel.name, " = 0.0"), "layout(location = ".concat(i + 1, ") out vec4 data").concat(i + 1));
        }
      } else {
        result.push('out vec4 data0', kernelResultDeclaration);
      }

      return utils.linesToString(result) + this.translatedSource;
    }
  }, {
    key: "getMainResultGraphical",
    value: function getMainResultGraphical() {
      return utils.linesToString(['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = actualColor']);
    }
  }, {
    key: "getMainResultPackedPixels",
    value: function getMainResultPackedPixels() {
      switch (this.returnType) {
        case 'LiteralInteger':
        case 'Number':
        case 'Integer':
        case 'Float':
          return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();

        default:
          throw new Error("packed output only usable with Numbers, \"".concat(this.returnType, "\" specified"));
      }
    }
    /**
     * @return {String}
     */

  }, {
    key: "getMainResultKernelPackedPixels",
    value: function getMainResultKernelPackedPixels() {
      return utils.linesToString(['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', "  data0 = ".concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(kernelResult)")]);
    }
    /**
     * @return {String}
     */

  }, {
    key: "getMainResultSubKernelPackedPixels",
    value: function getMainResultSubKernelPackedPixels() {
      var result = [];
      if (!this.subKernels) return '';

      for (var i = 0; i < this.subKernels.length; i++) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  data".concat(i + 1, " = ").concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(float(subKernelResult_").concat(this.subKernels[i].name, "))"));
        } else {
          result.push("  data".concat(i + 1, " = ").concat(this.useLegacyEncoder ? 'legacyEncode32' : 'encode32', "(subKernelResult_").concat(this.subKernels[i].name, ")"));
        }
      }

      return utils.linesToString(result);
    }
  }, {
    key: "getMainResultMemoryOptimizedFloats",
    value: function getMainResultMemoryOptimizedFloats() {
      var result = ['  index *= 4'];

      switch (this.returnType) {
        case 'Number':
        case 'Integer':
        case 'Float':
          var channels = ['r', 'g', 'b', 'a'];

          for (var i = 0; i < channels.length; i++) {
            var channel = channels[i];
            this.getMainResultKernelMemoryOptimizedFloats(result, channel);
            this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);

            if (i + 1 < channels.length) {
              result.push('  index += 1');
            }
          }

          break;

        default:
          throw new Error("optimized output only usable with Numbers, ".concat(this.returnType, " specified"));
      }

      return utils.linesToString(result);
    }
  }, {
    key: "getMainResultKernelMemoryOptimizedFloats",
    value: function getMainResultKernelMemoryOptimizedFloats(result, channel) {
      result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', "  data0.".concat(channel, " = kernelResult"));
    }
  }, {
    key: "getMainResultSubKernelMemoryOptimizedFloats",
    value: function getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; i++) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  data".concat(i + 1, ".").concat(channel, " = float(subKernelResult_").concat(subKernel.name, ")"));
        } else {
          result.push("  data".concat(i + 1, ".").concat(channel, " = subKernelResult_").concat(subKernel.name));
        }
      }
    }
  }, {
    key: "getMainResultKernelNumberTexture",
    value: function getMainResultKernelNumberTexture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0[0] = kernelResult'];
    }
  }, {
    key: "getMainResultSubKernelNumberTexture",
    value: function getMainResultSubKernelNumberTexture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        var subKernel = this.subKernels[i];

        if (subKernel.returnType === 'Integer') {
          result.push("  data".concat(i + 1, "[0] = float(subKernelResult_").concat(subKernel.name, ")"));
        } else {
          result.push("  data".concat(i + 1, "[0] = subKernelResult_").concat(subKernel.name));
        }
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray2Texture",
    value: function getMainResultKernelArray2Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0[0] = kernelResult[0]', '  data0[1] = kernelResult[1]'];
    }
  }, {
    key: "getMainResultSubKernelArray2Texture",
    value: function getMainResultSubKernelArray2Texture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        var subKernel = this.subKernels[i];
        result.push("  data".concat(i + 1, "[0] = subKernelResult_").concat(subKernel.name, "[0]"), "  data".concat(i + 1, "[1] = subKernelResult_").concat(subKernel.name, "[1]"));
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray3Texture",
    value: function getMainResultKernelArray3Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0[0] = kernelResult[0]', '  data0[1] = kernelResult[1]', '  data0[2] = kernelResult[2]'];
    }
  }, {
    key: "getMainResultSubKernelArray3Texture",
    value: function getMainResultSubKernelArray3Texture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        var subKernel = this.subKernels[i];
        result.push("  data".concat(i + 1, "[0] = subKernelResult_").concat(subKernel.name, "[0]"), "  data".concat(i + 1, "[1] = subKernelResult_").concat(subKernel.name, "[1]"), "  data".concat(i + 1, "[2] = subKernelResult_").concat(subKernel.name, "[2]"));
      }

      return result;
    }
  }, {
    key: "getMainResultKernelArray4Texture",
    value: function getMainResultKernelArray4Texture() {
      return ['  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = kernelResult'];
    }
  }, {
    key: "getMainResultSubKernelArray4Texture",
    value: function getMainResultSubKernelArray4Texture() {
      var result = [];
      if (!this.subKernels) return result;

      for (var i = 0; i < this.subKernels.length; ++i) {
        result.push("  data".concat(i + 1, " = subKernelResult_").concat(this.subKernels[i].name));
      }

      return result;
    }
    /**
     * @desc Get the fragment shader String.
     * If the String hasn't been compiled yet,
     * then this method compiles it as well
     *
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {string} Fragment Shader string
     */

  }, {
    key: "getFragmentShader",
    value: function getFragmentShader(args) {
      if (this.compiledFragmentShader !== null) {
        return this.compiledFragmentShader;
      }

      return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
    }
    /**
     * @desc Get the vertical shader String
     * @param {Array} args - The actual parameters sent to the Kernel
     * @returns {string} Vertical Shader string
     *
     */

  }, {
    key: "getVertexShader",
    value: function getVertexShader(args) {
      if (this.compiledVertexShader !== null) {
        return this.compiledVertexShader;
      }

      return this.compiledVertexShader = this.constructor.vertexShader;
    }
  }, {
    key: "destroyExtensions",
    value: function destroyExtensions() {
      this.extensions.EXT_color_buffer_float = null;
      this.extensions.OES_texture_float_linear = null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = _get(_getPrototypeOf(WebGL2Kernel.prototype), "toJSON", this).call(this);

      json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
      return json;
    }
  }], [{
    key: "setupFeatureChecks",
    value: function setupFeatureChecks() {
      if (typeof document !== 'undefined') {
        testCanvas = document.createElement('canvas');
      } else if (typeof OffscreenCanvas !== 'undefined') {
        testCanvas = new OffscreenCanvas(0, 0);
      }

      if (!testCanvas) return;
      testContext = testCanvas.getContext('webgl2');
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear')
      };
      features = this.getFeatures();
    }
  }, {
    key: "isContextMatch",
    value: function isContextMatch(context) {
      // from global
      if (typeof WebGL2RenderingContext !== 'undefined') {
        return context instanceof WebGL2RenderingContext;
      }

      return false;
    }
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      return Object.freeze({
        isFloatRead: this.getIsFloatRead(),
        isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
        kernelMap: true,
        isTextureFloat: true,
        channelCount: this.getChannelCount()
      });
    }
  }, {
    key: "getIsTextureFloat",
    value: function getIsTextureFloat() {
      return true;
    }
  }, {
    key: "getIsIntegerDivisionAccurate",
    value: function getIsIntegerDivisionAccurate() {
      return _get(_getPrototypeOf(WebGL2Kernel), "getIsIntegerDivisionAccurate", this).call(this);
    }
  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
    }
  }, {
    key: "lookupKernelValueType",
    value: function lookupKernelValueType(type, dynamic, precision) {
      return _lookupKernelValueType(type, dynamic, precision);
    }
  }, {
    key: "isSupported",
    get: function get() {
      if (isSupported !== null) {
        return isSupported;
      }

      this.setupFeatureChecks();
      isSupported = this.isContextMatch(testContext);
      return isSupported;
    }
  }, {
    key: "testCanvas",
    get: function get() {
      return testCanvas;
    }
  }, {
    key: "testContext",
    get: function get() {
      return testContext;
    }
    /**
     *
     * @returns {{isFloatRead: Boolean, isIntegerDivisionAccurate: Boolean, kernelMap: Boolean, isTextureFloat: Boolean}}
     */

  }, {
    key: "features",
    get: function get() {
      return features;
    }
  }, {
    key: "fragmentShader",
    get: function get() {
      return fragmentShader;
    }
  }, {
    key: "vertexShader",
    get: function get() {
      return vertexShader;
    }
  }]);

  return WebGL2Kernel;
}(WebGLKernel);

module.exports = {
  WebGL2Kernel: WebGL2Kernel
};
},{"../web-gl/kernel":"uiFz","./function-node":"IZrg","../function-builder":"HOQD","../../utils":"9h1E","./fragment-shader":"3K6r","./vertex-shader":"sORU","./kernel-value-maps":"Y9kF"}],"t2wu":[function(require,module,exports) {
var _require = require('./utils'),
    utils = _require.utils;
/**
 * Makes kernels easier for mortals (including me)
 * @param kernel
 * @returns {function()}
 */


function kernelRunShortcut(kernel) {
  var _run = function run() {
    kernel.build.apply(kernel, arguments);

    if (kernel.renderKernels) {
      _run = function run() {
        kernel.run.apply(kernel, arguments);

        if (kernel.switchingKernels) {
          kernel.switchingKernels = false;
          return kernel.onRequestSwitchKernel(arguments, kernel);
        }

        return kernel.renderKernels();
      };

      kernel.run.apply(kernel, arguments);
      return kernel.renderKernels();
    } else if (kernel.renderOutput) {
      _run = function run() {
        kernel.run.apply(kernel, arguments);

        if (kernel.switchingKernels) {
          kernel.switchingKernels = false;
          return kernel.onRequestSwitchKernel(arguments, kernel);
        }

        return kernel.renderOutput();
      };

      kernel.run.apply(kernel, arguments);
      return kernel.renderOutput();
    } else {
      _run = function run() {
        return kernel.run.apply(kernel, arguments);
      };

      return kernel.run.apply(kernel, arguments);
    }
  };

  var shortcut = function shortcut() {
    return _run.apply(kernel, arguments);
  };
  /**
   * Run kernel in async mode
   * @returns {Promise<KernelOutput>}
   */


  shortcut.exec = function () {
    var _this = this,
        _arguments = arguments;

    return new Promise(function (accept, reject) {
      try {
        accept(_run.apply(_this, _arguments));
      } catch (e) {
        reject(e);
      }
    });
  };

  shortcut.replaceKernel = function (replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
    shortcut.kernel = kernel;
  };

  bindKernelToShortcut(kernel, shortcut);
  shortcut.kernel = kernel;
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  var properties = utils.allPropertiesOf(kernel);

  var _loop = function _loop(i) {
    var property = properties[i];
    if (property[0] === '_' && property[1] === '_') return "continue";

    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function () {
          kernel[property].apply(kernel, arguments);
          return shortcut;
        };
      } else {
        if (property === 'toString') {
          shortcut.toString = function () {
            return kernel.toString.apply(kernel, arguments);
          };
        } else {
          shortcut[property] = kernel[property].bind(kernel);
        }
      }
    } else {
      shortcut.__defineGetter__(property, function () {
        return kernel[property];
      });

      shortcut.__defineSetter__(property, function (value) {
        kernel[property] = value;
      });
    }
  };

  for (var i = 0; i < properties.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }
}

module.exports = {
  kernelRunShortcut: kernelRunShortcut
};
},{"./utils":"9h1E"}],"1esj":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var gpuMock = require('gpu-mock.js');

var _require = require('./utils'),
    utils = _require.utils;

var _require2 = require('./backend/cpu/kernel'),
    CPUKernel = _require2.CPUKernel;

var _require3 = require('./backend/headless-gl/kernel'),
    HeadlessGLKernel = _require3.HeadlessGLKernel;

var _require4 = require('./backend/web-gl2/kernel'),
    WebGL2Kernel = _require4.WebGL2Kernel;

var _require5 = require('./backend/web-gl/kernel'),
    WebGLKernel = _require5.WebGLKernel;

var _require6 = require('./kernel-run-shortcut'),
    kernelRunShortcut = _require6.kernelRunShortcut;
/**
 *
 * @type {Kernel[]}
 */


var kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];
/**
 *
 * @type {string[]}
 */

var kernelTypes = ['gpu', 'cpu'];
var internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel
};
var validate = true;
/**
 * The GPU.js library class which manages the GPU context for the creating kernels
 */

var GPU =
/*#__PURE__*/
function () {
  _createClass(GPU, null, [{
    key: "disableValidation",
    value: function disableValidation() {
      validate = false;
    }
  }, {
    key: "enableValidation",
    value: function enableValidation() {
      validate = true;
    }
  }, {
    key: "isGPUSupported",
    get: function get() {
      return kernelOrder.some(function (Kernel) {
        return Kernel.isSupported;
      });
    }
    /**
     *
     * @returns {boolean}
     */

  }, {
    key: "isKernelMapSupported",
    get: function get() {
      return kernelOrder.some(function (Kernel) {
        return Kernel.isSupported && Kernel.features.kernelMap;
      });
    }
    /**
     * @desc TRUE is platform supports OffscreenCanvas
     */

  }, {
    key: "isOffscreenCanvasSupported",
    get: function get() {
      return typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined' || typeof importScripts !== 'undefined';
    }
    /**
     * @desc TRUE if platform supports WebGL
     */

  }, {
    key: "isWebGLSupported",
    get: function get() {
      return WebGLKernel.isSupported;
    }
    /**
     * @desc TRUE if platform supports WebGL2
     */

  }, {
    key: "isWebGL2Supported",
    get: function get() {
      return WebGL2Kernel.isSupported;
    }
    /**
     * @desc TRUE if platform supports HeadlessGL
     */

  }, {
    key: "isHeadlessGLSupported",
    get: function get() {
      return HeadlessGLKernel.isSupported;
    }
    /**
     *
     * @desc TRUE if platform supports Canvas
     */

  }, {
    key: "isCanvasSupported",
    get: function get() {
      return typeof HTMLCanvasElement !== 'undefined';
    }
    /**
     * @desc TRUE if platform supports HTMLImageArray}
     */

  }, {
    key: "isGPUHTMLImageArraySupported",
    get: function get() {
      return WebGL2Kernel.isSupported;
    }
    /**
     * @desc TRUE if platform supports single precision}
     * @returns {boolean}
     */

  }, {
    key: "isSinglePrecisionSupported",
    get: function get() {
      return kernelOrder.some(function (Kernel) {
        return Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat;
      });
    }
    /**
     * Creates an instance of GPU.
     * @param {IGPUSettings} [settings] - Settings to set mode, and other properties
     */

  }]);

  function GPU(settings) {
    _classCallCheck(this, GPU);

    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    if (this.mode === 'dev') return;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.chooseKernel(); // add functions from settings

    if (settings.functions) {
      for (var i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    } // add native functions from settings


    if (settings.nativeFunctions) {
      for (var p in settings.nativeFunctions) {
        this.addNativeFunction(p, settings.nativeFunctions[p]);
      }
    }
  }
  /**
   * Choose kernel type and save on .Kernel property of GPU
   */


  _createClass(GPU, [{
    key: "chooseKernel",
    value: function chooseKernel() {
      if (this.Kernel) return;
      var Kernel = null;

      if (this.context) {
        for (var i = 0; i < kernelOrder.length; i++) {
          var ExternalKernel = kernelOrder[i];

          if (ExternalKernel.isContextMatch(this.context)) {
            if (!ExternalKernel.isSupported) {
              throw new Error("Kernel type ".concat(ExternalKernel.name, " not supported"));
            }

            Kernel = ExternalKernel;
            break;
          }
        }

        if (Kernel === null) {
          throw new Error('unknown Context');
        }
      } else if (this.mode) {
        if (this.mode in internalKernels) {
          if (!validate || internalKernels[this.mode].isSupported) {
            Kernel = internalKernels[this.mode];
          }
        } else if (this.mode === 'gpu') {
          for (var _i = 0; _i < kernelOrder.length; _i++) {
            if (kernelOrder[_i].isSupported) {
              Kernel = kernelOrder[_i];
              break;
            }
          }
        } else if (this.mode === 'cpu') {
          Kernel = CPUKernel;
        }

        if (!Kernel) {
          throw new Error("A requested mode of \"".concat(this.mode, "\" and is not supported"));
        }
      } else {
        for (var _i2 = 0; _i2 < kernelOrder.length; _i2++) {
          if (kernelOrder[_i2].isSupported) {
            Kernel = kernelOrder[_i2];
            break;
          }
        }

        if (!Kernel) {
          Kernel = CPUKernel;
        }
      }

      if (!this.mode) {
        this.mode = Kernel.mode;
      }

      this.Kernel = Kernel;
    }
    /**
     * @desc This creates a callable function object to call the kernel function with the argument parameter set
     * @param {Function|String|object} source - The calling to perform the conversion
     * @param {Object} [settings] - The parameter configuration object
     * @returns {Kernel} callable function to run
     */

  }, {
    key: "createKernel",
    value: function createKernel(source, settings) {
      var _this = this;

      if (typeof source === 'undefined') {
        throw new Error('Missing source parameter');
      }

      if (_typeof(source) !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
        throw new Error('source parameter not a function');
      }

      if (this.mode === 'dev') {
        return gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      }

      source = typeof source === 'function' ? source.toString() : source;
      var switchableKernels = {};
      var settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {}; // handle conversion of argumentTypes

      if (settings && _typeof(settings.argumentTypes) === 'object') {
        settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(function (argumentName) {
          return settings.argumentTypes[argumentName];
        });
      }

      var mergedSettings = Object.assign({
        context: this.context,
        canvas: this.canvas,
        functions: this.functions,
        nativeFunctions: this.nativeFunctions,
        gpu: this,
        validate: validate,
        onRequestFallback: function onRequestFallback(args) {
          var fallbackKernel = new CPUKernel(source, mergedSettings);
          fallbackKernel.build.apply(fallbackKernel, args);
          var result = fallbackKernel.run.apply(fallbackKernel, args);
          kernel.replaceKernel(fallbackKernel);
          return result;
        },
        onRequestSwitchKernel: function onRequestSwitchKernel(args, kernel) {
          var signatureArray = [];

          for (var i = 0; i < args.length; i++) {
            signatureArray.push(utils.getVariableType(args[i]));
          }

          var signature = signatureArray.join(',');
          var existingKernel = switchableKernels[signature];

          if (existingKernel) {
            existingKernel.run.apply(existingKernel, args);

            if (existingKernel.renderKernels) {
              return existingKernel.renderKernels();
            } else {
              return existingKernel.renderOutput();
            }
          }

          var newKernel = switchableKernels[signature] = new _this.Kernel(source, {
            graphical: kernel.graphical,
            constants: kernel.constants,
            context: kernel.context,
            canvas: kernel.canvas,
            output: kernel.output,
            precision: kernel.precision,
            pipeline: kernel.pipeline,
            immutable: kernel.immutable,
            optimizeFloatMemory: kernel.optimizeFloatMemory,
            fixIntegerDivisionAccuracy: kernel.fixIntegerDivisionAccuracy,
            functions: kernel.functions,
            nativeFunctions: kernel.nativeFunctions,
            subKernels: kernel.subKernels,
            strictIntegers: kernel.strictIntegers,
            debug: kernel.debug,
            gpu: _this,
            validate: validate
          });
          newKernel.build.apply(newKernel, args);
          newKernel.run.apply(newKernel, args);

          if (newKernel.renderKernels) {
            return newKernel.renderKernels();
          } else {
            return newKernel.renderOutput();
          }
        }
      }, settingsCopy);
      var kernel = kernelRunShortcut(new this.Kernel(source, mergedSettings)); //if canvas didn't come from this, propagate from kernel

      if (!this.canvas) {
        this.canvas = kernel.canvas;
      } //if context didn't come from this, propagate from kernel


      if (!this.context) {
        this.context = kernel.context;
      }

      this.kernels.push(kernel);
      return kernel;
    }
    /**
     *
     * Create a super kernel which executes sub kernels
     * and saves their output to be used with the next sub kernel.
     * This can be useful if we want to save the output on one kernel,
     * and then use it as an input to another kernel. *Machine Learning*
     *
     * @param {Object|Array} subKernels - Sub kernels for this kernel
     * @param {Function} rootKernel - Root kernel
     *
     * @returns {Function} callable kernel function
     *
     * @example
     * const megaKernel = gpu.createKernelMap({
     *   addResult: function add(a, b) {
     *     return a[this.thread.x] + b[this.thread.x];
     *   },
     *   multiplyResult: function multiply(a, b) {
     *     return a[this.thread.x] * b[this.thread.x];
     *   },
     *  }, function(a, b, c) {
     *       return multiply(add(a, b), c);
     * });
     *
     * megaKernel(a, b, c);
     *
     * Note: You can also define subKernels as an array of functions.
     * > [add, multiply]
     *
     */

  }, {
    key: "createKernelMap",
    value: function createKernelMap() {
      var fn;
      var settings;

      if (typeof arguments[arguments.length - 2] === 'function') {
        fn = arguments[arguments.length - 2];
        settings = arguments[arguments.length - 1];
      } else {
        fn = arguments[arguments.length - 1];
      }

      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error("kernelMap not supported on ".concat(this.Kernel.name));
        }
      }

      var settingsCopy = upgradeDeprecatedCreateKernelSettings(settings); // handle conversion of argumentTypes

      if (settings && _typeof(settings.argumentTypes) === 'object') {
        settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(function (argumentName) {
          return settings.argumentTypes[argumentName];
        });
      }

      if (Array.isArray(arguments[0])) {
        settingsCopy.subKernels = [];
        var functions = arguments[0];

        for (var i = 0; i < functions.length; i++) {
          var source = functions[i].toString();
          var name = utils.getFunctionNameFromString(source);
          settingsCopy.subKernels.push({
            name: name,
            source: source,
            property: i
          });
        }
      } else {
        settingsCopy.subKernels = [];
        var _functions = arguments[0];

        for (var p in _functions) {
          if (!_functions.hasOwnProperty(p)) continue;

          var _source = _functions[p].toString();

          var _name = utils.getFunctionNameFromString(_source);

          settingsCopy.subKernels.push({
            name: _name || p,
            source: _source,
            property: p
          });
        }
      }

      var kernel = this.createKernel(fn, settingsCopy);
      return kernel;
    }
    /**
     *
     * Combine different kernels into one super Kernel,
     * useful to perform multiple operations inside one
     * kernel without the penalty of data transfer between
     * cpu and gpu.
     *
     * The number of kernel functions sent to this method can be variable.
     * You can send in one, two, etc.
     *
     * @param {Function} subKernels - Kernel function(s) to combine.
     * @param {Function} rootKernel - Root kernel to combine kernels into
     *
     * @example
     *   combineKernels(add, multiply, function(a,b,c){
     *     return add(multiply(a,b), c)
     *  })
     *
     * @returns {Function} Callable kernel function
     *
     */

  }, {
    key: "combineKernels",
    value: function combineKernels() {
      var firstKernel = arguments[0];
      var combinedKernel = arguments[arguments.length - 1];
      if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
      var canvas = arguments[0].canvas;
      var context = arguments[0].context;
      var max = arguments.length - 1;

      for (var i = 0; i < max; i++) {
        arguments[i].setCanvas(canvas).setContext(context).setPipeline(true);
      }

      return function () {
        var texture = combinedKernel.apply(this, arguments);

        if (texture.toArray) {
          return texture.toArray();
        }

        return texture;
      };
    }
    /**
     * @desc Adds additional functions, that the kernel may call.
     * @param {Function|String} source - Javascript function to convert
     * @param {IFunctionSettings} [settings]
     * @returns {GPU} returns itself
     */

  }, {
    key: "addFunction",
    value: function addFunction(source, settings) {
      this.functions.push(utils.functionToIFunction(source, settings));
      return this;
    }
    /**
     * @desc Adds additional native functions, that the kernel may call.
     * @param {String} name - native function name, used for reverse lookup
     * @param {String} source - the native function implementation, as it would be defined in it's entirety
     * @param {object} [settings]
     * @returns {GPU} returns itself
     */

  }, {
    key: "addNativeFunction",
    value: function addNativeFunction(name, source, settings) {
      if (this.kernels.length > 0) {
        throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
      }

      settings = settings || {};

      var _ref = this.Kernel.nativeFunctionArguments(source) || {},
          argumentTypes = _ref.argumentTypes,
          argumentNames = _ref.argumentNames;

      this.nativeFunctions.push({
        name: name,
        source: source,
        settings: settings,
        argumentTypes: argumentTypes,
        argumentNames: argumentNames,
        returnType: settings.returnType || this.Kernel.nativeFunctionReturnType(source)
      });
      return this;
    }
    /**
     * @desc Destroys all memory associated with gpu.js & the webGl if we created it
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      // perform on next run loop - for some reason we dont get lose context events
      // if webGl is created and destroyed in the same run loop.
      setTimeout(function () {
        for (var i = 0; i < _this2.kernels.length; i++) {
          _this2.kernels[i].destroy(true); // remove canvas if exists

        }

        _this2.kernels[0].kernel.constructor.destroyContext(_this2.context);
      }, 0);
    }
  }]);

  return GPU;
}();

function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }

  var upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }

  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }

  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }

  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }

  return upgradedSettings;
}

module.exports = {
  GPU: GPU,
  kernelOrder: kernelOrder,
  kernelTypes: kernelTypes
};
},{"gpu-mock.js":"/T23","./utils":"9h1E","./backend/cpu/kernel":"A4bq","./backend/headless-gl/kernel":"5Ni1","./backend/web-gl2/kernel":"sSW8","./backend/web-gl/kernel":"uiFz","./kernel-run-shortcut":"t2wu"}],"209B":[function(require,module,exports) {
var _require = require('./utils'),
    utils = _require.utils;
/**
 *
 * @param name
 * @param source
 * @returns {Function}
 */


function alias(name, source) {
  var fnString = source.toString();
  return new Function("return function ".concat(name, " (").concat(utils.getArgumentNamesFromString(fnString).join(', '), ") {\n  ").concat(utils.getFunctionBodyFromString(fnString), "\n}"))();
}

module.exports = {
  alias: alias
};
},{"./utils":"9h1E"}],"Ft/B":[function(require,module,exports) {
var _require = require('./gpu'),
    GPU = _require.GPU;

var _require2 = require('./alias'),
    alias = _require2.alias;

var _require3 = require('./utils'),
    utils = _require3.utils;

var _require4 = require('./input'),
    Input = _require4.Input,
    input = _require4.input;

var _require5 = require('./texture'),
    Texture = _require5.Texture;

var _require6 = require('./backend/function-builder'),
    FunctionBuilder = _require6.FunctionBuilder;

var _require7 = require('./backend/function-node'),
    FunctionNode = _require7.FunctionNode;

var _require8 = require('./backend/cpu/function-node'),
    CPUFunctionNode = _require8.CPUFunctionNode;

var _require9 = require('./backend/cpu/kernel'),
    CPUKernel = _require9.CPUKernel;

var _require10 = require('./backend/headless-gl/kernel'),
    HeadlessGLKernel = _require10.HeadlessGLKernel;

var _require11 = require('./backend/web-gl/function-node'),
    WebGLFunctionNode = _require11.WebGLFunctionNode;

var _require12 = require('./backend/web-gl/kernel'),
    WebGLKernel = _require12.WebGLKernel;

var _require13 = require('./backend/web-gl2/function-node'),
    WebGL2FunctionNode = _require13.WebGL2FunctionNode;

var _require14 = require('./backend/web-gl2/kernel'),
    WebGL2Kernel = _require14.WebGL2Kernel;

var _require15 = require('./backend/gl/kernel'),
    GLKernel = _require15.GLKernel;

var _require16 = require('./backend/kernel'),
    Kernel = _require16.Kernel;

module.exports = {
  alias: alias,
  CPUFunctionNode: CPUFunctionNode,
  CPUKernel: CPUKernel,
  GPU: GPU,
  FunctionBuilder: FunctionBuilder,
  FunctionNode: FunctionNode,
  HeadlessGLKernel: HeadlessGLKernel,
  Input: Input,
  input: input,
  Texture: Texture,
  utils: utils,
  WebGL2FunctionNode: WebGL2FunctionNode,
  WebGL2Kernel: WebGL2Kernel,
  WebGLFunctionNode: WebGLFunctionNode,
  WebGLKernel: WebGLKernel,
  GLKernel: GLKernel,
  Kernel: Kernel
};
},{"./gpu":"1esj","./alias":"209B","./utils":"9h1E","./input":"ryqg","./texture":"5wk/","./backend/function-builder":"HOQD","./backend/function-node":"oNAw","./backend/cpu/function-node":"JBVu","./backend/cpu/kernel":"A4bq","./backend/headless-gl/kernel":"5Ni1","./backend/web-gl/function-node":"TrAu","./backend/web-gl/kernel":"uiFz","./backend/web-gl2/function-node":"IZrg","./backend/web-gl2/kernel":"sSW8","./backend/gl/kernel":"8fdV","./backend/kernel":"JYjN"}],"L30b":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setup = setup;
exports.teardown = teardown;
exports.makeKernel = makeKernel;
exports.kernelInput = kernelInput;

var _gpu = require('gpu.js');

var gpuInstance = null;

function setup(value) {
  gpuInstance = value;
}

function teardown() {
  gpuInstance = null;
}

function makeKernel(fn, settings) {
  if (gpuInstance === null) {
    setup(new _gpu.GPU({
      mode: 'cpu'
    }));
  }

  if (settings.hasOwnProperty('map')) {
    return gpuInstance.createKernelMap(settings.map, fn, settings).setPipeline(true);
  }

  return gpuInstance.createKernel(fn, settings).setPipeline(true);
}

function kernelInput(input, size) {
  return _gpu.GPU.input(input, size);
}
},{"gpu.js":"Ft/B"}],"M4LY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zeros;

function zeros(size) {
  return new Float32Array(size);
}
},{}],"C4Cz":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zeros2D;

var _zeros = require('./zeros');

var _zeros2 = _interopRequireDefault(_zeros);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function zeros2D(width, height) {
  var result = new Array(height);

  for (var y = 0; y < height; y++) {
    result[y] = (0, _zeros2.default)(width);
  }

  return result;
}
},{"./zeros":"M4LY"}],"0AN3":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zeros3D;

var _zeros2d = require('./zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function zeros3D(width, height, depth) {
  var result = new Array(depth);

  for (var z = 0; z < depth; z++) {
    result[z] = (0, _zeros2d2.default)(width, height);
  }

  return result;
}
},{"./zeros-2d":"C4Cz"}],"kIeX":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Base = function () {
  _createClass(Base, null, [{
    key: 'defaults',
    get: function get() {
      return {
        width: 1,
        height: 1,
        depth: 1,
        weights: null,
        deltas: null,
        name: null
      };
    }
  }]);

  function Base() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Base); // size


    this.width = null;
    this.height = null; // what matters :P

    this.deltas = null;
    this.weights = null;
    this.praxis = null;

    if (this.constructor !== Base) {
      Object.assign(this, Base.defaults, settings);
    }

    Object.assign(this, this.constructor.defaults, settings); // special settings

    if (settings.hasOwnProperty('praxis')) {
      if (typeof settings.praxis === 'function') {
        this.praxis = settings.praxis(Object.assign({
          height: this.height,
          width: this.width
        }, settings));
      } else {
        this.praxis = settings.praxis;
      }
    }
  }
  /*
  get weights() {
    return this._weights;
  }
   set weights(value) {
    if (value) {
      if (value[0].length !== this.width) {
        throw new Error(`${this.constructor.name}.weights being set with improper value width`);
      }
      if (value.length !== this.height) {
        throw new Error(`${this.constructor.name}.weights being set with improper value height`);
      }
    }
    this._weights = value;
  }
   get deltas() {
    return this._deltas;
  }
   set deltas(value) {
    if (value) {
      if (value[0].length !== this.width) {
        throw new Error(`${this.constructor.name}.deltas being set with improper value width`);
      }
      if (value.length !== this.height) {
        throw new Error(`${this.constructor.name}.deltas being set with improper value height`);
      }
    }
    this._deltas = value;
  } */


  _createClass(Base, [{
    key: 'validate',
    value: function validate() {
      if (Number.isNaN(this.height)) {
        throw new Error(this.constructor.name + ' layer height is not a number');
      }

      if (Number.isNaN(this.width)) {
        throw new Error(this.constructor.name + ' layer width is not a number');
      }

      if (this.height < 1) {
        throw new Error(this.constructor.name + ' layer height is less than 1');
      }

      if (this.width < 1) {
        throw new Error(this.constructor.name + ' layer width is less than 1');
      }
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {// console.log(`${this.constructor.name}-setupKernels is not yet implemented`)
    }
  }, {
    key: 'reuseKernels',
    value: function reuseKernels(layer) {
      if (layer.width !== this.width) {
        throw new Error(this.constructor.name + ' kernel width mismatch ' + layer.width + ' is not ' + this.width);
      }

      if (layer.height !== this.height) {
        throw new Error(this.constructor.name + ' kernel width mismatch ' + layer.height + ' is not ' + this.height);
      }

      if (layer.hasOwnProperty('predictKernel')) {
        this.predictKernel = layer.predictKernel;
      }

      if (layer.hasOwnProperty('compareKernel')) {
        this.compareKernel = layer.compareKernel;
      }

      this.praxis = layer.praxis;
    }
  }, {
    key: 'predict',
    value: function predict() {} // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    // eslint-disable-next-line

  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }, {
    key: 'learn',
    value: function learn(previousLayer, nextLayer, learningRate) {
      this.weights = this.praxis.run(this, previousLayer, nextLayer, learningRate); // TODO: put into a kernel

      if (this.depth > 1) {
        this.deltas = (0, _zeros3d2.default)(this.width, this.height, this.depth);
      } else {
        this.deltas = (0, _zeros2d2.default)(this.width, this.height);
      }
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return this.weights.toArray();
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var jsonLayer = {};
      var _constructor = this.constructor,
          defaults = _constructor.defaults,
          name = _constructor.name;

      if (this.constructor !== Base) {
        Object.assign(defaults, Base.defaults, defaults);
      }

      var keys = Object.keys(defaults);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key === 'deltas') continue;
        if (key === 'name' && this[key] === null) continue;
        jsonLayer[key] = this[key];
      }

      jsonLayer.type = name;
      return jsonLayer;
    }
  }]);

  return Base;
}();

exports.default = Base;
},{"../utilities/zeros-2d":"C4Cz","../utilities/zeros-3d":"0AN3"}],"pX1U":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Operator = exports.Modifier = exports.Model = exports.Filter = exports.Internal = exports.Activation = undefined;

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Activation = exports.Activation = function (_Base) {
  _inherits(Activation, _Base);

  function Activation() {
    _classCallCheck(this, Activation);

    return _possibleConstructorReturn(this, (Activation.__proto__ || Object.getPrototypeOf(Activation)).apply(this, arguments));
  }

  return Activation;
}(_base2.default);

var Internal = exports.Internal = function Internal() {
  _classCallCheck(this, Internal);
};

var Filter = exports.Filter = function (_Base2) {
  _inherits(Filter, _Base2);

  function Filter() {
    _classCallCheck(this, Filter);

    return _possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).apply(this, arguments));
  }

  return Filter;
}(_base2.default);

var Model = exports.Model = function (_Base3) {
  _inherits(Model, _Base3);

  function Model() {
    _classCallCheck(this, Model);

    return _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).apply(this, arguments));
  }

  return Model;
}(_base2.default);

var Modifier = exports.Modifier = function (_Base4) {
  _inherits(Modifier, _Base4);

  function Modifier() {
    _classCallCheck(this, Modifier);

    return _possibleConstructorReturn(this, (Modifier.__proto__ || Object.getPrototypeOf(Modifier)).apply(this, arguments));
  }

  return Modifier;
}(_base2.default);

var Operator = exports.Operator = function (_Base5) {
  _inherits(Operator, _Base5);

  function Operator() {
    _classCallCheck(this, Operator);

    return _possibleConstructorReturn(this, (Operator.__proto__ || Object.getPrototypeOf(Operator)).apply(this, arguments));
  }

  return Operator;
}(_base2.default);
},{"./base":"kIeX"}],"q7CK":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

exports.predict = predict;

var _kernel = require('../utilities/kernel');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputWeights1, inputWeights2) {
  return inputWeights1[this.thread.y][this.thread.x] + inputWeights2[this.thread.y][this.thread.x];
}

var Add = function (_Operator) {
  _inherits(Add, _Operator);

  function Add(inputLayer1, inputLayer2) {
    _classCallCheck(this, Add);

    var _this = _possibleConstructorReturn(this, (Add.__proto__ || Object.getPrototypeOf(Add)).call(this));

    _this.inputLayer1 = inputLayer1;
    _this.inputLayer2 = inputLayer2;
    _this.width = _this.inputLayer1.width;
    _this.height = _this.inputLayer1.height;

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Add, [{
    key: 'validate',
    value: function validate() {
      _get(Add.prototype.__proto__ || Object.getPrototypeOf(Add.prototype), 'validate', this).call(this);

      if (this.inputLayer1.width !== this.inputLayer2.width) {
        throw new Error('Layer width mismatch of ' + this.inputLayer1.width + ' and ' + this.inputLayer2.width);
      }

      if (this.inputLayer1.height !== this.inputLayer2.height) {
        throw new Error('Layer height mismatch of ' + this.inputLayer1.height + ' and ' + this.inputLayer2.height);
      }
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
    } // eslint-disable-next-line

  }, {
    key: 'compare',
    value: function compare() {
      this.inputLayer1.deltas = this.deltas;
      this.inputLayer2.deltas = this.deltas;
    }
  }]);

  return Add;
}(_types.Operator);

exports.default = Add;
},{"../utilities/kernel":"L30b","../utilities/zeros-2d":"C4Cz","./types":"pX1U"}],"iz6h":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setStride = setStride;
exports.setPadding = setPadding;

function setStride(layer, settings) {
  var defaults = layer.constructor.defaults;

  if (settings.hasOwnProperty('stride')) {
    layer.strideX = settings.stride;
    layer.strideY = settings.stride;
  } else {
    if (settings.hasOwnProperty('strideX')) {
      layer.strideX = settings.strideX;
    } else {
      layer.strideX = defaults.stride;
    }

    if (settings.hasOwnProperty('strideY')) {
      layer.strideY = settings.strideY;
    } else {
      layer.strideY = defaults.stride;
    }
  }
}

function setPadding(layer, settings) {
  var defaults = layer.constructor.defaults;

  if (settings.hasOwnProperty('padding')) {
    layer.paddingX = settings.padding;
    layer.paddingY = settings.padding;
  } else {
    if (settings.hasOwnProperty('paddingX')) {
      layer.paddingX = settings.paddingX;
    } else {
      layer.paddingX = defaults.padding;
    }

    if (settings.hasOwnProperty('paddingY')) {
      layer.paddingY = settings.paddingY;
    } else {
      layer.paddingY = defaults.padding;
    }
  }
}
},{}],"TX07":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randomWeight;

function randomWeight() {
  return Math.random() * 0.4 - 0.2;
}
},{}],"S8tM":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randos;

var _randomWeight = require('./random-weight');

var _randomWeight2 = _interopRequireDefault(_randomWeight);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function randos(size) {
  var array = new Float32Array(size);

  for (var i = 0; i < size; i++) {
    array[i] = (0, _randomWeight2.default)();
  }

  return array;
}
},{"./random-weight":"TX07"}],"pcuE":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randos2D;

var _randos = require('./randos');

var _randos2 = _interopRequireDefault(_randos);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function randos2D(width, height) {
  var result = new Array(height);

  for (var y = 0; y < height; y++) {
    result[y] = (0, _randos2.default)(width);
  }

  return result;
}
},{"./randos":"S8tM"}],"9TSf":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randos3D;

var _randos2d = require('./randos-2d');

var _randos2d2 = _interopRequireDefault(_randos2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function randos3D(width, height, depth) {
  var result = new Array(depth);

  for (var z = 0; z < depth; z++) {
    result[z] = (0, _randos2d2.default)(width, height);
  }

  return result;
}
},{"./randos-2d":"pcuE"}],"Whlg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = values;

function values(size, value) {
  return new Float32Array(size).fill(value);
}
},{}],"xL0H":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compareFilterDeltas = compareFilterDeltas;
exports.compareInputDeltas = compareInputDeltas;
exports.compareBiases = compareBiases;

var _kernel = require('../utilities/kernel');

var _layerSetup = require('../utilities/layer-setup');

var _types = require('./types');

var _randos = require('../utilities/randos');

var _randos2 = _interopRequireDefault(_randos);

var _randos3d = require('../utilities/randos-3d');

var _randos3d2 = _interopRequireDefault(_randos3d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

var _values = require('../utilities/values');

var _values2 = _interopRequireDefault(_values);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs, filters, biases) {
  var startFilterX = this.constants.paddingX - this.thread.x * this.constants.strideX;
  var startInputX = this.thread.x * this.constants.strideX - this.constants.paddingX;
  var endFilterX = Math.min(this.constants.filterWidth, startFilterX + this.constants.inputWidth);
  var startFilterY = this.constants.paddingY - this.thread.y * this.constants.strideY;
  var startInputY = this.thread.y * this.constants.strideY - this.constants.paddingY;
  var endFilterY = Math.min(this.constants.filterHeight, startFilterY + this.constants.inputHeight);
  var sum = 0;

  for (var z = 0; z < this.constants.inputDepth; z++) {
    for (var filterY = Math.max(0, startFilterY), inputY = Math.max(0, startInputY); filterY < endFilterY; filterY++, inputY++) {
      for (var filterX = Math.max(0, startFilterX), inputX = Math.max(0, startInputX); filterX < endFilterX; filterX++, inputX++) {
        sum += filters[z][filterY][filterX] * inputs[z][inputY][inputX];
      }
    }
  }

  return sum + biases[this.thread.z];
}

function compareFilterDeltas(filterDeltas, inputs, deltas) {
  var startDeltaX = Math.max(0, Math.ceil((this.constants.paddingX - this.thread.x) / this.constants.strideX));
  var startInputX = startDeltaX * this.constants.strideX + this.thread.x - this.constants.paddingX;
  var endDeltaX = Math.min(this.constants.deltaWidth, Math.floor((this.constants.inputWidth - 1 - this.thread.x + this.constants.paddingX) / this.constants.strideX) + 1);
  var startDeltaY = Math.max(0, Math.ceil((this.constants.paddingY - this.thread.y) / this.constants.strideY));
  var startInputY = startDeltaY * this.constants.strideY + this.thread.y - this.constants.paddingY;
  var endDeltaY = Math.min(this.constants.deltaHeight, Math.floor((this.constants.inputHeight - 1 - this.thread.y + this.constants.paddingY) / this.constants.strideY) + 1);
  var sum = filterDeltas[this.thread.z][this.thread.y][this.thread.x];

  for (var deltaY = startDeltaY, inputY = startInputY; deltaY < endDeltaY; deltaY++, inputY += this.constants.strideY) {
    for (var deltaX = startDeltaX, inputX = startInputX; deltaX < endDeltaX; deltaX++, inputX += this.constants.strideX) {
      sum += inputs[this.thread.z][inputY][inputX] * deltas[this.constants.deltaZ][deltaY][deltaX];
    }
  }

  return sum;
}

function compareInputDeltas(inputDeltas, filters, deltas) {
  var x = this.thread.x + this.constants.paddingX;
  var startDeltaX = x < this.constants.filterWidth ? 0 : Math.floor((x - this.constants.filterWidth + this.constants.strideX) / this.constants.strideX);
  var startFilterX = x - startDeltaX * this.constants.strideX;
  var endDeltaX = Math.min(startDeltaX + Math.floor(startFilterX / this.constants.strideX) + 1, this.constants.deltaWidth);
  var y = this.thread.y + this.constants.paddingY;
  var startDeltaY = y < this.constants.filterHeight ? 0 : Math.floor((y - this.constants.filterHeight + this.constants.strideY) / this.constants.strideY);
  var startFilterY = y - startDeltaY * this.constants.strideY;
  var endDeltaY = Math.min(startDeltaY + Math.floor(startFilterY / this.constants.strideY) + 1, this.constants.deltaHeight);
  var sum = inputDeltas[this.thread.z][this.thread.y][this.thread.x];
  var deltaY = startDeltaY;

  for (var filterY = startFilterY; deltaY < endDeltaY; filterY -= this.constants.strideY, deltaY++) {
    var deltaX = startDeltaX;

    for (var filterX = startFilterX; deltaX < endDeltaX; filterX -= this.constants.strideX, deltaX++) {
      sum += filters[this.thread.z][filterY][filterX] * deltas[this.constants.deltaZ][deltaY][deltaX];
    }
  }

  return sum;
}

function compareBiases(biasDeltas, deltas) {
  var sum = 0;

  for (var y = 0; y < this.constants.deltaHeight; y++) {
    for (var x = 0; x < this.constants.deltaWidth; x++) {
      sum += deltas[this.thread.z][y][x];
    }
  }

  return biasDeltas[this.thread.z][this.thread.y][this.thread.x] + sum;
}

var Convolution = function (_Filter) {
  _inherits(Convolution, _Filter);

  _createClass(Convolution, null, [{
    key: 'defaults',
    get: function get() {
      return {
        stride: 0,
        padding: 0,
        bias: 0.1,
        filterCount: 1,
        filterWidth: 0,
        filterHeight: 0
      };
    }
  }]);

  function Convolution(settings, inputLayer) {
    _classCallCheck(this, Convolution);

    var _this = _possibleConstructorReturn(this, (Convolution.__proto__ || Object.getPrototypeOf(Convolution)).call(this, settings));

    _this.stride = null;
    _this.strideX = null;
    _this.strideY = null;
    (0, _layerSetup.setStride)(_this, settings);
    _this.padding = null;
    _this.paddingX = null;
    _this.paddingY = null;
    (0, _layerSetup.setPadding)(_this, settings);
    _this.filterCount = settings.filterCount;
    _this.filterWidth = settings.filterWidth;
    _this.filterHeight = settings.filterHeight;
    _this.width = Math.floor((inputLayer.width + _this.paddingX * 2 - _this.filterWidth) / _this.strideX + 1);
    _this.height = Math.floor((inputLayer.height + _this.paddingY * 2 - _this.filterHeight) / _this.strideY + 1);
    _this.depth = _this.filterCount;
    _this.weights = (0, _randos3d2.default)(_this.width, _this.height, _this.depth);
    _this.deltas = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
    _this.biases = (0, _values2.default)(_this.depth, _this.bias);
    _this.biasDeltas = (0, _randos2.default)(_this.depth);
    _this.filters = (0, _randos3d2.default)(_this.filterWidth, _this.filterHeight, _this.filterCount);
    _this.filterDeltas = (0, _zeros3d2.default)(_this.filterWidth, _this.filterHeight, _this.filterCount);
    _this.learnFilters = null;
    _this.learnInputs = null;
    _this.inputLayer = inputLayer;

    _this.validate();

    return _this;
  }

  _createClass(Convolution, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        constants: {
          inputWidth: this.inputLayer.width,
          inputHeight: this.inputLayer.height,
          inputDepth: this.inputLayer.depth,
          strideX: this.strideX,
          strideY: this.strideY,
          paddingX: this.paddingX,
          paddingY: this.paddingY,
          filterWidth: this.filterWidth,
          filterHeight: this.filterHeight
        },
        output: [this.width, this.height, this.depth]
      });
      this.compareFilterDeltasKernel = (0, _kernel.makeKernel)(compareFilterDeltas, {
        constants: {
          deltasWidth: this.width,
          deltasHeight: this.height,
          deltasDepth: this.depth,
          inputWidth: this.inputLayer.width,
          inputHeight: this.inputLayer.height,
          inputDepth: this.inputLayer.depth,
          strideX: this.strideX,
          strideY: this.strideY,
          paddingX: this.paddingX,
          paddingY: this.paddingY,
          filterWidth: this.filterWidth,
          filterHeight: this.filterHeight
        },
        output: [this.width, this.height, this.depth]
      });
      this.compareInputDeltasKernel = (0, _kernel.makeKernel)(compareInputDeltas, {
        constants: {
          filterCount: this.filterCount
        },
        output: [this.inputLayer.width, this.inputLayer.height, this.inputLayer.depth]
      });
      this.compareBiasesKernel = (0, _kernel.makeKernel)(compareBiases, {
        output: [1, 1, this.depth],
        constants: {
          deltaWidth: this.width,
          deltaHeight: this.height
        }
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.filterDeltas = this.compareFilterDeltasKernel(this.filterDeltas, this.inputLayer.weights, this.deltas);
      this.biasDeltas = this.compareBiasesKernel(this.biasDeltas, this.deltas);
      this.deltas = this.compareInputDeltasKernel(this.filters, this.inputLayer.deltas);
      this.inputLayer.deltas = this.deltas;
    }
  }, {
    key: 'learn',
    value: function learn(previousLayer, nextLayer, learningRate) {
      // TODO: handle filters
      this.weights = this.praxis.run(this, previousLayer, nextLayer, learningRate);
      this.deltas = (0, _zeros3d2.default)(this.width, this.height, this.depth);
    }
  }]);

  return Convolution;
}(_types.Filter);

exports.default = Convolution;
},{"../utilities/kernel":"L30b","../utilities/layer-setup":"iz6h","./types":"pX1U","../utilities/randos":"S8tM","../utilities/randos-3d":"9TSf","../utilities/zeros-3d":"0AN3","../utilities/values":"Whlg"}],"YwJF":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.trainingPredict = trainingPredict;
exports.predict = predict;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // TODO: implement random in glsl in gpu.js


function trainingPredict(inputs) {
  if (Math.random() < this.constants.probability) {
    return 0;
  }

  return inputs[this.thread.y][this.thread.x];
}

function predict(inputs) {
  return inputs[this.thread.y][this.thread.x] * this.constants.probability;
}

var Dropout = function (_Filter) {
  _inherits(Dropout, _Filter);

  _createClass(Dropout, null, [{
    key: 'defaults',
    get: function get() {
      return {
        width: 0,
        height: 0,
        depth: 0,
        probability: 0.5,
        isTraining: false
      };
    }
  }]);

  function Dropout(settings, inputLayer) {
    _classCallCheck(this, Dropout);

    var _this = _possibleConstructorReturn(this, (Dropout.__proto__ || Object.getPrototypeOf(Dropout)).call(this, settings));

    _this.inputLayer = inputLayer;

    _this.validate();

    return _this;
  }

  _createClass(Dropout, [{
    key: 'setupKernels',
    value: function setupKernels() {
      if (this.isTraining) {
        this.predictKernel = (0, _kernel.makeKernel)(trainingPredict, {
          output: [this.width, this.height, this.depth]
        });
      } else {
        this.predictKernel = (0, _kernel.makeKernel)(predict, {
          output: [this.width, this.height, this.depth]
        });
      }
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.deltas = this.learnKernel(this.deltas);
    }
  }]);

  return Dropout;
}(_types.Filter);

exports.default = Dropout;
},{"./types":"pX1U","../utilities/kernel":"L30b"}],"Aqg2":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.predict3D = predict3D;
exports.compareInputDeltas = compareInputDeltas;
exports.compareInputDeltas3D = compareInputDeltas3D;
exports.compareBiases = compareBiases;
exports.compareFilterDeltas = compareFilterDeltas;
exports.compareFilterDeltas3D = compareFilterDeltas3D;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _values = require('../utilities/values');

var _values2 = _interopRequireDefault(_values);

var _randos2d = require('../utilities/randos-2d');

var _randos2d2 = _interopRequireDefault(_randos2d);

var _randos3d = require('../utilities/randos-3d');

var _randos3d2 = _interopRequireDefault(_randos3d);

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs, filters, biases) {
  var output = 0;
  var i = 0;

  for (var y = 0; y < this.constants.inputHeight; y++) {
    for (var x = 0; x < this.constants.inputWidth; x++) {
      output += inputs[y][x] * filters[this.thread.x][i];
      i++;
    }
  }

  return output + biases[this.thread.x];
}

function predict3D(inputs, filters, biases) {
  var output = 0;
  var i = 0;

  for (var z = 0; z < this.constants.inputDepth; z++) {
    for (var y = 0; y < this.constants.inputHeight; y++) {
      for (var x = 0; x < this.constants.inputWidth; x++) {
        output += inputs[z][y][x] * filters[this.thread.x][i];
        i++;
      }
    }
  }

  return output + biases[this.thread.x];
}

function compareInputDeltas(inputDeltas, deltas, filters) {
  var sum = 0;
  var filterX = this.thread.x + this.thread.y * this.output.x;

  for (var filterY = 0; filterY < this.constants.filterCount; filterY++) {
    sum += filters[filterY][filterX] * deltas[0][filterY];
  }

  return sum + inputDeltas[this.thread.y][this.thread.x];
}

function compareInputDeltas3D(inputDeltas, deltas, filters) {
  var sum = 0;
  var filterX = this.thread.x + this.thread.y * this.output.x;

  for (var filterY = 0; filterY < this.constants.filterCount; filterY++) {
    sum += filters[filterY][filterX] * deltas[0][filterY];
  }

  return sum + inputDeltas[this.thread.z][this.thread.y][this.thread.x];
}

function compareBiases(biases, deltas) {
  return biases[this.thread.x] + deltas[this.thread.y][this.thread.x];
}

function compareFilterDeltas(filterDeltas, inputWeights, deltas) {
  return filterDeltas[this.thread.y][this.thread.x] + inputWeights[this.thread.y][this.thread.x] * deltas[this.constants.deltaY][this.constants.deltaX];
}

function compareFilterDeltas3D(filterDeltas, inputWeights, deltas) {
  var inputZ = Math.floor(this.thread.x / (this.constants.inputWidth * this.constants.inputHeight));
  var inputY = Math.floor((this.thread.x - inputZ * this.constants.inputWidth * this.constants.inputHeight) / this.constants.inputWidth);
  var inputX = this.thread.x - this.constants.inputWidth * (inputY + this.constants.inputHeight * inputZ);
  return filterDeltas[this.thread.y][this.thread.x] + inputWeights[inputZ][inputY][inputX] * deltas[0][this.thread.y];
}

var FullyConnected = function (_Filter) {
  _inherits(FullyConnected, _Filter);

  _createClass(FullyConnected, null, [{
    key: 'defaults',
    get: function get() {
      return {
        bias: 0.1
      };
    }
  }]);

  function FullyConnected(settings, inputLayer) {
    _classCallCheck(this, FullyConnected);

    var _this = _possibleConstructorReturn(this, (FullyConnected.__proto__ || Object.getPrototypeOf(FullyConnected)).call(this, settings));

    _this.inputLayer = inputLayer;

    _this.validate();

    _this.compareFilterDeltasKernel = null;
    _this.compareInputDeltasKernel = null;
    _this.compareBiasesKernel = null;
    var connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;
    _this.biases = (0, _values2.default)(_this.height, _this.bias);
    _this.biasDeltas = (0, _zeros2.default)(_this.height);
    _this.filters = (0, _randos2d2.default)(connectionCount, _this.height);
    _this.filterDeltas = (0, _zeros2d2.default)(connectionCount, _this.height);

    if (_this.depth > 1) {
      _this.weights = (0, _randos3d2.default)(_this.width, _this.height);
      _this.deltas = (0, _zeros3d2.default)(_this.width, _this.height);
    } else if (_this.height > 1) {
      _this.weights = (0, _randos2d2.default)(_this.width, _this.height);
      _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    }

    return _this;
  }

  _createClass(FullyConnected, [{
    key: 'validate',
    value: function validate() {
      _get(FullyConnected.prototype.__proto__ || Object.getPrototypeOf(FullyConnected.prototype), 'validate', this).call(this);

      if (this.depth > 1) throw new Error('depth not supported');
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {
      var inputLayer = this.inputLayer;
      var connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;

      if (inputLayer.depth > 1) {
        this.predictKernel = (0, _kernel.makeKernel)(predict3D, {
          output: [this.width, this.height],
          constants: {
            inputHeight: inputLayer.height,
            inputWidth: inputLayer.width,
            inputDepth: inputLayer.depth
          }
        });
        this.compareFilterDeltasKernel = (0, _kernel.makeKernel)(compareFilterDeltas3D, {
          output: [connectionCount, this.height],
          constants: {
            inputWidth: inputLayer.width,
            inputHeight: inputLayer.height
          }
        });
        this.compareInputDeltasKernel = (0, _kernel.makeKernel)(compareInputDeltas3D, {
          output: [inputLayer.width, inputLayer.height, inputLayer.depth],
          constants: {
            filterCount: this.height
          }
        });
      } else {
        this.predictKernel = (0, _kernel.makeKernel)(predict, {
          output: [this.width, this.height],
          constants: {
            inputHeight: inputLayer.height,
            inputWidth: inputLayer.width
          }
        });
        this.compareFilterDeltasKernel = (0, _kernel.makeKernel)(compareFilterDeltas, {
          output: [connectionCount, this.height],
          constants: {
            inputWidth: inputLayer.width
          }
        });
        this.compareInputDeltasKernel = (0, _kernel.makeKernel)(compareInputDeltas, {
          output: [inputLayer.width, inputLayer.height],
          constants: {
            filterCount: this.height
          }
        });
      }

      this.compareBiasesKernel = (0, _kernel.makeKernel)(compareBiases, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.inputLayer.deltas = this.compareInputDeltasKernel(this.inputLayer.deltas, this.deltas, this.filters); // TODO: handle biasDeltas learn

      this.biasDeltas = this.compareBiasesKernel(this.biases, this.deltas); // TODO: handle filterDeltas learn

      this.filterDeltas = this.compareFilterDeltasKernel(this.filterDeltas, this.inputLayer.weights, this.deltas);
    }
  }]);

  return FullyConnected;
}(_types.Filter);

exports.default = FullyConnected;
},{"./types":"pX1U","../utilities/kernel":"L30b","../utilities/values":"Whlg","../utilities/randos-2d":"pcuE","../utilities/randos-3d":"9TSf","../utilities/zeros":"M4LY","../utilities/zeros-2d":"C4Cz","../utilities/zeros-3d":"0AN3"}],"qUrb":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _types = require('./types');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _kernel = require('../utilities/kernel');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Input = function (_Model) {
  _inherits(Input, _Model);

  function Input(settings) {
    _classCallCheck(this, Input);

    var _this = _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, settings));

    if (_this.width === 1) {
      _this.predict = _this.predict1D;
    }

    _this.validate();

    _this.weights = null;
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Input, [{
    key: 'setupKernels',
    value: function setupKernels() {}
  }, {
    key: 'predict',
    value: function predict(inputs) {
      if (inputs.length === this.height * this.width) {
        this.weights = (0, _kernel.kernelInput)(inputs, [this.width, this.height]);
      } else if (inputs.length === this.height && inputs[0].length === this.width) {
        this.weights = inputs;
      } else {
        throw new Error('Inputs are not of sized correctly');
      }
    }
  }, {
    key: 'predict1D',
    value: function predict1D(inputs) {
      var weights = [];

      for (var x = 0; x < inputs.length; x++) {
        weights.push([inputs[x]]);
      }

      this.weights = weights;
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }, {
    key: 'learn',
    value: function learn() {
      this.deltas = (0, _zeros2d2.default)(this.width, this.height);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var jsonLayer = {};
      var _constructor = this.constructor,
          defaults = _constructor.defaults,
          name = _constructor.name;
      var keys = Object.keys(defaults);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key === 'deltas' || key === 'weights') continue;
        jsonLayer[key] = this[key];
      }

      jsonLayer.type = name;
      return jsonLayer;
    }
  }]);

  return Input;
}(_types.Model);

exports.default = Input;
},{"./types":"pX1U","../utilities/zeros-2d":"C4Cz","../utilities/kernel":"L30b"}],"JZX2":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compare = compare;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _leakyRelu = require('../activation/leaky-relu');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs) {
  return (0, _leakyRelu.activate)(inputs[this.thread.y][this.thread.x]);
}

function compare(weights, deltas) {
  return (0, _leakyRelu.measure)(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
}

var LeakyRelu = function (_Activation) {
  _inherits(LeakyRelu, _Activation);

  function LeakyRelu(inputLayer) {
    _classCallCheck(this, LeakyRelu);

    var _this = _possibleConstructorReturn(this, (LeakyRelu.__proto__ || Object.getPrototypeOf(LeakyRelu)).call(this));

    _this.inputLayer = inputLayer;
    var width = inputLayer.width,
        height = inputLayer.height,
        depth = inputLayer.depth;
    _this.width = width;
    _this.height = height;
    _this.depth = depth;

    _this.validate();

    return _this;
  }

  _createClass(LeakyRelu, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        functions: [_leakyRelu.activate]
      });
      this.compareKernel = (0, _kernel.makeKernel)(compare, {
        functions: [_leakyRelu.measure]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.deltas = this.compareKernel(this.weights, this.deltas);
    }
  }]);

  return LeakyRelu;
}(_types.Activation);

exports.default = LeakyRelu;
},{"./types":"pX1U","../utilities/kernel":"L30b","../activation/leaky-relu":"4I3O"}],"xJEq":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

exports.predict = predict;
exports.compareFromX = compareFromX;
exports.compareFromY = compareFromY;

var _kernel = require('../utilities/kernel');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(weights1, weights2) {
  var sum = 0;

  for (var i = 0; i < this.constants.size; i++) {
    sum += weights1[this.thread.y][i] * weights2[i][this.thread.x];
  }

  return sum;
}

function compareFromX(deltas, inputDeltas, inputWeights) {
  var sum = inputDeltas[this.thread.y][this.thread.x];

  for (var i = 0; i < this.constants.size; i++) {
    sum += deltas[this.thread.y][i] * inputWeights[this.thread.x][i];
  }

  return sum;
}

function compareFromY(deltas, inputDeltas, inputWeights) {
  var sum = inputDeltas[this.thread.y][this.thread.x];

  for (var i = 0; i < this.constants.size; i++) {
    sum += deltas[i][this.thread.x] * inputWeights[i][this.thread.y];
  }

  return sum;
}

var Multiply = function (_Operator) {
  _inherits(Multiply, _Operator);

  function Multiply(inputLayer1, inputLayer2) {
    _classCallCheck(this, Multiply);

    var _this = _possibleConstructorReturn(this, (Multiply.__proto__ || Object.getPrototypeOf(Multiply)).call(this));

    _this.inputLayer1 = inputLayer1;
    _this.inputLayer2 = inputLayer2;
    _this.compareKernel1 = null;
    _this.compareKernel2 = null;
    _this.width = inputLayer2.width;
    _this.height = inputLayer1.height;

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Multiply, [{
    key: 'validate',
    value: function validate() {
      _get(Multiply.prototype.__proto__ || Object.getPrototypeOf(Multiply.prototype), 'validate', this).call(this);

      if (this.inputLayer1.width !== this.inputLayer2.height) {
        throw new Error('Layer width mismatch of ' + this.inputLayer1.width + ' and ' + this.inputLayer2.height);
      }
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height],
        constants: {
          size: this.inputLayer2.height
        }
      });
      this.compareKernel1 = (0, _kernel.makeKernel)(compareFromX, {
        output: [this.inputLayer1.width, this.inputLayer1.height],
        constants: {
          size: this.inputLayer2.width
        }
      });
      this.compareKernel2 = (0, _kernel.makeKernel)(compareFromY, {
        output: [this.inputLayer2.width, this.inputLayer2.height],
        constants: {
          size: this.inputLayer1.height
        }
      });
    }
  }, {
    key: 'reuseKernels',
    value: function reuseKernels(layer) {
      _get(Multiply.prototype.__proto__ || Object.getPrototypeOf(Multiply.prototype), 'reuseKernels', this).call(this, layer);

      this.compareKernel1 = layer.compareKernel1;
      this.compareKernel2 = layer.compareKernel2;
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      var newDeltas1 = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights);
      var newDeltas2 = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);
      this.inputLayer2.deltas = newDeltas2;
      this.inputLayer1.deltas = newDeltas1;
    }
  }]);

  return Multiply;
}(_types.Operator);

exports.default = Multiply;
},{"../utilities/kernel":"L30b","../utilities/zeros-2d":"C4Cz","./types":"pX1U"}],"vjFV":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var _kernel = require('../utilities/kernel');

var _types = require('./types');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(weights, inputLayerWeights) {
  return weights[this.thread.y][this.thread.x] * inputLayerWeights[this.thread.y][this.thread.x];
}

function compare(weights, deltas) {
  return weights[this.thread.y][this.thread.x] * deltas[this.thread.y][this.thread.x];
}

var MultiplyElement = function (_Operator) {
  _inherits(MultiplyElement, _Operator);

  function MultiplyElement(inputLayer1, inputLayer2) {
    _classCallCheck(this, MultiplyElement);

    var _this = _possibleConstructorReturn(this, (MultiplyElement.__proto__ || Object.getPrototypeOf(MultiplyElement)).call(this));

    _this.inputLayer1 = inputLayer1;
    _this.inputLayer2 = inputLayer2;
    _this.width = inputLayer1.width;
    _this.height = inputLayer1.height;

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(MultiplyElement, [{
    key: 'validate',
    value: function validate() {
      _get(MultiplyElement.prototype.__proto__ || Object.getPrototypeOf(MultiplyElement.prototype), 'validate', this).call(this);

      if (this.inputLayer1.width !== this.inputLayer2.width) {
        throw new Error('Layer width mismatch of ' + this.inputLayer1.width + ' and ' + this.inputLayer2.width);
      }

      if (this.inputLayer1.height !== this.inputLayer2.height) {
        throw new Error('Layer height mismatch of ' + this.inputLayer1.height + ' and ' + this.inputLayer2.height);
      }
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height]
      });
      this.compareKernel = (0, _kernel.makeKernel)(compare, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.weights, this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.deltas = this.compareKernel(this.weights, this.deltas);
    }
  }]);

  return MultiplyElement;
}(_types.Operator);

exports.default = MultiplyElement;
},{"../utilities/kernel":"L30b","./types":"pX1U","../utilities/zeros-2d":"C4Cz"}],"kuo+":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _kernel = require('../utilities/kernel');

var _types = require('./types');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(weights) {
  return -weights[this.thread.y][this.thread.x];
}

var Negative = function (_Modifier) {
  _inherits(Negative, _Modifier);

  function Negative(settings, inputLayer) {
    _classCallCheck(this, Negative);

    var _this = _possibleConstructorReturn(this, (Negative.__proto__ || Object.getPrototypeOf(Negative)).call(this, settings));

    _this.inputLayer = inputLayer;

    _this.validate();

    return _this;
  }

  _createClass(Negative, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }]);

  return Negative;
}(_types.Modifier);

exports.default = Negative;
},{"../utilities/kernel":"L30b","./types":"pX1U"}],"f7P8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ones;

function ones(size) {
  return new Float32Array(size).fill(1);
}
},{}],"jZTY":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ones2D;

var _ones = require('./ones');

var _ones2 = _interopRequireDefault(_ones);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function ones2D(width, height) {
  var result = new Array(height);

  for (var y = 0; y < height; y++) {
    result[y] = (0, _ones2.default)(width);
  }

  return result;
}
},{"./ones":"f7P8"}],"0122":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ones2d = require('../utilities/ones-2d');

var _ones2d2 = _interopRequireDefault(_ones2d);

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Ones = function (_Model) {
  _inherits(Ones, _Model);

  function Ones(settings) {
    _classCallCheck(this, Ones);

    var _this = _possibleConstructorReturn(this, (Ones.__proto__ || Object.getPrototypeOf(Ones)).call(this, settings));

    _this.validate();

    _this.weights = (0, _ones2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  return Ones;
}(_types.Model);

exports.default = Ones;
},{"../utilities/ones-2d":"jZTY","../utilities/zeros-2d":"C4Cz","./types":"pX1U"}],"vNYh":[function(require,module,exports) {
'use strict';

var _typeof2 = typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol" ? function (obj) { return _typeof3(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj); };

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compare = compare;
exports.compare3D = compare3D;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _layerSetup = require('../utilities/layer-setup');

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

var _randos3d = require('../utilities/randos-3d');

var _randos3d2 = _interopRequireDefault(_randos3d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function setSwitchY(value) {
  return value;
}

function setSwitchX(value) {
  return value;
}

function predict(inputs) {
  var x = Math.floor(this.thread.x / this.output.x * this.constants.inputWidth - this.constants.paddingX);
  var y = Math.floor(this.thread.y / this.output.y * this.constants.inputHeight - this.constants.paddingY);
  var largestValue = -Infinity;
  var largestX = -1;
  var largestY = -1; // convolve centered at this particular location

  for (var filterY = 0; filterY < this.constants.filterHeight; filterY++) {
    // coordinates in the original input array coordinates
    var inputY = filterY + y;

    for (var filterX = 0; filterX < this.constants.filterWidth; filterX++) {
      var inputX = filterX + x;

      if (inputY >= 0 && inputY < this.constants.inputHeight && inputX >= 0 && inputX < this.constants.inputWidth) {
        var input = inputs[this.thread.z][inputY][inputX];

        if (input > largestValue) {
          largestValue = input;
          largestY = inputY;
          largestX = inputX;
        }
      }
    }
  }

  setSwitchY(largestY);
  setSwitchX(largestX);
  return largestValue;
}

function compare(deltas, switchY, switchX) {
  var x = Math.floor(this.thread.x / this.output.x * this.constants.outputWidth);
  var y = Math.floor(this.thread.y / this.output.y * this.constants.outputHeight);
  var value = 0;

  for (var deltasY = 0; deltasY < this.constants.inputHeight; deltasY++) {
    for (var deltasX = 0; deltasX < this.constants.inputWidth; deltasX++) {
      var switchXValue = switchX[deltasY][deltasX];
      var switchYValue = switchY[deltasY][deltasX];

      if (switchXValue === x && switchYValue === y) {
        value += deltas[deltasY][deltasX];
      }
    }
  }

  return value;
}

function compare3D(deltas, switchY, switchX) {
  var x = Math.floor(this.thread.x / this.output.x * this.constants.outputWidth);
  var y = Math.floor(this.thread.y / this.output.y * this.constants.outputHeight);
  var value = 0;

  for (var deltasY = 0; deltasY < this.constants.inputHeight; deltasY++) {
    for (var deltasX = 0; deltasX < this.constants.inputWidth; deltasX++) {
      var switchXValue = switchX[this.thread.z][deltasY][deltasX];
      var switchYValue = switchY[this.thread.z][deltasY][deltasX];

      if (switchXValue === x && switchYValue === y) {
        value += deltas[this.thread.z][deltasY][deltasX];
      }
    }
  }

  return value;
}

var Pool = function (_Filter) {
  _inherits(Pool, _Filter);

  _createClass(Pool, null, [{
    key: 'defaults',
    get: function get() {
      return {
        padding: 0,
        bias: 0,
        filterWidth: 0,
        filterHeight: 0,
        filterCount: 0
      };
    }
  }]);

  function Pool(settings, inputLayer) {
    _classCallCheck(this, Pool);

    var _this = _possibleConstructorReturn(this, (Pool.__proto__ || Object.getPrototypeOf(Pool)).call(this, settings));

    _this.stride = null;
    _this.strideX = null;
    _this.strideY = null;
    (0, _layerSetup.setStride)(_this, settings);
    _this.padding = null;
    _this.paddingX = null;
    _this.paddingY = null;
    (0, _layerSetup.setPadding)(_this, settings);
    _this.filterCount = settings.filterCount;
    _this.filterWidth = settings.filterWidth;
    _this.filterHeight = settings.filterHeight;
    _this.width = Math.floor((inputLayer.width + _this.paddingX * 2 - _this.filterWidth) / _this.strideX + 1);
    _this.height = Math.floor((inputLayer.height + _this.paddingY * 2 - _this.filterHeight) / _this.strideY + 1); // TODO: handle 1 depth?

    _this.depth = _this.filterCount;
    _this.weights = (0, _randos3d2.default)(_this.width, _this.height, _this.depth);
    _this.deltas = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
    _this.filters = (0, _randos3d2.default)(_this.filterWidth, _this.filterHeight, _this.filterCount);
    _this.filterDeltas = (0, _zeros3d2.default)(_this.filterWidth, _this.filterHeight, _this.filterCount);
    _this.learnFilters = null;
    _this.learnInputs = null;
    _this.inputLayer = inputLayer;

    _this.validate();

    return _this;
  }

  _createClass(Pool, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height, this.depth],
        map: {
          switchX: setSwitchX,
          switchY: setSwitchY
        },
        constants: {
          inputWidth: this.inputLayer.width,
          inputHeight: this.inputLayer.height,
          paddingX: this.paddingX,
          paddingY: this.paddingY,
          filterHeight: this.filterHeight,
          filterWidth: this.filterWidth
        }
      });
      this.compareKernel = (0, _kernel.makeKernel)(compare, {
        output: [this.inputLayer.width, this.inputLayer.height, this.inputLayer.depth],
        constants: {
          outputWidth: this.width,
          outputHeight: this.height,
          outputDepth: this.depth,
          paddingX: this.paddingX,
          paddingY: this.paddingY
        }
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      var weights = this.predictKernel(this.inputLayer.weights);
      this.switchX = weights.switchX;
      this.switchY = weights.switchY;
      this.weights = weights.result;
      return this.weights;
    }
  }, {
    key: 'compare',
    value: function compare() {
      debugger;
      var depth = this.inputLayer.deltas.length;
      var height = this.inputLayer.deltas[0].length;
      var width = this.inputLayer.deltas[0][0].length;

      var type = _typeof(this.inputLayer.deltas[0][0][0]);

      this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY);
      debugger;
      if (depth !== this.inputLayer.deltas.length) debugger;
      if (height !== this.inputLayer.deltas[0].length) debugger;
      if (width !== this.inputLayer.deltas[0][0].length) debugger;
      if (type !== _typeof(this.inputLayer.deltas[0][0][0])) debugger;
    }
  }]);

  return Pool;
}(_types.Filter);

exports.default = Pool;
},{"./types":"pX1U","../utilities/kernel":"L30b","../utilities/layer-setup":"iz6h","../utilities/zeros-3d":"0AN3","../utilities/randos-3d":"9TSf"}],"yQCp":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _types = require('./types');

var _randos2d = require('../utilities/randos-2d');

var _randos2d2 = _interopRequireDefault(_randos2d);

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Random = function (_Model) {
  _inherits(Random, _Model);

  function Random(settings) {
    _classCallCheck(this, Random);

    var _this = _possibleConstructorReturn(this, (Random.__proto__ || Object.getPrototypeOf(Random)).call(this, settings));

    _this.validate();

    _this.weights = (0, _randos2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Random, [{
    key: 'predict',
    value: function predict() {// throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }]);

  return Random;
}(_types.Model);

exports.default = Random;
},{"./types":"pX1U","../utilities/randos-2d":"pcuE","../utilities/zeros-2d":"C4Cz"}],"viPg":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Regression = function (_Base) {
  _inherits(Regression, _Base);

  function Regression(settings) {
    _classCallCheck(this, Regression);

    var _this = _possibleConstructorReturn(this, (Regression.__proto__ || Object.getPrototypeOf(Regression)).call(this, settings));

    _this.validate();

    return _this;
  }

  _createClass(Regression, [{
    key: 'predict',
    value: function predict() {
      this.weights = this.inputs;
    }
  }, {
    key: 'learn',
    value: function learn() {// throw new Error(`${this.constructor.name}-learn is not yet implemented`)
    }
  }]);

  return Regression;
}(_base2.default);

exports.default = Regression;

function learn(inputs, targets) {
  return inputs[this.thread.x] - targets[this.thread.x];
} // TODO: handle `loss += 0.5*dy*dy;` total and sum in learn
},{"./base":"kIeX"}],"BjPp":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compare = compare;
exports.predict3D = predict3D;
exports.compare3D = compare3D;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _relu = require('../activation/relu');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs) {
  return (0, _relu.activate)(inputs[this.thread.y][this.thread.x]);
}

function compare(weights, deltas) {
  return (0, _relu.measure)(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
}

function predict3D(inputs) {
  return (0, _relu.activate)(inputs[this.thread.z][this.thread.y][this.thread.x]);
}

function compare3D(weights, deltas) {
  return (0, _relu.measure)(weights[this.thread.z][this.thread.y][this.thread.x], deltas[this.thread.z][this.thread.y][this.thread.x]);
}

var Relu = function (_Activation) {
  _inherits(Relu, _Activation);

  function Relu(inputLayer) {
    _classCallCheck(this, Relu);

    var _this = _possibleConstructorReturn(this, (Relu.__proto__ || Object.getPrototypeOf(Relu)).call(this));

    _this.inputLayer = inputLayer;
    var width = inputLayer.width,
        height = inputLayer.height,
        depth = inputLayer.depth;
    _this.width = width;
    _this.height = height;

    _this.validate();

    if (depth > 1) {
      _this.depth = depth;
      _this.weights = (0, _zeros3d2.default)(width, height, depth);
      _this.deltas = (0, _zeros3d2.default)(width, height, depth);
    } else {
      _this.depth = 1;
      _this.weights = (0, _zeros2d2.default)(width, height);
      _this.deltas = (0, _zeros2d2.default)(width, height);
    }

    return _this;
  }

  _createClass(Relu, [{
    key: 'setupKernels',
    value: function setupKernels() {
      var _inputLayer = this.inputLayer,
          width = _inputLayer.width,
          height = _inputLayer.height,
          depth = _inputLayer.depth;

      if (this.depth > 1) {
        this.predictKernel = (0, _kernel.makeKernel)(predict3D, {
          output: [width, height, depth],
          functions: [_relu.activate]
        });
        this.compareKernel = (0, _kernel.makeKernel)(compare3D, {
          output: [width, height, depth],
          functions: [_relu.measure]
        });
      } else {
        this.predictKernel = (0, _kernel.makeKernel)(predict, {
          output: [width, height],
          functions: [_relu.activate]
        });
        this.compareKernel = (0, _kernel.makeKernel)(compare, {
          output: [width, height],
          functions: [_relu.measure]
        });
      }
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
    }
  }]);

  return Relu;
}(_types.Activation);

exports.default = Relu;
},{"./types":"pX1U","../utilities/kernel":"L30b","../activation/relu":"kBu/","../utilities/zeros-2d":"C4Cz","../utilities/zeros-3d":"0AN3"}],"ED1E":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compare = compare;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _sigmoid = require('../activation/sigmoid');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs) {
  return (0, _sigmoid.activate)(inputs[this.thread.y][this.thread.x]);
}

function compare(weights, deltas) {
  var weight = weights[this.thread.y][this.thread.x];
  var delta = deltas[this.thread.y][this.thread.x];
  return (0, _sigmoid.measure)(weight, delta);
}

var Sigmoid = function (_Activation) {
  _inherits(Sigmoid, _Activation);

  function Sigmoid(inputLayer) {
    _classCallCheck(this, Sigmoid);

    var _this = _possibleConstructorReturn(this, (Sigmoid.__proto__ || Object.getPrototypeOf(Sigmoid)).call(this));

    _this.inputLayer = inputLayer;
    var width = inputLayer.width,
        height = inputLayer.height;
    _this.width = width;
    _this.height = height;

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Sigmoid, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height],
        functions: [_sigmoid.activate]
      });
      this.compareKernel = (0, _kernel.makeKernel)(compare, {
        output: [this.width, this.height],
        functions: [_sigmoid.measure]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
    }
  }]);

  return Sigmoid;
}(_types.Activation);

exports.default = Sigmoid;
},{"./types":"pX1U","../utilities/kernel":"L30b","../activation/sigmoid":"thFH","../utilities/zeros-2d":"C4Cz"}],"nfIB":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.getMaxValue = getMaxValue;
exports.getMaxValue2D = getMaxValue2D;
exports.getMaxValue3D = getMaxValue3D;
exports.getSum = getSum;
exports.getSum2D = getSum2D;
exports.getSum3D = getSum3D;
exports.getExponentials = getExponentials;
exports.getExponentials2D = getExponentials2D;
exports.getExponentials3D = getExponentials3D;
exports.predict = predict;
exports.predict2D = predict2D;
exports.predict3D = predict3D;
exports.compare = compare;
exports.compare2D = compare2D;
exports.compare3D = compare3D;
exports.loss = loss;

var _kernel = require('../utilities/kernel');

var _types = require('./types');

var _randos = require('../utilities/randos');

var _randos2 = _interopRequireDefault(_randos);

var _randos2d = require('../utilities/randos-2d');

var _randos2d2 = _interopRequireDefault(_randos2d);

var _randos3d = require('../utilities/randos-3d');

var _randos3d2 = _interopRequireDefault(_randos3d);

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function getMaxValue(inputs) {
  var maxInput = -Infinity;

  for (var x = 0; x < this.constants.inputWidth; x++) {
    var input = inputs[x];

    if (input > maxInput) {
      maxInput = input;
    }
  }

  return maxInput;
}

function getMaxValue2D(inputs) {
  var maxInput = -Infinity;

  for (var y = 0; y < this.constants.inputHeight; y++) {
    for (var x = 0; x < this.constants.inputWidth; x++) {
      var input = inputs[y][x];

      if (input > maxInput) {
        maxInput = input;
      }
    }
  }

  return maxInput;
}

function getMaxValue3D(inputs) {
  var maxInput = -Infinity;

  for (var z = 0; z < this.constants.inputDepth; z++) {
    for (var y = 0; y < this.constants.inputHeight; y++) {
      for (var x = 0; x < this.constants.inputWidth; x++) {
        var input = inputs[z][y][x];

        if (input > maxInput) {
          maxInput = input;
        }
      }
    }
  }

  return maxInput;
}

function getSum(inputs) {
  var sum = 0;

  for (var x = 0; x < this.constants.inputWidth; x++) {
    sum += inputs[x];
  }

  return sum;
}

function getSum2D(inputs) {
  var sum = 0;

  for (var y = 0; y < this.constants.inputHeight; y++) {
    for (var x = 0; x < this.constants.inputWidth; x++) {
      sum += inputs[y][x];
    }
  }

  return sum;
}

function getSum3D(inputs) {
  var sum = 0;

  for (var z = 0; z < this.constants.inputDepth; z++) {
    for (var y = 0; y < this.constants.inputHeight; y++) {
      for (var x = 0; x < this.constants.inputWidth; x++) {
        sum += inputs[z][y][x];
      }
    }
  }

  return sum;
}

function getExponentials(inputs, maxInput) {
  return Math.exp(inputs[this.thread.x] - maxInput[0]);
}

function getExponentials2D(inputs, maxInput) {
  return Math.exp(inputs[this.thread.y][this.thread.x] - maxInput[0]);
}

function getExponentials3D(inputs, maxInput) {
  return Math.exp(inputs[this.thread.z][this.thread.y][this.thread.x] - maxInput[0]);
}

function predict(exponentials, exponentialsSum) {
  return exponentials[this.thread.x] / exponentialsSum[0];
}

function predict2D(exponentials, exponentialsSum) {
  return exponentials[this.thread.y][this.thread.x] / exponentialsSum[0];
}

function predict3D(exponentials, exponentialsSum) {
  return exponentials[this.thread.z][this.thread.y][this.thread.x] / exponentialsSum[0];
}

function compare(target, exponentials) {
  var indicator = 0;

  if (this.thread.x === target) {
    indicator = 1;
  }

  return -(indicator - exponentials[this.thread.x]);
}

function compare2D(target, exponentials) {
  var indicator = 0;
  var index = this.thread.x + this.thread.y * this.output.x;

  if (index === target) {
    indicator = 1;
  }

  return -(indicator - exponentials[this.thread.y][this.thread.x]);
}

function compare3D(target, exponentials) {
  var indicator = 0;
  var index = this.thread.x + this.thread.y * this.output.x + this.thread.z * this.output.x * this.output.y;

  if (index === target) {
    indicator = 1;
  }

  return -(indicator - exponentials[this.thread.z][this.thread.y][this.thread.x]);
}

function loss(exponentials) {
  return -Math.log();
} // TODO: handle: `return -Math.log(this.es[y]);` in learn


var SoftMax = function (_Filter) {
  _inherits(SoftMax, _Filter);

  function SoftMax(inputLayer) {
    _classCallCheck(this, SoftMax);

    var _this = _possibleConstructorReturn(this, (SoftMax.__proto__ || Object.getPrototypeOf(SoftMax)).call(this));

    _this.width = inputLayer.width;
    _this.height = inputLayer.height;
    _this.depth = inputLayer.depth;
    _this.getExponentialsKernel = null;
    _this.getMaxValueKernel = null;
    _this.getSumKernel = null;
    _this.inputLayer = inputLayer;

    _this.validate();

    if (_this.height > 1) {
      if (_this.depth > 1) {
        _this.weights = (0, _randos3d2.default)(_this.width, _this.height, _this.depth);
        _this.deltas = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
      } else {
        _this.weights = (0, _randos2d2.default)(_this.width, _this.height);
        _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
      }
    } else {
      _this.weights = (0, _randos2.default)(_this.width);
      _this.deltas = (0, _zeros2.default)(_this.width);
    }

    return _this;
  }

  _createClass(SoftMax, [{
    key: 'setupKernels',
    value: function setupKernels() {
      var width = this.width,
          height = this.height,
          depth = this.depth;

      if (depth > 1) {
        this.getExponentialsKernel = (0, _kernel.makeKernel)(getExponentials3D, {
          output: [width, height, depth]
        });
        this.getMaxValueKernel = (0, _kernel.makeKernel)(getMaxValue3D, {
          output: [1, 1, 1],
          constants: {
            inputWidth: width,
            inputHeight: height,
            inputDepth: depth
          }
        });
        this.getSumKernel = (0, _kernel.makeKernel)(getSum3D, {
          output: [1, 1, 1],
          constants: {
            inputWidth: width,
            inputHeight: height,
            inputDepth: depth
          }
        });
        this.predictKernel = (0, _kernel.makeKernel)(predict3D, {
          output: [width, height, depth]
        });
        this.compareKernel = (0, _kernel.makeKernel)(compare3D, {
          output: [width, height, depth]
        });
      } else {
        this.getExponentialsKernel = (0, _kernel.makeKernel)(getExponentials, {
          output: [width, height]
        });
        this.getMaxValueKernel = (0, _kernel.makeKernel)(getMaxValue2D, {
          output: [1, 1],
          constants: {
            inputWidth: width,
            inputHeight: height
          }
        });
        this.getSumKernel = (0, _kernel.makeKernel)(getSum2D, {
          output: [1, 1],
          constants: {
            inputWidth: width,
            inputHeight: height
          }
        });
        this.predictKernel = (0, _kernel.makeKernel)(predict2D, {
          output: [width, height]
        });
        this.compareKernel = (0, _kernel.makeKernel)(compare2D, {
          output: [width, height]
        });
      }
    }
  }, {
    key: 'predict',
    value: function predict() {
      var maxValue = this.getMaxValueKernel(this.inputLayer.weights);
      var exponentials = this.getExponentialsKernel(this.inputLayer.weights, maxValue);
      var exponentialsSum = this.getSumKernel(exponentials);
      this.weights = this.predictKernel(exponentials, exponentialsSum);
    }
  }, {
    key: 'compare',
    value: function compare(targetValues) {
      this.errors = this.compareKernel(targetValues[0], this.deltas);
      this.deltas = this.errors;
      this.inputLayer.deltas = this.deltas;
    }
  }]);

  return SoftMax;
}(_types.Filter);

exports.default = SoftMax;
},{"../utilities/kernel":"L30b","./types":"pX1U","../utilities/randos":"S8tM","../utilities/randos-2d":"pcuE","../utilities/randos-3d":"9TSf","../utilities/zeros":"M4LY","../utilities/zeros-2d":"C4Cz","../utilities/zeros-3d":"0AN3"}],"qIAv":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Regression = function (_Base) {
  _inherits(Regression, _Base);

  function Regression() {
    _classCallCheck(this, Regression);

    return _possibleConstructorReturn(this, (Regression.__proto__ || Object.getPrototypeOf(Regression)).apply(this, arguments));
  }

  _createClass(Regression, [{
    key: 'predict',
    value: function predict() {
      this.weights = this.inputs;
      this.validate();
    }
  }, {
    key: 'learn',
    value: function learn() {// throw new Error(`${this.constructor.name}-learn is not yet implemented`)
    }
  }]);

  return Regression;
}(_base2.default);

exports.default = Regression;

function learn(target) {// if(y === i) { continue; }
  // var ydiff = -yscore + x.w[i] + margin;
  // if(ydiff > 0) {
  //   // violating dimension, apply loss
  //   x.dw[i] += 1;
  //   x.dw[y] -= 1;
  //   loss += ydiff;
  // }
}
},{"./base":"kIeX"}],"YNtu":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.predict = predict;
exports.compare = compare;

var _types = require('./types');

var _kernel = require('../utilities/kernel');

var _tanh = require('../activation/tanh');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function predict(inputs) {
  return Math.tanh(inputs[this.thread.y][this.thread.x]);
}

function compare(weights, errors) {
  return (0, _tanh.tanhDerivative)(weights[this.thread.y][this.thread.x], errors[this.thread.y][this.thread.x]);
}

var Tanh = function (_Activation) {
  _inherits(Tanh, _Activation);

  function Tanh(inputLayer) {
    _classCallCheck(this, Tanh);

    var _this = _possibleConstructorReturn(this, (Tanh.__proto__ || Object.getPrototypeOf(Tanh)).call(this));

    _this.inputLayer = inputLayer;
    var _this$inputLayer = _this.inputLayer,
        width = _this$inputLayer.width,
        height = _this$inputLayer.height,
        depth = _this$inputLayer.depth;
    _this.width = width;
    _this.height = height;
    _this.depth = depth;

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Tanh, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(predict, {
        output: [this.width, this.height]
      });
      this.compareKernel = (0, _kernel.makeKernel)(compare, {
        output: [this.width, this.height],
        functions: [_tanh.tanhDerivative]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.deltas = this.compareKernel(this.weights, this.deltas);
    }
  }]);

  return Tanh;
}(_types.Activation);

exports.default = Tanh;
},{"./types":"pX1U","../utilities/kernel":"L30b","../activation/tanh":"v3/M","../utilities/zeros-2d":"C4Cz"}],"xXoy":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _kernel = require('../utilities/kernel');

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _zeros3d = require('../utilities/zeros-3d');

var _zeros3d2 = _interopRequireDefault(_zeros3d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function compare1D(weights, targetValues) {
  return weights[this.thread.y][this.thread.x] - targetValues[this.thread.x];
}

function compare2D(weights, targetValues) {
  return weights[this.thread.y][this.thread.x] - targetValues[this.thread.y][this.thread.x];
}

var Target = function (_Filter) {
  _inherits(Target, _Filter);

  function Target(settings, inputLayer) {
    _classCallCheck(this, Target);

    var _this = _possibleConstructorReturn(this, (Target.__proto__ || Object.getPrototypeOf(Target)).call(this, settings));

    _this.inputLayer = inputLayer;
    _this.width = inputLayer.width;
    _this.height = inputLayer.height;
    _this.depth = inputLayer.depth;

    _this.validate();

    if (_this.depth > 1) {
      _this.weights = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
      _this.deltas = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
      _this.errors = (0, _zeros3d2.default)(_this.width, _this.height, _this.depth);
    } else if (_this.height > 1) {
      _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
      _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
      _this.errors = (0, _zeros2d2.default)(_this.width, _this.height);
    } else {
      _this.weights = (0, _zeros2.default)(_this.width);
      _this.deltas = (0, _zeros2.default)(_this.width);
      _this.errors = (0, _zeros2.default)(_this.width);
    }

    return _this;
  }

  _createClass(Target, [{
    key: 'setupKernels',
    value: function setupKernels() {
      var compareFn = this.width === 1 ? compare1D : compare2D;
      this.compareKernel = (0, _kernel.makeKernel)(compareFn, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      // NOTE: this looks like it shouldn't be, but the weights are immutable, and this is where they are reused.
      this.weights = this.inputLayer.weights;
    }
  }, {
    key: 'compare',
    value: function compare(targetValues) {
      // this is where weights attach to deltas
      // deltas will be zero on learn, so save it in error for comparing to mse later
      this.errors = this.compareKernel(this.weights, targetValues);
      this.deltas = this.errors;
      this.inputLayer.deltas = this.deltas;
    }
  }]);

  return Target;
}(_types.Filter);

exports.default = Target;
},{"../utilities/kernel":"L30b","../utilities/zeros":"M4LY","../utilities/zeros-2d":"C4Cz","../utilities/zeros-3d":"0AN3","./types":"pX1U"}],"NJz4":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _types = require('./types');

var _kernel = require('../utilities/kernel');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function transpose(array) {
  return array[this.thread.x][this.thread.y];
}

var Transpose = function (_Modifier) {
  _inherits(Transpose, _Modifier);

  function Transpose(inputLayer) {
    _classCallCheck(this, Transpose);

    var _this = _possibleConstructorReturn(this, (Transpose.__proto__ || Object.getPrototypeOf(Transpose)).call(this));

    _this.inputLayer = inputLayer;
    _this.width = _this.inputLayer.height;
    _this.height = _this.inputLayer.width;

    _this.validate();

    return _this;
  }

  _createClass(Transpose, [{
    key: 'setupKernels',
    value: function setupKernels() {
      this.predictKernel = (0, _kernel.makeKernel)(transpose, {
        output: [this.height, this.width]
      });
      this.compareKernel = (0, _kernel.makeKernel)(transpose, {
        output: [this.width, this.height]
      });
    }
  }, {
    key: 'predict',
    value: function predict() {
      this.weights = this.predictKernel(this.inputLayer.weights);
    }
  }, {
    key: 'compare',
    value: function compare() {
      this.inputLayer.deltas = this.predictKernel(this.deltas);
    }
  }]);

  return Transpose;
}(_types.Modifier);

exports.default = Transpose;
},{"./types":"pX1U","../utilities/kernel":"L30b"}],"EO/P":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Zeros = function (_Model) {
  _inherits(Zeros, _Model);

  function Zeros(settings) {
    _classCallCheck(this, Zeros);

    var _this = _possibleConstructorReturn(this, (Zeros.__proto__ || Object.getPrototypeOf(Zeros)).call(this, settings));

    _this.validate();

    _this.weights = (0, _zeros2d2.default)(_this.width, _this.height);
    _this.deltas = (0, _zeros2d2.default)(_this.width, _this.height);
    return _this;
  }

  _createClass(Zeros, [{
    key: 'predict',
    value: function predict() {// throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }]);

  return Zeros;
}(_types.Model);

exports.default = Zeros;
},{"../utilities/zeros-2d":"C4Cz","./types":"pX1U"}],"X3lc":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zeros = exports.Zeros = exports.transpose = exports.Transpose = exports.target = exports.Target = exports.tanh = exports.Tanh = exports.svm = exports.SVM = exports.softMax = exports.SoftMax = exports.sigmoid = exports.Sigmoid = exports.relu = exports.Relu = exports.regression = exports.Regression = exports.random = exports.Random = exports.pool = exports.Pool = exports.ones = exports.Ones = exports.negative = exports.Negative = exports.multiplyElement = exports.MultiplyElement = exports.multiply = exports.Multiply = exports.leakyRelu = exports.LeakyRelu = exports.input = exports.Input = exports.fullyConnected = exports.FullyConnected = exports.dropout = exports.Dropout = exports.convolution = exports.Convolution = exports.Base = exports.add = exports.Add = undefined;

var _add = require('./add');

var _add2 = _interopRequireDefault(_add);

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _convolution = require('./convolution');

var _convolution2 = _interopRequireDefault(_convolution);

var _dropout = require('./dropout');

var _dropout2 = _interopRequireDefault(_dropout);

var _fullyConnected = require('./fully-connected');

var _fullyConnected2 = _interopRequireDefault(_fullyConnected);

var _input = require('./input');

var _input2 = _interopRequireDefault(_input);

var _leakyRelu = require('./leaky-relu');

var _leakyRelu2 = _interopRequireDefault(_leakyRelu);

var _multiply = require('./multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _multiplyElement = require('./multiply-element');

var _multiplyElement2 = _interopRequireDefault(_multiplyElement);

var _negative = require('./negative');

var _negative2 = _interopRequireDefault(_negative);

var _ones = require('./ones');

var _ones2 = _interopRequireDefault(_ones);

var _pool = require('./pool');

var _pool2 = _interopRequireDefault(_pool);

var _random = require('./random');

var _random2 = _interopRequireDefault(_random);

var _regression = require('./regression');

var _regression2 = _interopRequireDefault(_regression);

var _relu = require('./relu');

var _relu2 = _interopRequireDefault(_relu);

var _sigmoid = require('./sigmoid');

var _sigmoid2 = _interopRequireDefault(_sigmoid);

var _softMax = require('./soft-max');

var _softMax2 = _interopRequireDefault(_softMax);

var _svm = require('./svm');

var _svm2 = _interopRequireDefault(_svm);

var _tanh = require('./tanh');

var _tanh2 = _interopRequireDefault(_tanh);

var _target = require('./target');

var _target2 = _interopRequireDefault(_target);

var _transpose = require('./transpose');

var _transpose2 = _interopRequireDefault(_transpose);

var _zeros = require('./zeros');

var _zeros2 = _interopRequireDefault(_zeros);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // import feedForward from './feed-forward'


function add(inputLayer1, inputLayer2) {
  return new _add2.default(inputLayer1, inputLayer2);
} // import recurrent from './recurrent'
// import output from './output'
// import lstm from './lstm'
// import gru from './gru'


function convolution(settings, inputLayer) {
  return new _convolution2.default(settings, inputLayer);
}

function dropout(settings, inputLayer) {
  return new _dropout2.default(settings, inputLayer);
}

function fullyConnected(settings, inputLayer) {
  return new _fullyConnected2.default(settings, inputLayer);
}

function input(settings) {
  return new _input2.default(settings);
}

function leakyRelu(inputLayer) {
  return new _leakyRelu2.default(inputLayer);
}

function multiply(inputLayer1, inputLayer2) {
  return new _multiply2.default(inputLayer1, inputLayer2);
}

function multiplyElement(inputLayer1, inputLayer2) {
  return new _multiplyElement2.default(inputLayer1, inputLayer2);
}

function negative(settings, inputLayer) {
  return new _negative2.default(settings, inputLayer);
}

function ones(settings) {
  return new _ones2.default(settings);
}

function pool(settings, inputLayer) {
  return new _pool2.default(settings, inputLayer);
}

function random(settings) {
  return new _random2.default(settings);
}

function regression(settings, inputLayer) {
  return new _regression2.default(settings, inputLayer);
}

function relu(inputLayer) {
  return new _relu2.default(inputLayer);
}

function sigmoid(inputLayer) {
  return new _sigmoid2.default(inputLayer);
}

function softMax(settings, inputLayer) {
  return new _softMax2.default(settings, inputLayer);
}

function svm(settings, inputLayer) {
  return new _svm2.default(settings, inputLayer);
}

function tanh(inputLayer) {
  return new _tanh2.default(inputLayer);
}

function target(settings, inputLayer) {
  return new _target2.default(settings, inputLayer);
}

function transpose(inputLayer) {
  return new _transpose2.default(inputLayer);
}

function zeros(settings) {
  return new _zeros2.default(settings);
}

exports.Add = _add2.default;
exports.add = add;
exports.Base = _base2.default;
exports.Convolution = _convolution2.default;
exports.convolution = convolution;
exports.Dropout = _dropout2.default;
exports.dropout = dropout;
exports.FullyConnected = _fullyConnected2.default;
exports.fullyConnected = fullyConnected;
exports.Input = _input2.default;
exports.input = input;
exports.LeakyRelu = _leakyRelu2.default;
exports.leakyRelu = leakyRelu;
exports.Multiply = _multiply2.default;
exports.multiply = multiply;
exports.MultiplyElement = _multiplyElement2.default;
exports.multiplyElement = multiplyElement;
exports.Negative = _negative2.default;
exports.negative = negative;
exports.Ones = _ones2.default;
exports.ones = ones;
exports.Pool = _pool2.default;
exports.pool = pool;
exports.Random = _random2.default;
exports.random = random;
exports.Regression = _regression2.default;
exports.regression = regression;
exports.Relu = _relu2.default;
exports.relu = relu;
exports.Sigmoid = _sigmoid2.default;
exports.sigmoid = sigmoid;
exports.SoftMax = _softMax2.default;
exports.softMax = softMax;
exports.SVM = _svm2.default;
exports.svm = svm;
exports.Tanh = _tanh2.default;
exports.tanh = tanh;
exports.Target = _target2.default;
exports.target = target;
exports.Transpose = _transpose2.default;
exports.transpose = transpose;
exports.Zeros = _zeros2.default;
exports.zeros = zeros;
},{"./add":"q7CK","./base":"kIeX","./convolution":"xL0H","./dropout":"YwJF","./fully-connected":"Aqg2","./input":"qUrb","./leaky-relu":"JZX2","./multiply":"xJEq","./multiply-element":"vjFV","./negative":"kuo+","./ones":"0122","./pool":"vNYh","./random":"yQCp","./regression":"viPg","./relu":"BjPp","./sigmoid":"ED1E","./soft-max":"nfIB","./svm":"qIAv","./tanh":"YNtu","./target":"xXoy","./transpose":"NJz4","./zeros":"EO/P"}],"dfGl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = likely;
/**
 *
 * @param {*} input
 * @param {NeuralNetwork} net
 * @returns {*}
 */

function likely(input, net) {
  var output = net.run(input);
  var maxProp = null;
  var maxValue = -1;
  Object.keys(output).forEach(function (key) {
    var value = output[key];

    if (value > maxValue) {
      maxProp = key;
      maxValue = value;
    }
  });
  return maxProp;
}
},{}],"Q1a6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/* Functions for turning sparse hashes into arrays and vice versa */


var lookup = function () {
  function lookup() {
    _classCallCheck(this, lookup);
  }

  _createClass(lookup, null, [{
    key: "buildLookup",

    /**
     * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
     * @param {Object} hashes
     * @returns {Object}
     */
    value: function buildLookup(hashes) {
      var reducedHash = hashes.reduce(function (memo, hash) {
        return Object.assign(memo, hash);
      }, {});
      return lookup.lookupFromHash(reducedHash);
    }
    /**
     * performs `{a: 6, b: 7} -> {a: 0, b: 1}`
     * @param {Object} hash
     * @returns {Object}
     */

  }, {
    key: "lookupFromHash",
    value: function lookupFromHash(hash) {
      var lookupHash = {};
      var index = 0;
      Object.keys(hash).forEach(function (i) {
        index += 1;
        lookupHash[i] = index;
      });
      return lookupHash;
    }
    /**
     * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`
     * @param {*} lookup
     * @param {*} hash
     * @returns {Array}
     */

  }, {
    key: "toArray",
    value: function toArray(lookupHash, hash) {
      var array = [];
      Object.keys(lookupHash).forEach(function (i) {
        array[lookupHash[i]] = hash[i] || 0;
      });
      return array;
    }
    /**
     * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`
     * @param {Object} lookupHash
     * @param {Array} array
     * @returns {Object}
     */

  }, {
    key: "toHash",
    value: function toHash(lookupHash, array) {
      var hash = {};
      Object.keys(lookupHash).forEach(function (i) {
        hash[i] = array[lookupHash[i]];
      });
      return hash;
    }
    /**
     *
     * @param {Array} array
     * @returns {*}
     */

  }, {
    key: "lookupFromArray",
    value: function lookupFromArray(array) {
      var lookupHash = {};
      var z = 0;
      var i = array.length;

      while (i-- > 0) {
        lookupHash[array[i]] = z++;
      }

      return lookupHash;
    }
  }]);

  return lookup;
}();

exports.default = lookup;
},{}],"OMKX":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MRmsProp = exports.getMomentum = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

exports.clipByValue = clipByValue;
exports.isClippedByValue = isClippedByValue;

var _kernel = require('../utilities/kernel');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function getMomentum(delta, decay, previousMomentum) {
  return previousMomentum * decay + (1 - decay) * delta * delta;
}

function clipByValue(value, max, min) {
  if (value > max) {
    return max;
  }

  if (value < min) {
    return min;
  }

  return value;
}
/**
 * @description Momentum Root Mean Square Propagation Function
 * @returns {number}
 */


function momentumRootMeanSquaredPropagation(weights, deltas, previousMomentums) {
  var delta = deltas[this.thread.y][this.thread.x];
  var clippedDelta = clipByValue(delta, this.constants.clipValue, -this.constants.clipValue);
  var weight = weights[this.thread.y][this.thread.x];
  var previousMomentum = previousMomentums[this.thread.y][this.thread.x];
  var momentum = getMomentum(delta, this.constants.decayRate, previousMomentum);
  return weight + -this.constants.learningRate * clippedDelta / Math.sqrt(momentum + this.constants.smoothEps) - this.constants.regularizationStrength * weight;
}

function isClippedByValue(value, max, min) {
  if (value > max) {
    return 1;
  }

  if (value < min) {
    return 1;
  }

  return 0;
}

var MomentumRootMeanSquaredPropagation = function () {
  _createClass(MomentumRootMeanSquaredPropagation, null, [{
    key: 'defaults',
    get: function get() {
      return {
        decayRate: 0.999,
        regularizationStrength: 0.000001,
        learningRate: 0.01,
        smoothEps: 1e-8,
        clipValue: 5
      };
    }
  }]);

  function MomentumRootMeanSquaredPropagation(layer) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MomentumRootMeanSquaredPropagation);

    this.layer = layer;
    this.width = layer.width;
    this.height = layer.height;
    this.momentums = (0, _zeros2d2.default)(layer.width, layer.height);
    Object.assign(this, this.constructor.defaults, settings);
    this.setupKernels();
  }

  _createClass(MomentumRootMeanSquaredPropagation, [{
    key: 'run',
    value: function run(layer, previousLayer, nextLayer, learningRate) {
      var output = this.kernel(layer.weights, layer.deltas, this.momentums);
      this.momentums = output.momentums;
      return output.result;
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {
      this.kernel = (0, _kernel.makeKernel)(momentumRootMeanSquaredPropagation, {
        output: [this.width, this.height],
        constants: {
          clipValue: this.clipValue,
          decayRate: this.decayRate,
          learningRate: this.learningRate,
          regularizationStrength: this.regularizationStrength,
          smoothEps: this.smoothEps
        },
        functions: [clipByValue],
        map: {
          momentums: getMomentum
        }
      });
    }
  }]);

  return MomentumRootMeanSquaredPropagation;
}();
/**
 * @description Mathematician friendly name of MomentumRootMeanSquaredPropagation class. For those that are not mere mortals
 * @type {MomentumRootMeanSquaredPropagation}
 */


exports.default = MomentumRootMeanSquaredPropagation;
var MRmsProp = MomentumRootMeanSquaredPropagation;
exports.getMomentum = getMomentum;
exports.MRmsProp = MRmsProp;
},{"../utilities/kernel":"L30b","../utilities/zeros-2d":"C4Cz"}],"4P9L":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _momentumRootMeanSquaredPropagation = require('./momentum-root-mean-squared-propagation');

var _momentumRootMeanSquaredPropagation2 = _interopRequireDefault(_momentumRootMeanSquaredPropagation);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function momentumRootMeanSquaredPropagation(layer, settings) {
  return new _momentumRootMeanSquaredPropagation2.default(layer, settings);
}

var mRmsProp = momentumRootMeanSquaredPropagation;
exports.default = {
  MomentumRootMeanSquaredPropagation: _momentumRootMeanSquaredPropagation2.default,
  momentumRootMeanSquaredPropagation: momentumRootMeanSquaredPropagation,
  MRmsProp: _momentumRootMeanSquaredPropagation.MRmsProp,
  mRmsProp: mRmsProp
};
},{"./momentum-root-mean-squared-propagation":"OMKX"}],"3u/j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mse2d;

function mse2d(errors) {
  // mean squared error 2d
  var sum = 0;
  var length = errors.length * errors[0].length;

  for (var y = 0; y < errors.length; y++) {
    for (var x = 0; x < errors[y].length; x++) {
      sum += Math.pow(errors[y][x], 2);
    }
  }

  return sum / length;
}
},{}],"NEs+":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = layerFromJSON;

var layer = require('../layer');

function layerFromJSON(jsonLayer) {
  if (!layer.hasOwnProperty(jsonLayer.type)) return null;
  var Layer = layer[jsonLayer.type]; // eslint-disable-next-line

  var realLayer = Reflect.construct(Layer, arguments);
  Object.keys(jsonLayer).forEach(function (p) {
    if (p !== 'type') {
      realLayer[p] = jsonLayer[p];
    }
  });
  return realLayer;
}
},{"../layer":"X3lc"}],"WO5N":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseLayersFrom;

function traverseLayersFrom(layer, cb) {
  if (layer.hasOwnProperty('inputLayer')) {
    traverseLayersFrom(layer.inputLayer, cb);
  } else {
    if (layer.hasOwnProperty('inputLayer1')) {
      traverseLayersFrom(layer.inputLayer1, cb);
    }

    if (layer.hasOwnProperty('inputLayer2')) {
      traverseLayersFrom(layer.inputLayer2, cb);
    }
  }

  cb(layer);
}
},{}],"4Z71":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flattenLayers;

var _traverseLayersFrom = require('./traverse-layers-from');

var _traverseLayersFrom2 = _interopRequireDefault(_traverseLayersFrom);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function flattenLayers(layers) {
  var result = layers.slice(0);

  var _loop = function _loop(i) {
    var offset = 0;
    (0, _traverseLayersFrom2.default)(result[i], function (layer) {
      if (result.indexOf(layer) === -1) {
        result.splice(i + offset, 0, layer);
        offset++;
      }
    });
  };

  for (var i = 0; i < result.length; i++) {
    _loop(i);
  }

  return result;
}
},{"./traverse-layers-from":"WO5N"}],"eqC7":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}(); // import TrainStream from './train-stream'


var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

var _mse2d = require('./utilities/mse-2d');

var _mse2d2 = _interopRequireDefault(_mse2d);

var _layerFromJson = require('./utilities/layer-from-json');

var _layerFromJson2 = _interopRequireDefault(_layerFromJson);

var _praxis2 = require('./praxis');

var _praxis = _interopRequireWildcard(_praxis2);

var _flattenLayers = require('./utilities/flatten-layers');

var _flattenLayers2 = _interopRequireDefault(_flattenLayers);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var FeedForward = function () {
  _createClass(FeedForward, [{
    key: '_setLogMethod',

    /**
     *
     * @param log
     * if a method is passed in method is used
     * if false passed in nothing is logged
     * @returns error
     */
    value: function _setLogMethod(log) {
      if (typeof log === 'function') {
        this.trainOpts.log = log;
      } else if (log) {
        // eslint-disable-next-line
        this.trainOpts.log = console.log;
      } else {
        this.trainOpts.log = false;
      }
    }
    /**
     *
     * @param opts
     *    Supports all `trainDefaults` properties
     *    also supports:
     *       learningRate: (number)
     */

  }, {
    key: '_updateTrainingOptions',
    value: function _updateTrainingOptions(opts) {
      var _this = this;

      Object.keys(this.constructor.trainDefaults).forEach(function (opt) {
        _this.trainOpts[opt] = opts.hasOwnProperty(opt) ? opts[opt] : _this.trainOpts[opt];
      });

      this.constructor._validateTrainingOptions(this.trainOpts);

      this._setLogMethod(opts.log || this.trainOpts.log);
    }
  }], [{
    key: '_validateTrainingOptions',

    /**
     *
     * @param options
     * @private
     */
    value: function _validateTrainingOptions(options) {
      var validations = {
        iterations: function iterations(val) {
          return typeof val === 'number' && val > 0;
        },
        errorThresh: function errorThresh(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        log: function log(val) {
          return typeof val === 'function' || typeof val === 'boolean';
        },
        logPeriod: function logPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        learningRate: function learningRate(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        callback: function callback(val) {
          return typeof val === 'function' || val === null;
        },
        callbackPeriod: function callbackPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        timeout: function timeout(val) {
          return typeof val === 'number' && val > 0;
        }
      };
      Object.keys(FeedForward.trainDefaults).forEach(function (key) {
        if (validations.hasOwnProperty(key) && !validations[key](options[key])) {
          throw new Error('[' + key + ', ' + options[key] + '] is out of normal training range, your network will probably not train.');
        }
      });
    }
  }, {
    key: 'trainDefaults',
    get: function get() {
      return {
        iterations: 20000,
        errorThresh: 0.005,
        log: false,
        logPeriod: 10,
        learningRate: 0.3,
        callback: null,
        callbackPeriod: 10,
        reinforce: false
      };
    }
  }, {
    key: 'defaults',
    get: function get() {
      return {
        learningRate: 0.3,
        binaryThresh: 0.5,
        hiddenLayers: null,
        inputLayer: null,
        outputLayer: null,
        praxis: function praxis(layer) {
          return _praxis.momentumRootMeanSquaredPropagation(layer);
        }
      };
    }
  }, {
    key: 'structure',
    get: function get() {
      return {
        layers: null,
        _inputLayer: null,
        _outputLayer: null
      };
    }
    /**
     *
     * @param {object} options
     * @constructor
     */

  }]);

  function FeedForward() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FeedForward);

    this.inputLayer = null;
    this.hiddenLayers = null;
    this.outputLayer = null;
    this.errorCheckInterval = 100;
    Object.assign(this, this.constructor.defaults, options);
    this.trainOpts = {};

    this._updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));

    Object.assign(this, this.constructor.structure);
  }

  _createClass(FeedForward, [{
    key: '_connectLayers',
    value: function _connectLayers() {
      var layers = [];
      this._inputLayer = this.inputLayer();

      var hiddenLayers = this._connectHiddenLayers(this._inputLayer);

      this._outputLayer = this.outputLayer(hiddenLayers[hiddenLayers.length - 1], hiddenLayers.length);
      layers.push(this._inputLayer);
      layers.push.apply(layers, _toConsumableArray(hiddenLayers));
      layers.push(this._outputLayer);
      this.layers = (0, _flattenLayers2.default)(layers);
    }
  }, {
    key: '_connectHiddenLayers',
    value: function _connectHiddenLayers(previousLayer) {
      var hiddenLayers = [];

      for (var i = 0; i < this.hiddenLayers.length; i++) {
        var hiddenLayer = this.hiddenLayers[i](previousLayer, i);
        hiddenLayers.push(hiddenLayer);
        previousLayer = hiddenLayer;
      }

      return hiddenLayers;
    }
  }, {
    key: 'initialize',
    value: function initialize() {
      this._connectLayers();

      this.initializeLayers(this.layers);
    }
  }, {
    key: 'initializeLayers',
    value: function initializeLayers(layers) {
      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        layer.setupKernels();

        if (layer.hasOwnProperty('praxis') && layer.praxis === null) {
          layer.praxis = this.praxis(layer);
        }
      }
    }
    /**
     *
     * @param input
     * @returns {*}
     */

  }, {
    key: 'run',
    value: function run(input) {
      if (this.inputLookup) {
        input = _lookup2.default.toArray(this.inputLookup, input);
      }

      var output = this.runInput(input);

      if (this.outputLookup) {
        output = _lookup2.default.toHash(this.outputLookup, output);
      }

      return output;
    }
  }, {
    key: 'runInput',
    value: function runInput(input) {
      this.layers[0].predict(input);

      for (var i = 1; i < this.layers.length; i++) {
        this.layers[i].predict();
      }

      return this.layers[this.layers.length - 1].weights;
    }
    /**
     *
     * @param data
     * @param options
     * @returns {{error: number, iterations: number}}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var status = void 0;
      var endTime = void 0;

      var _prepTraining2 = this._prepTraining(data, options);

      data = _prepTraining2.data;
      status = _prepTraining2.status;
      endTime = _prepTraining2.endTime;

      while (this._trainingTick(data, status, endTime)) {}

      return status;
    }
    /**
     *
     * @param {object} data
     * @param {object} status { iterations: number, error: number }
     * @param endTime
     */

  }, {
    key: '_trainingTick',
    value: function _trainingTick(data, status, endTime) {
      if (status.iterations >= this.trainOpts.iterations || status.error <= this.trainOpts.errorThresh || Date.now() >= endTime) {
        return false;
      }

      status.iterations++;

      if (this.trainOpts.log && status.iterations % this.trainOpts.logPeriod === 0) {
        status.error = this._calculateTrainingError(data);
        this.trainOpts.log('iterations: ' + status.iterations + ', training error: ' + status.error);
      } else if (status.iterations % this.errorCheckInterval === 0) {
        status.error = this._calculateTrainingError(data);
      } else {
        this._trainPatterns(data);
      }

      if (this.trainOpts.callback && status.iterations % this.trainOpts.callbackPeriod === 0) {
        this.trainOpts.callback(Object.assign(status));
      }

      return true;
    }
    /**
     *
     * @param data
     * @param options
     * @protected
     * @return { data, status, endTime }
     */

  }, {
    key: '_prepTraining',
    value: function _prepTraining(data, options) {
      this._updateTrainingOptions(options);

      data = this._formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;
      var status = {
        error: 1,
        iterations: 0
      };
      this.initialize();
      return {
        data: data,
        status: status,
        endTime: endTime
      };
    }
    /**
     *
     * @param data
     * @returns {Number} error
     */

  }, {
    key: '_calculateTrainingError',
    value: function _calculateTrainingError(data) {
      var sum = 0;

      for (var i = 0; i < data.length; ++i) {
        sum += this._trainPattern(data[i].input, data[i].output, true);
      }

      return sum / data.length;
    }
    /**
     * @param data
     * @private
     */

  }, {
    key: '_trainPatterns',
    value: function _trainPatterns(data) {
      for (var i = 0; i < data.length; ++i) {
        this._trainPattern(data[i].input, data[i].output, false);
      }
    }
    /**
     *
     * @param input
     * @param target
     * @param {Boolean} logErrorRate
     */

  }, {
    key: '_trainPattern',
    value: function _trainPattern(input, target, logErrorRate) {
      // forward propagate
      this.runInput(input); // back propagate

      this._calculateDeltas(target);

      this._adjustWeights();

      if (logErrorRate) {
        return (0, _mse2d2.default)(this._outputLayer.errors.hasOwnProperty('toArray') ? this._outputLayer.errors.toArray() : this._outputLayer.errors);
      }

      return null;
    }
  }, {
    key: '_calculateDeltas',
    value: function _calculateDeltas(target) {
      for (var i = this.layers.length - 1; i > -1; i--) {
        this.layers[i].compare(target);
      }
    }
    /**
     *
     */

  }, {
    key: '_adjustWeights',
    value: function _adjustWeights() {
      for (var i = 0; i < this.layers.length; i++) {
        this.layers[i].learn(this.layers[i - 1], this.layers[i + 1], this.trainOpts.learningRate);
      }
    }
    /**
     *
     * @param data
     * @returns {*}
     */

  }, {
    key: '_formatData',
    value: function _formatData(data) {
      var _this2 = this;

      if (!Array.isArray(data)) {
        // turn stream datum into array
        var tmp = [];
        tmp.push(data);
        data = tmp;
      } // turn sparse hash input into arrays with 0s as filler


      var datum = data[0].input;

      if (!Array.isArray(datum) && !(datum instanceof Float32Array)) {
        if (!this.inputLookup) {
          this.inputLookup = _lookup2.default.buildLookup(data.map(function (value) {
            return value.input;
          }));
        }

        data = data.map(function (datumParam) {
          var array = _lookup2.default.toArray(_this2.inputLookup, datumParam.input);

          return Object.assign({}, datumParam, {
            input: array
          });
        }, this);
      }

      if (!Array.isArray(data[0].output)) {
        if (!this.outputLookup) {
          this.outputLookup = _lookup2.default.buildLookup(data.map(function (value) {
            return value.output;
          }));
        }

        data = data.map(function (datumParam) {
          var array = _lookup2.default.toArray(_this2.outputLookup, datumParam.output);

          return Object.assign({}, datumParam, {
            output: array
          });
        }, this);
      }

      return data;
    }
    /**
     *
     * @param data
     * @returns {
     *  {
     *    error: number,
     *    misclasses: Array
     *  }
     * }
     */

  }, {
    key: 'test',
    value: function test() {
      throw new Error(this.constructor.name + '-test is not yet implemented');
    }
    /**
     *
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var jsonLayers = [];

      for (var i = 0; i < this.layers.length; i++) {
        var layer = this.layers[i];
        var jsonLayer = layer.toJSON();

        if (layer.hasOwnProperty('inputLayer')) {
          jsonLayer.inputLayerIndex = this.layers.indexOf(layer.inputLayer);
        } else if (layer.hasOwnProperty('inputLayer1') && layer.hasOwnProperty('inputLayer2')) {
          jsonLayer.inputLayer1Index = this.layers.indexOf(layer.inputLayer1);
          jsonLayer.inputLayer2Index = this.layers.indexOf(layer.inputLayer2);
        }

        jsonLayers.push(jsonLayer);
      }

      return {
        layers: jsonLayers
      };
    }
    /**
     *
     * @param json
     * @param [getLayer]
     * @returns {FeedForward}
     */

  }, {
    key: 'toFunction',

    /**
     *
     * @returns {Function}
     */
    value: function toFunction() {
      throw new Error(this.constructor.name + '-toFunction is not yet implemented');
    }
    /**
     * This will create a TrainStream (WriteStream) for us to send the training data to.
     * @param opts training options
     * @returns {TrainStream|*}
     */

  }, {
    key: 'createTrainStream',
    value: function createTrainStream() {
      throw new Error(this.constructor.name + '-createTrainStream is not yet implemented');
    }
  }], [{
    key: 'fromJSON',
    value: function fromJSON(json, getLayer) {
      var jsonLayers = json.layers;
      var layers = [];
      var inputLayer = (0, _layerFromJson2.default)(jsonLayers[0]) || getLayer(jsonLayers[0]);
      layers.push(inputLayer);

      for (var i = 1; i < jsonLayers.length; i++) {
        var jsonLayer = jsonLayers[i];

        if (jsonLayer.hasOwnProperty('inputLayerIndex')) {
          var inputLayer1 = layers[jsonLayer.inputLayerIndex];
          layers.push((0, _layerFromJson2.default)(jsonLayer, inputLayer1) || getLayer(jsonLayer, inputLayer1));
        } else {
          if (!jsonLayer.hasOwnProperty('inputLayer1Index')) throw new Error('inputLayer1Index not defined');
          if (!jsonLayer.hasOwnProperty('inputLayer2Index')) throw new Error('inputLayer2Index not defined');
          var _inputLayer = layers[jsonLayer.inputLayer1Index];
          var inputLayer2 = layers[jsonLayer.inputLayer2Index];
          if (_inputLayer === undefined) throw new Error('layer of index ' + jsonLayer.inputLayer1Index + ' not found');
          if (inputLayer2 === undefined) throw new Error('layer of index ' + jsonLayer.inputLayer2Index + ' not found');
          layers.push((0, _layerFromJson2.default)(jsonLayer, inputLayer) || getLayer(jsonLayer, _inputLayer, inputLayer2));
        }
      }

      var net = new FeedForward(json);
      net.layers = layers;
      return net;
    }
  }]);

  return FeedForward;
}();

exports.default = FeedForward;
},{"./lookup":"Q1a6","./utilities/mse-2d":"3u/j","./utilities/layer-from-json":"NEs+","./praxis":"4P9L","./utilities/flatten-layers":"4Z71"}],"Mjd7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.thaw = thaw;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//private variables
var thawing = false;
var thaws = [];

/**
 * thaw an array of items
 * @param {Array} items
 * @param {Object} [options]
 * @constructor
 */

var Thaw = function () {
  _createClass(Thaw, null, [{
    key: "stopAll",


    /**
     * Stops all Thaw instances
     */
    value: function stopAll() {
      for (var i = 0; i < thaws.length; i++) {
        thaws[i].stop();
      }
    }
  }, {
    key: "defaultSettings",

    /**
     *
     * @type {{each: null, done: null}}
     */
    get: function get() {
      return {
        each: null,
        done: null
      };
    }

    /**
     * returns if Thaw.js is thawing
     * @returns {boolean}
     */

  }, {
    key: "isThawing",
    get: function get() {
      return thawing;
    }
  }]);

  function Thaw(items) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Thaw);

    var _constructor$defaultS = _extends({}, this.constructor.defaultSettings, options),
        each = _constructor$defaultS.each,
        done = _constructor$defaultS.done;

    this.items = items;
    this.i = 0;
    this.options = options;
    var tick = this.tick = function () {
      if (_this.i < 0) return;

      _this.timeout = setTimeout(tick, 0);

      if (thawing) return;
      var item = items[_this.i];
      if (_this.i >= items.length) {
        if (done !== null) {
          thawing = true;
          done(item, _this.i);
          thawing = false;
        }

        _this.i = -1;
        clearTimeout(_this.timeout);
        return;
      }
      if (each !== null) {
        thawing = true;
        each(item, _this.i);
        thawing = false;
      } else if (item !== undefined) {
        item();
      }
      _this.i++;
    };

    thaws.push(this);
    if (!options.delay) {
      tick();
    }
  }

  /**
   * readies thaw to continue
   * @returns {boolean} if had to get ready
   */


  _createClass(Thaw, [{
    key: "makeReady",
    value: function makeReady() {
      if (this.i < 0) {
        this.i = this.items.length;
        return true;
      }
      return false;
    }

    /**
     * Adds an item to the end of this instance of Thaw and readies Thaw to process it
     * @param item
     * @returns {Thaw}
     */

  }, {
    key: "add",
    value: function add(item) {
      var doTick = this.makeReady();

      this.items.push(item);

      if (doTick) {
        this.tick();
      }
      return this;
    }

    /**
     * Inserts an item just after the current item being processed in Thaw and readies Thaw to process it
     * @param item
     * @returns {Thaw}
     */

  }, {
    key: "insert",
    value: function insert(item) {
      var doTick = this.makeReady();

      this.items.splice(this.i, 0, item);

      if (doTick) {
        this.tick();
      }

      return this;
    }

    /**
     * Adds an Array to the end of this instance of Thaw and readies Thaw to process it
     * @param {Array} items
     * @returns {Thaw}
     */

  }, {
    key: "addArray",
    value: function addArray(items) {
      var doTick = this.makeReady();

      this.items = this.items.concat(items);

      if (doTick) {
        this.tick();
      }

      return this;
    }

    /**
     * Inserts an Array just after the current item being processed in Thaw and readies Thaw to process them
     * @param {Array} items
     * @returns {Thaw}
     */

  }, {
    key: "insertArray",
    value: function insertArray(items) {
      var doTick = this.makeReady();
      var left = this.items;
      var middle = items;
      var right = this.items.splice(this.i, this.items.length - this.i + 1);

      this.items = left.concat(middle, right);

      if (doTick) {
        this.tick();
      }
      return this;
    }

    /**
     * Stops this instance of Thaw
     * @returns {Thaw}
     */

  }, {
    key: "stop",
    value: function stop() {
      this.i = -1;
      clearTimeout(this.timeout);
      if (this.options.done) {
        this.options.done();
      }
      return this;
    }
  }]);

  return Thaw;
}();

/**
 * simple thaw
 * @param {Array} items
 * @param {Object} [options]
 * @returns Thaw
 */


exports.default = Thaw;
function thaw(items) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return new Thaw(items, options);
}

},{}],"YsCn":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('./');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * @param {Object} [options]
 * @param {Number} [count]
 * @constructor
 */
var Block = function () {
  function Block(options, count) {
    _classCallCheck(this, Block);

    this.index = 0;
    this.thaws = [];
    this.count = count || 200;
    this.options = options;
  }

  /**
   * add an item to the end of items
   * @param item
   * @returns {Block}
   */


  _createClass(Block, [{
    key: 'add',
    value: function add(item) {
      var next = this._next();
      next.add(item);

      return this;
    }

    /**
     * add an Array to the end of items
     * @param items
     * @returns {Block}
     */

  }, {
    key: 'addArray',
    value: function addArray(items) {
      var next = this._next();
      next.addArray(items);

      return this;
    }

    /**
     * insert an item into items @ current position
     * @param item
     * @returns {Block}
     */

  }, {
    key: 'insert',
    value: function insert(item) {
      var next = this._next();
      next.insert(item);

      return this;
    }

    /**
     * insert and array into items @ current position
     * @param items
     * @returns {Block}
     */

  }, {
    key: 'insertArray',
    value: function insertArray(items) {
      var next = this._next();
      next.insertArray(items);

      return this;
    }

    /**
     * Stops all thaws in this block
     * @returns {Block}
     */

  }, {
    key: 'stop',
    value: function stop() {
      for (var i = 0; i < this.thaws.length; i++) {
        this.thaws[i].stop();
      }
      return this;
    }

    /**
     * Get next available in block
     * @returns {*}
     * @private
     */

  }, {
    key: '_next',
    value: function _next() {
      var thaw = null;
      var thaws = this.thaws;

      if (thaws.length < this.count) {
        thaws.push(thaw = new _2.default([], this.options));
      } else {
        thaw = thaws[this.index];
      }
      this.index++;
      if (this.index >= this.count) {
        this.index = 0;
      }

      return thaw;
    }
  }]);

  return Block;
}();

exports.default = Block;
;

},{"./":"8AZL"}],"8AZL":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = undefined;

var _thaw = require('./thaw');

var _thaw2 = _interopRequireDefault(_thaw);

var _block = require('./block');

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _thaw2.default;
exports.Block = _block2.default;


if (typeof window !== 'undefined') {
  window.Thaw = _thaw2.default;
  window.Thaw.Block = _block2.default;
}

},{"./thaw":"Mjd7","./block":"YsCn"}],"FRpO":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}
},{}],"4Bm0":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"pBGv":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"Yj0v":[function(require,module,exports) {
var process = require("process");
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"pBGv"}],"upBv":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"Q8A6":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"FRpO"}],"yh9p":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"JgNJ":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"dskh":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"yh9p","ieee754":"JgNJ","isarray":"upBv","buffer":"dskh"}],"38Wu":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"dskh"}],"Q14w":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"dskh"}],"70rD":[function(require,module,exports) {

},{}],"Um5I":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"38Wu","util":"70rD"}],"avqi":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"Yj0v"}],"yM1o":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"3I0x":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"Yj0v","core-util-is":"Q14w","inherits":"4Bm0","util-deprecate":"yM1o","./internal/streams/stream":"Q8A6","safe-buffer":"38Wu","./internal/streams/destroy":"avqi","./_stream_duplex":"wldW","process":"pBGv"}],"wldW":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"Yj0v","core-util-is":"Q14w","inherits":"4Bm0","./_stream_readable":"Ogwm","./_stream_writable":"3I0x"}],"3+3F":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"38Wu"}],"Ogwm":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"Yj0v","isarray":"upBv","events":"FRpO","./internal/streams/stream":"Q8A6","safe-buffer":"38Wu","core-util-is":"Q14w","inherits":"4Bm0","util":"70rD","./internal/streams/BufferList":"Um5I","./internal/streams/destroy":"avqi","./_stream_duplex":"wldW","string_decoder/":"3+3F","process":"pBGv"}],"I3bg":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"wldW","core-util-is":"Q14w","inherits":"4Bm0"}],"kQBK":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"I3bg","core-util-is":"Q14w","inherits":"4Bm0"}],"uwsL":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"Ogwm","./lib/_stream_writable.js":"3I0x","./lib/_stream_duplex.js":"wldW","./lib/_stream_transform.js":"I3bg","./lib/_stream_passthrough.js":"kQBK"}],"GAH2":[function(require,module,exports) {
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":"3I0x"}],"dMbb":[function(require,module,exports) {
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":"wldW"}],"yG3q":[function(require,module,exports) {
module.exports = require('./readable').Transform

},{"./readable":"uwsL"}],"jlpe":[function(require,module,exports) {
module.exports = require('./readable').PassThrough

},{"./readable":"uwsL"}],"fnRj":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"FRpO","inherits":"4Bm0","readable-stream/readable.js":"uwsL","readable-stream/writable.js":"GAH2","readable-stream/duplex.js":"dMbb","readable-stream/transform.js":"yG3q","readable-stream/passthrough.js":"jlpe"}],"vEEq":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _stream = require('stream');

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}
/**
 *
 * https://gist.github.com/telekosmos/3b62a31a5c43f40849bb
 * @param arr
 * @returns {Array}
 */


function uniques(arr) {
  // Sets cannot contain duplicate elements, which is what we want
  return [].concat(_toConsumableArray(new Set(arr)));
}
/**
 *
 * @param opts
 * @returns {TrainStream}
 * @constructor
 */


var TrainStream = function (_Writable) {
  _inherits(TrainStream, _Writable);

  function TrainStream(opts) {
    var _ret;

    _classCallCheck(this, TrainStream);

    var _this = _possibleConstructorReturn(this, (TrainStream.__proto__ || Object.getPrototypeOf(TrainStream)).call(this, {
      objectMode: true
    }));

    opts = opts || {}; // require the neuralNetwork

    if (!opts.neuralNetwork) {
      throw new Error('no neural network specified');
    }

    _this.neuralNetwork = opts.neuralNetwork;
    _this.dataFormatDetermined = false;
    _this.inputKeys = [];
    _this.outputKeys = []; // keeps track of keys seen

    _this.i = 0; // keep track of the for loop i variable that we got rid of

    _this.iterations = opts.iterations || 20000;
    _this.errorThresh = opts.errorThresh || 0.005; // eslint-disable-next-line

    _this.log = opts.log ? typeof opts.log === 'function' ? opts.log : console.log //eslint-disable-line
    : false;
    _this.logPeriod = opts.logPeriod || 10;
    _this.callback = opts.callback;
    _this.callbackPeriod = opts.callbackPeriod || 10;
    _this.floodCallback = opts.floodCallback;
    _this.doneTrainingCallback = opts.doneTrainingCallback;
    _this.size = 0;
    _this.count = 0;
    _this.sum = 0;

    _this.on('finish', _this.finishStreamIteration.bind(_this));

    return _ret = _this, _possibleConstructorReturn(_this, _ret);
  }
  /**
   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}
   * @param chunk
   * @param enc
   * @param next
   * @returns {*}
   * @private
   */


  _createClass(TrainStream, [{
    key: '_write',
    value: function _write(chunk, enc, next) {
      if (!chunk) {
        // check for the end of one iteration of the stream
        this.emit('finish');
        return next();
      }

      if (!this.dataFormatDetermined) {
        this.size++;
        this.inputKeys = uniques(this.inputKeys.slice(0).concat(Object.keys(chunk.input)));
        this.outputKeys = uniques(this.outputKeys.slice(0).concat(Object.keys(chunk.output)));
        this.firstDatum = this.firstDatum || chunk;
        return next();
      }

      this.count++;
      var data = this.neuralNetwork.formatData(chunk);
      this.trainDatum(data[0]); // tell the Readable Stream that we are ready for more data

      return next();
    }
    /**
     *
     * @param datum
     */

  }, {
    key: 'trainDatum',
    value: function trainDatum(datum) {
      var err = this.neuralNetwork.trainPattern(datum.input, datum.output);
      this.sum += err;
    }
    /**
     *
     * @returns {*}
     */

  }, {
    key: 'finishStreamIteration',
    value: function finishStreamIteration() {
      if (this.dataFormatDetermined && this.size !== this.count) {
        this.log("This iteration's data length was different from the first.");
      }

      if (!this.dataFormatDetermined) {
        // create the lookup
        this.neuralNetwork.inputLookup = _lookup2.default.lookupFromArray(this.inputKeys);

        if (!Array.isArray(this.firstDatum.output)) {
          this.neuralNetwork.outputLookup = _lookup2.default.lookupFromArray(this.outputKeys);
        }

        var data = this.neuralNetwork.formatData(this.firstDatum);
        var sizes = [];
        var inputSize = data[0].input.length;
        var outputSize = data[0].output.length;
        var hiddenSizes = this.hiddenSizes;

        if (!hiddenSizes) {
          sizes.push(Math.max(3, Math.floor(inputSize / 2)));
        } else {
          hiddenSizes.forEach(function (size) {
            sizes.push(size);
          });
        }

        sizes.unshift(inputSize);
        sizes.push(outputSize);
        this.dataFormatDetermined = true;
        this.neuralNetwork.initialize(sizes);

        if (typeof this.floodCallback === 'function') {
          this.floodCallback();
        }

        return;
      }

      var error = this.sum / this.size;

      if (this.log && this.i % this.logPeriod === 0) {
        this.log('iterations:', this.i, 'training error:', error);
      }

      if (this.callback && this.i % this.callbackPeriod === 0) {
        this.callback({
          error: error,
          iterations: this.i
        });
      }

      this.sum = 0;
      this.count = 0; // update the iterations

      this.i++; // do a check here to see if we need the stream again

      if (this.i < this.iterations && error > this.errorThresh) {
        if (typeof this.floodCallback === 'function') {
          // eslint-disable-next-line
          return this.floodCallback();
        }
      } // done training
      else if (typeof this.doneTrainingCallback === 'function') {
          // eslint-disable-next-line
          return this.doneTrainingCallback({
            error: error,
            iterations: this.i
          });
        }
    }
  }]);

  return TrainStream;
}(_stream.Writable);

exports.default = TrainStream;
},{"stream":"fnRj","./lookup":"Q1a6"}],"HBY8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toArray;
/**
 *
 * @param values
 * @returns {*}
 */

function toArray(values) {
  if (Array.isArray(values)) {
    return values;
  }

  return new Float32Array(Object.values(values));
}
},{}],"UFcl":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = max;

var _toArray = require('./to-array');

var _toArray2 = _interopRequireDefault(_toArray);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}
/**
 *
 * @param values
 * @returns {number}
 */


function max(values) {
  return Math.max.apply(Math, _toConsumableArray((0, _toArray2.default)(values)));
}
},{"./to-array":"HBY8"}],"YGn7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mse;

function mse(errors) {
  // mean squared error
  var sum = 0;

  for (var i = 0; i < errors.length; i++) {
    sum += Math.pow(errors[i], 2);
  }

  return sum / errors.length;
}
},{}],"YhH7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = range;
/**
 *
 * @param start
 * @param end
 * @returns {Array}
 */

function range(start, end) {
  var result = [];

  for (; start < end; start++) {
    result.push(start);
  }

  return result;
}
},{}],"8epZ":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _thaw = require('thaw.js');

var _thaw2 = _interopRequireDefault(_thaw);

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

var _trainStream = require('./train-stream');

var _trainStream2 = _interopRequireDefault(_trainStream);

var _max = require('./utilities/max');

var _max2 = _interopRequireDefault(_max);

var _mse = require('./utilities/mse');

var _mse2 = _interopRequireDefault(_mse);

var _randos = require('./utilities/randos');

var _randos2 = _interopRequireDefault(_randos);

var _range = require('./utilities/range');

var _range2 = _interopRequireDefault(_range);

var _toArray = require('./utilities/to-array');

var _toArray2 = _interopRequireDefault(_toArray);

var _zeros = require('./utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/**
 * @param {object} options
 * @constructor
 */


var NeuralNetwork = function () {
  _createClass(NeuralNetwork, null, [{
    key: '_validateTrainingOptions',

    /**
     *
     * @param options
     * @private
     */
    value: function _validateTrainingOptions(options) {
      var validations = {
        iterations: function iterations(val) {
          return typeof val === 'number' && val > 0;
        },
        errorThresh: function errorThresh(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        log: function log(val) {
          return typeof val === 'function' || typeof val === 'boolean';
        },
        logPeriod: function logPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        learningRate: function learningRate(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        momentum: function momentum(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        callback: function callback(val) {
          return typeof val === 'function' || val === null;
        },
        callbackPeriod: function callbackPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        timeout: function timeout(val) {
          return typeof val === 'number' && val > 0;
        }
      };
      Object.keys(NeuralNetwork.trainDefaults).forEach(function (key) {
        if (validations.hasOwnProperty(key) && !validations[key](options[key])) {
          throw new Error('[' + key + ', ' + options[key] + '] is out of normal training range, your network will probably not train.');
        }
      });
    }
  }, {
    key: 'trainDefaults',
    get: function get() {
      return {
        iterations: 20000,
        // the maximum times to iterate the training data
        errorThresh: 0.005,
        // the acceptable error percentage from training data
        log: false,
        // true to use console.log, when a function is supplied it is used
        logPeriod: 10,
        // iterations between logging out
        learningRate: 0.3,
        // multiply's against the input and the delta then adds to momentum
        momentum: 0.1,
        // multiply's against the specified "change" then adds to learning rate for change
        callback: null,
        // a periodic call back that can be triggered while training
        callbackPeriod: 10,
        // the number of iterations through the training data between callback calls
        timeout: Infinity // the max number of milliseconds to train for

      };
    }
  }, {
    key: 'defaults',
    get: function get() {
      return {
        binaryThresh: 0.5,
        // ¯\_(ツ)_/¯
        hiddenLayers: [3],
        // array of ints for the sizes of the hidden layers in the network
        activation: 'sigmoid' // Supported activation types ['sigmoid', 'relu', 'leaky-relu', 'tanh']

      };
    }
  }]);

  function NeuralNetwork() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NeuralNetwork);

    Object.assign(this, this.constructor.defaults, options);
    this.hiddenSizes = options.hiddenLayers;
    this.trainOpts = {};

    this._updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));

    this.sizes = null;
    this.outputLayer = null;
    this.biases = null; // weights for bias nodes

    this.weights = null;
    this.outputs = null; // state for training

    this.deltas = null;
    this.changes = null; // for momentum

    this.errors = null;
    this.errorCheckInterval = 1;

    if (!this.constructor.prototype.hasOwnProperty('runInput')) {
      this.runInput = null;
    }

    if (!this.constructor.prototype.hasOwnProperty('calculateDeltas')) {
      this.calculateDeltas = null;
    }
  }
  /**
   *
   * Expects this.sizes to have been set
   */


  _createClass(NeuralNetwork, [{
    key: '_initialize',
    value: function _initialize() {
      if (!this.sizes) throw new Error('Sizes must be set before initializing');
      this.outputLayer = this.sizes.length - 1;
      this.biases = []; // weights for bias nodes

      this.weights = [];
      this.outputs = []; // state for training

      this.deltas = [];
      this.changes = []; // for momentum

      this.errors = [];

      for (var layer = 0; layer <= this.outputLayer; layer++) {
        var size = this.sizes[layer];
        this.deltas[layer] = (0, _zeros2.default)(size);
        this.errors[layer] = (0, _zeros2.default)(size);
        this.outputs[layer] = (0, _zeros2.default)(size);

        if (layer > 0) {
          this.biases[layer] = (0, _randos2.default)(size);
          this.weights[layer] = new Array(size);
          this.changes[layer] = new Array(size);

          for (var node = 0; node < size; node++) {
            var prevSize = this.sizes[layer - 1];
            this.weights[layer][node] = (0, _randos2.default)(prevSize);
            this.changes[layer][node] = (0, _zeros2.default)(prevSize);
          }
        }
      }

      this.setActivation();
    }
    /**
     *
     * @param activation supported inputs: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
     */

  }, {
    key: 'setActivation',
    value: function setActivation(activation) {
      this.activation = activation || this.activation;

      switch (this.activation) {
        case 'sigmoid':
          this.runInput = this.runInput || this._runInputSigmoid;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasSigmoid;
          break;

        case 'relu':
          this.runInput = this.runInput || this._runInputRelu;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasRelu;
          break;

        case 'leaky-relu':
          this.runInput = this.runInput || this._runInputLeakyRelu;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasLeakyRelu;
          break;

        case 'tanh':
          this.runInput = this.runInput || this._runInputTanh;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasTanh;
          break;

        default:
          throw new Error('unknown activation ' + this.activation + ', The activation should be one of [\'sigmoid\', \'relu\', \'leaky-relu\', \'tanh\']');
      }
    }
    /**
     *
     * @returns boolean
     */

  }, {
    key: 'run',

    /**
     *
     * @param input
     * @returns {*}
     */
    value: function run(input) {
      if (!this.isRunnable) return null;

      if (this.inputLookup) {
        input = _lookup2.default.toArray(this.inputLookup, input);
      }

      var output = [].concat(_toConsumableArray(this.runInput(input)));

      if (this.outputLookup) {
        output = _lookup2.default.toHash(this.outputLookup, output);
      }

      return output;
    }
    /**
     * trains via sigmoid
     * @param input
     * @returns {*}
     */

  }, {
    key: '_runInputSigmoid',
    value: function _runInputSigmoid(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];
          var sum = this.biases[layer][node];

          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          } // sigmoid


          this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));
        }

        input = this.outputs[layer];
        output = input;
      }

      return output;
    }
  }, {
    key: '_runInputRelu',
    value: function _runInputRelu(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];
          var sum = this.biases[layer][node];

          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          } // relu


          this.outputs[layer][node] = sum < 0 ? 0 : sum;
        }

        input = this.outputs[layer];
        output = input;
      }

      return output;
    }
  }, {
    key: '_runInputLeakyRelu',
    value: function _runInputLeakyRelu(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];
          var sum = this.biases[layer][node];

          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          } // leaky relu


          this.outputs[layer][node] = sum < 0 ? 0 : 0.01 * sum;
        }

        input = this.outputs[layer];
        output = input;
      }

      return output;
    }
  }, {
    key: '_runInputTanh',
    value: function _runInputTanh(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];
          var sum = this.biases[layer][node];

          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          } // tanh


          this.outputs[layer][node] = Math.tanh(sum);
        }

        input = this.outputs[layer];
        output = input;
      }

      return output;
    }
    /**
     *
     * @param data
     * Verifies network sizes are initilaized
     * If they are not it will initialize them based off the data set.
     */

  }, {
    key: '_verifyIsInitialized',
    value: function _verifyIsInitialized(data) {
      var _this = this;

      if (this.sizes) return;
      this.sizes = [];
      this.sizes.push(data[0].input.length);

      if (!this.hiddenSizes) {
        this.sizes.push(Math.max(3, Math.floor(data[0].input.length / 2)));
      } else {
        this.hiddenSizes.forEach(function (size) {
          _this.sizes.push(size);
        });
      }

      this.sizes.push(data[0].output.length);

      this._initialize();
    }
    /**
     *
     * @param opts
     *    Supports all `trainDefaults` properties
     *    also supports:
     *       learningRate: (number),
     *       momentum: (number),
     *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
     */

  }, {
    key: '_updateTrainingOptions',
    value: function _updateTrainingOptions(opts) {
      var _this2 = this;

      Object.keys(NeuralNetwork.trainDefaults).forEach(function (opt) {
        _this2.trainOpts[opt] = opts.hasOwnProperty(opt) ? opts[opt] : _this2.trainOpts[opt];
        return _this2.trainOpts[opt];
      });

      NeuralNetwork._validateTrainingOptions(this.trainOpts);

      this._setLogMethod(opts.log || this.trainOpts.log);

      this.activation = opts.activation || this.activation;
    }
    /**
     *
     *  Gets JSON of trainOpts object
     *    NOTE: Activation is stored directly on JSON object and not in the training options
     */

  }, {
    key: '_getTrainOptsJSON',
    value: function _getTrainOptsJSON() {
      var _this3 = this;

      return Object.keys(NeuralNetwork.trainDefaults).reduce(function (opts, opt) {
        if (opt === 'timeout' && _this3.trainOpts[opt] === Infinity) return opts;
        if (_this3.trainOpts[opt]) opts[opt] = _this3.trainOpts[opt];
        if (opt === 'log') opts.log = typeof opts.log === 'function';
        return opts;
      }, {});
    }
    /**
     *
     * @param log
     * if a method is passed in method is used
     * if false passed in nothing is logged
     * @returns error
     */

  }, {
    key: '_setLogMethod',
    value: function _setLogMethod(log) {
      if (typeof log === 'function') {
        this.trainOpts.log = log;
      } else if (log) {
        this.trainOpts.log = console.log;
      } else {
        this.trainOpts.log = false;
      }
    }
    /**
     *
     * @param data
     * @returns {Number} error
     */

  }, {
    key: '_calculateTrainingError',
    value: function _calculateTrainingError(data) {
      var sum = 0;

      for (var i = 0; i < data.length; ++i) {
        sum += this._trainPattern(data[i].input, data[i].output, true);
      }

      return sum / data.length;
    }
    /**
     * @param data
     * @private
     */

  }, {
    key: '_trainPatterns',
    value: function _trainPatterns(data) {
      for (var i = 0; i < data.length; ++i) {
        this._trainPattern(data[i].input, data[i].output, false);
      }
    }
    /**
     *
     * @param {object} data
     * @param {object} status { iterations: number, error: number }
     * @param endTime
     */

  }, {
    key: '_trainingTick',
    value: function _trainingTick(data, status, endTime) {
      if (status.iterations >= this.trainOpts.iterations || status.error <= this.trainOpts.errorThresh || Date.now() >= endTime) {
        return false;
      }

      status.iterations++;

      if (this.trainOpts.log && status.iterations % this.trainOpts.logPeriod === 0) {
        status.error = this._calculateTrainingError(data);
        this.trainOpts.log('iterations: ' + status.iterations + ', training error: ' + status.error);
      } else if (status.iterations % this.errorCheckInterval === 0) {
        status.error = this._calculateTrainingError(data);
      } else {
        this._trainPatterns(data);
      }

      if (this.trainOpts.callback && status.iterations % this.trainOpts.callbackPeriod === 0) {
        this.trainOpts.callback(Object.assign(status));
      }

      return true;
    }
    /**
     *
     * @param data
     * @param options
     * @protected
     * @return { data, status, endTime }
     */

  }, {
    key: '_prepTraining',
    value: function _prepTraining(data, options) {
      this._updateTrainingOptions(options);

      data = this._formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;
      var status = {
        error: 1,
        iterations: 0
      };

      this._verifyIsInitialized(data);

      return {
        data: data,
        status: status,
        endTime: endTime
      };
    }
    /**
     *
     * @param data
     * @param options
     * @returns {{error: number, iterations: number}}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var status = void 0;
      var endTime = void 0;

      var _prepTraining2 = this._prepTraining(data, options);

      data = _prepTraining2.data;
      status = _prepTraining2.status;
      endTime = _prepTraining2.endTime;

      while (this._trainingTick(data, status, endTime)) {}

      return status;
    }
    /**
     *
     * @param data
     * @param options
     * @returns {Promise}
     * @resolves {{error: number, iterations: number}}
     * @rejects {{trainError: string, status: {error: number, iterations: number}}
     */

  }, {
    key: 'trainAsync',
    value: function trainAsync(data) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var status = void 0;
      var endTime = void 0;

      var _prepTraining3 = this._prepTraining(data, options);

      data = _prepTraining3.data;
      status = _prepTraining3.status;
      endTime = _prepTraining3.endTime;
      return new Promise(function (resolve, reject) {
        try {
          var thawedTrain = new _thaw2.default(new Array(_this4.trainOpts.iterations), {
            delay: true,
            each: function each() {
              return _this4._trainingTick(data, status, endTime) || thawedTrain.stop();
            },
            done: function done() {
              return resolve(status);
            }
          });
          thawedTrain.tick();
        } catch (trainError) {
          reject(new Error({
            trainError: trainError,
            status: status
          }));
        }
      });
    }
    /**
     *
     * @param input
     * @param target
     */

  }, {
    key: '_trainPattern',
    value: function _trainPattern(input, target, logErrorRate) {
      // forward propagate
      this.runInput(input); // back propagate

      this.calculateDeltas(target);

      this._adjustWeights();

      if (logErrorRate) {
        return (0, _mse2.default)(this.errors[this.outputLayer]);
      }

      return null;
    }
    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasSigmoid',
    value: function _calculateDeltasSigmoid(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];
          var error = 0;

          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];

            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }

          this.errors[layer][node] = error;
          this.deltas[layer][node] = error * output * (1 - output);
        }
      }
    }
    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasRelu',
    value: function _calculateDeltasRelu(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];
          var error = 0;

          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];

            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }

          this.errors[layer][node] = error;
          this.deltas[layer][node] = output > 0 ? error : 0;
        }
      }
    }
    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasLeakyRelu',
    value: function _calculateDeltasLeakyRelu(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];
          var error = 0;

          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];

            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }

          this.errors[layer][node] = error;
          this.deltas[layer][node] = output > 0 ? error : 0.01 * error;
        }
      }
    }
    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasTanh',
    value: function _calculateDeltasTanh(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];
          var error = 0;

          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];

            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }

          this.errors[layer][node] = error;
          this.deltas[layer][node] = (1 - output * output) * error;
        }
      }
    }
    /**
     *
     * Changes weights of networks
     */

  }, {
    key: '_adjustWeights',
    value: function _adjustWeights() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        var incoming = this.outputs[layer - 1];

        for (var node = 0; node < this.sizes[layer]; node++) {
          var delta = this.deltas[layer][node];

          for (var k = 0; k < incoming.length; k++) {
            var change = this.changes[layer][node][k];
            change = this.trainOpts.learningRate * delta * incoming[k] + this.trainOpts.momentum * change;
            this.changes[layer][node][k] = change;
            this.weights[layer][node][k] += change;
          }

          this.biases[layer][node] += this.trainOpts.learningRate * delta;
        }
      }
    }
    /**
     *
     * @param data
     * @returns {*}
     */

  }, {
    key: '_formatData',
    value: function _formatData(data) {
      var _this5 = this;

      if (!Array.isArray(data)) {
        // turn stream datum into array
        var tmp = [];
        tmp.push(data);
        data = tmp;
      } // turn sparse hash input into arrays with 0s as filler


      var datumCheck = data[0].input;

      if (!Array.isArray(datumCheck) && !(datumCheck instanceof Float32Array)) {
        if (!this.inputLookup) {
          this.inputLookup = _lookup2.default.buildLookup(data.map(function (value) {
            return value.input;
          }));
        }

        data = data.map(function (datum) {
          var array = _lookup2.default.toArray(_this5.inputLookup, datum.input);

          return Object.assign({}, datum, {
            input: array
          });
        }, this);
      }

      if (!Array.isArray(data[0].output)) {
        if (!this.outputLookup) {
          this.outputLookup = _lookup2.default.buildLookup(data.map(function (value) {
            return value.output;
          }));
        }

        data = data.map(function (datum) {
          var array = _lookup2.default.toArray(_this5.outputLookup, datum.output);

          return Object.assign({}, datum, {
            output: array
          });
        }, this);
      }

      return data;
    }
    /**
     *
     * @param data
     * @returns {
     *  {
     *    error: number,
     *    misclasses: Array
     *  }
     * }
     */

  }, {
    key: 'test',
    value: function test(data) {
      var _this6 = this;

      data = this._formatData(data); // for binary classification problems with one output node

      var isBinary = data[0].output.length === 1;
      var falsePos = 0;
      var falseNeg = 0;
      var truePos = 0;
      var trueNeg = 0; // for classification problems

      var misclasses = []; // run each pattern through the trained network and collect
      // error and misclassification statistics

      var sum = 0;

      var _loop = function _loop(i) {
        var output = _this6.runInput(data[i].input);

        var target = data[i].output;
        var actual = void 0;
        var expected = void 0;

        if (isBinary) {
          actual = output[0] > _this6.binaryThresh ? 1 : 0; // eslint-disable-next-line

          expected = target[0];
        } else {
          actual = output.indexOf((0, _max2.default)(output));
          expected = target.indexOf((0, _max2.default)(target));
        }

        if (actual !== expected) {
          var misclass = data[i];
          Object.assign(misclass, {
            actual: actual,
            expected: expected
          });
          misclasses.push(misclass);
        }

        if (isBinary) {
          if (actual === 0 && expected === 0) {
            trueNeg++;
          } else if (actual === 1 && expected === 1) {
            truePos++;
          } else if (actual === 0 && expected === 1) {
            falseNeg++;
          } else if (actual === 1 && expected === 0) {
            falsePos++;
          }
        }

        var errors = output.map(function (value, j) {
          return target[j] - value;
        });
        sum += (0, _mse2.default)(errors);
      };

      for (var i = 0; i < data.length; i++) {
        _loop(i);
      }

      var error = sum / data.length;
      var stats = {
        error: error,
        misclasses: misclasses
      };

      if (isBinary) {
        Object.assign(stats, {
          trueNeg: trueNeg,
          truePos: truePos,
          falseNeg: falseNeg,
          falsePos: falsePos,
          total: data.length,
          precision: truePos / (truePos + falsePos),
          recall: truePos / (truePos + falseNeg),
          accuracy: (trueNeg + truePos) / data.length
        });
      }

      return stats;
    }
    /**
     *
     * @returns
     *  {
     *    layers: [
     *      {
     *        x: {},
     *        y: {}
     *      },
     *      {
     *        '0': {
     *          bias: -0.98771313,
     *          weights: {
     *            x: 0.8374838,
     *            y: 1.245858
     *          },
     *        '1': {
     *          bias: 3.48192004,
     *          weights: {
     *            x: 1.7825821,
     *            y: -2.67899
     *          }
     *        }
     *      },
     *      {
     *        f: {
     *          bias: 0.27205739,
     *          weights: {
     *            '0': 1.3161821,
     *            '1': 2.00436
     *          }
     *        }
     *      }
     *    ]
     *  }
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var _this7 = this;

      var layers = [];

      var _loop2 = function _loop2(layer) {
        layers[layer] = [];
        var nodes = void 0; // turn any internal arrays back into hashes for readable json

        if (layer === 0 && _this7.inputLookup) {
          nodes = Object.keys(_this7.inputLookup);
        } else if (layer === _this7.outputLayer && _this7.outputLookup) {
          nodes = Object.keys(_this7.outputLookup);
        } else {
          nodes = (0, _range2.default)(0, _this7.sizes[layer]);
        }

        var _loop3 = function _loop3(j) {
          var node = nodes[j];
          layers[layer][node] = {};

          if (layer > 0) {
            layers[layer][node].bias = _this7.biases[layer][j];
            layers[layer][node].weights = [];
            Object.keys(layers[layer - 1]).forEach(function (k) {
              var index = k;

              if (layer === 1 && _this7.inputLookup) {
                index = _this7.inputLookup[k];
              }

              layers[layer][node].weights[k] = _this7.weights[layer][j][index];
            });
          }
        };

        for (var j = 0; j < nodes.length; j++) {
          _loop3(j);
        }
      };

      for (var layer = 0; layer <= this.outputLayer; layer++) {
        _loop2(layer);
      }

      return {
        sizes: this.sizes,
        layers: layers,
        outputLookup: !!this.outputLookup,
        inputLookup: !!this.inputLookup,
        activation: this.activation,
        trainOpts: this._getTrainOptsJSON()
      };
    }
    /**
     *
     * @param json
     * @returns {NeuralNetwork}
     */

  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var _this8 = this;

      this.sizes = json.sizes;

      this._initialize();

      var _loop4 = function _loop4(i) {
        var layer = json.layers[i];

        if (i === 0 && (!layer[0] || json.inputLookup)) {
          _this8.inputLookup = _lookup2.default.lookupFromHash(layer);
        } else if (i === _this8.outputLayer && (!layer[0] || json.outputLookup)) {
          _this8.outputLookup = _lookup2.default.lookupFromHash(layer);
        }

        if (i > 0) {
          var _nodes = Object.keys(layer);

          _this8.sizes[i] = _nodes.length;
          Object.keys(_nodes).forEach(function (j) {
            var node = _nodes[j];
            _this8.biases[i][j] = layer[node].bias;
            _this8.weights[i][j] = (0, _toArray2.default)(layer[node].weights);
          });
        }
      };

      for (var i = 0; i <= this.outputLayer; i++) {
        _loop4(i);
      }

      if (json.hasOwnProperty('trainOpts')) {
        this._updateTrainingOptions(json.trainOpts);
      }

      this.setActivation(this.activation || 'sigmoid');
      return this;
    }
    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      var activation = this.activation;

      function nodeHandle(layers, layerNumber, nodeKey) {
        if (layerNumber === 0) {
          return typeof nodeKey === 'string' ? 'input[\'' + nodeKey + '\']' : 'input[' + nodeKey + ']';
        }

        var layer = layers[layerNumber];
        var node = layer[nodeKey];
        var result = [node.bias];
        Object.keys(node.weights).forEach(function (w) {
          if (node.weights[w] < 0) {
            result.push(node.weights[w] + '*(' + nodeHandle(layers, layerNumber - 1, w) + ')');
          } else {
            result.push('+' + node.weights[w] + '*(' + nodeHandle(layers, layerNumber - 1, w) + ')');
          }
        });

        switch (activation) {
          case 'sigmoid':
            return '1/(1+1/Math.exp(' + result.join('') + '))';

          case 'relu':
            return 'var sum = ' + result.join('') + ';(sum < 0 ? 0 : sum);';

          case 'leaky-relu':
            return 'var sum = ' + result.join('') + ';(sum < 0 ? 0 : 0.01 * sum);';

          case 'tanh':
            return 'Math.tanh(' + result.join('') + ');';

          default:
            throw new Error('unknown activation type ' + activation);
        }
      }

      var _toJSON = this.toJSON(),
          layers = _toJSON.layers;

      var layersAsMath = [];
      var result = void 0;
      Object.keys(layers[layers.length - 1]).forEach(function (l) {
        layersAsMath.push(nodeHandle(layers, layers.length - 1, l));
      });

      if (this.outputLookup) {
        result = '{' + Object.keys(this.outputLookup).map(function (key, i) {
          return '\'' + key + '\':' + layersAsMath[i];
        }) + '}';
      } else {
        result = '[' + layersAsMath.join(',') + ']';
      } // eslint-disable-next-line


      return new Function('input', 'return ' + result);
    }
    /**
     * This will create a TrainStream (WriteStream) for us to send the training data to.
     * @param opts training options
     * @returns {TrainStream|*}
     */

  }, {
    key: 'createTrainStream',
    value: function createTrainStream(opts) {
      opts = opts || {};
      opts.neuralNetwork = this;
      this.setActivation();
      this.trainStream = new _trainStream2.default(opts);
      return this.trainStream;
    }
  }, {
    key: 'isRunnable',
    get: function get() {
      var _this9 = this;

      if (!this.runInput) {
        console.error('Activation function has not been initialized, did you run train()?');
        return false;
      }

      var checkFns = ['sizes', 'outputLayer', 'biases', 'weights', 'outputs', 'deltas', 'changes', 'errors'].filter(function (c) {
        return _this9[c] === null;
      });

      if (checkFns.length > 0) {
        console.error('Some settings have not been initialized correctly, did you run train()? Found issues with: ' + checkFns.join(', '));
        return false;
      }

      return true;
    }
  }]);

  return NeuralNetwork;
}();

exports.default = NeuralNetwork;
},{"thaw.js":"8AZL","./lookup":"Q1a6","./train-stream":"vEEq","./utilities/max":"UFcl","./utilities/mse":"YGn7","./utilities/randos":"S8tM","./utilities/range":"YhH7","./utilities/to-array":"HBY8","./utilities/zeros":"M4LY"}],"6trg":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var _gpu = require('gpu.js');

var _neuralNetwork = require('./neural-network');

var _neuralNetwork2 = _interopRequireDefault(_neuralNetwork);

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function weightedSumSigmoid(weights, biases, inputs) {
  var sum = biases[this.thread.x];

  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  } // sigmoid


  return 1 / (1 + Math.exp(-sum));
}

function weightedSumRelu(weights, biases, inputs) {
  var sum = biases[this.thread.x];

  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  } // relu


  return sum < 0 ? 0 : sum;
}

function weightedSumLeakyRelu(weights, biases, inputs) {
  var sum = biases[this.thread.x];

  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  } // leaky relu


  return sum < 0 ? 0 : 0.01 * sum;
}

function weightedSumTanh(weights, biases, inputs) {
  var sum = biases[this.thread.x];

  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  } // tanh


  return Math.tanh(sum);
}

function calcErrorOutput(output, targets) {
  return targets[this.thread.x] - output;
}

function calcDeltasSigmoid(error, output) {
  // sigmoid derivative
  return error * output * (1 - output);
}

function calcDeltasRelu(error, output) {
  // relu derivative
  return output > 0 ? error : 0;
}

function calcDeltasLeakyRelu(error, output) {
  // leaky relu derivative
  return output > 0 ? error : 0.01 * error;
}

function calcDeltasTanh(error, output) {
  // tanh derivative
  return (1 - output * output) * error;
}

function calcError(nextWeights, nextDeltas) {
  var error = 0;

  for (var k = 0; k < this.constants.size; k++) {
    error += nextDeltas[k] * nextWeights[k][this.thread.x];
  }

  return error;
}

function calcChanges(previousChanges, deltas, previousOutputs) {
  return this.constants.learningRate * deltas[this.thread.y] * previousOutputs[this.thread.x] + this.constants.momentum * previousChanges[this.thread.y][this.thread.x];
}

function addWeights(change, weights) {
  return change + weights[this.thread.y][this.thread.x];
}

function addBiases(biases, deltas) {
  return biases[this.thread.x] + deltas[this.thread.x] * this.constants.learningRate;
} // mean squared error, reimplemented for GPU


function mse(errors) {
  var sum = 0;

  for (var i = 0; i < this.constants.size; i++) {
    sum += Math.pow(errors[i], 2);
  }

  return sum / this.constants.size;
}
/**
 *
 * @param {object} options
 * @constructor
 */


var NeuralNetworkGPU = function (_NeuralNetwork) {
  _inherits(NeuralNetworkGPU, _NeuralNetwork);

  function NeuralNetworkGPU() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NeuralNetworkGPU);

    var _this = _possibleConstructorReturn(this, (NeuralNetworkGPU.__proto__ || Object.getPrototypeOf(NeuralNetworkGPU)).call(this, options));

    _this.forwardPropagate = [];
    _this.backwardPropagate = [];
    _this.changesPropagate = [];
    _this.biasesPropagate = [];
    _this.biasCopies = [];
    _this.copyBias = [];
    _this.changesCopies = [];
    _this.copyChanges = [];
    _this.weightsCopies = [];
    _this.copyWeights = [];
    _this.errorCheckInterval = 100;
    _this.gpu = new _gpu.GPU({
      mode: options.mode
    });
    return _this;
  }
  /**
   *
   */


  _createClass(NeuralNetworkGPU, [{
    key: '_initialize',
    value: function _initialize() {
      _get(NeuralNetworkGPU.prototype.__proto__ || Object.getPrototypeOf(NeuralNetworkGPU.prototype), '_initialize', this).call(this);

      this.buildRunInput();
      this.buildCalculateDeltas();
      this.buildGetChanges();
      this.buildChangeBiases();
      this.buildGetMSE();
    }
  }, {
    key: 'setActivation',
    value: function setActivation() {
      return;
      throw new Error(this.constructor.name + '-setActivation is not yet implemented');
    }
    /**
     *
     * @param input
     * @param target
     * @param logErrorRate
     */

  }, {
    key: '_trainPattern',
    value: function _trainPattern(input, target, logErrorRate) {
      // forward propagate
      this.runInput(input); // backward propagate

      this.calculateDeltas(target);
      this.getChanges();
      this.changeBiases();

      if (logErrorRate) {
        return this.getMSE(this.errors[this.outputLayer])[0];
      }

      return null;
    }
  }, {
    key: 'buildRunInput',
    value: function buildRunInput() {
      var _this2 = this;

      var weightedSum = null;

      switch (this.activation) {
        case 'sigmoid':
          weightedSum = weightedSumSigmoid;
          break;

        case 'relu':
          weightedSum = weightedSumRelu;
          break;

        case 'leaky-relu':
          weightedSum = weightedSumLeakyRelu;
          break;

        case 'tanh':
          weightedSum = weightedSumTanh;
          break;

        default:
          throw new Error('unknown activation ' + this.activation);
      }

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.forwardPropagate[layer] = this.gpu.createKernel(weightedSum, {
          output: [this.sizes[layer]],
          pipeline: true,
          constants: {
            size: this.sizes[layer - 1]
          }
        });
      }

      this._texturizeInputData = this.gpu.createKernel(function (value) {
        return value[_this2.thread.x];
      }, {
        output: [this.sizes[1]],
        pipeline: true,
        immutable: true
      });
    }
    /**
     *
     * @param input
     * @returns {*}
     */

  }, {
    key: 'runInput',
    value: function runInput(input) {
      var output = void 0;
      this.outputs[0] = input;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.outputs[layer] = this.forwardPropagate[layer](this.weights[layer], this.biases[layer], input);
        input = this.outputs[layer];
        output = input;
      }

      return output;
    }
  }, {
    key: 'buildCalculateDeltas',
    value: function buildCalculateDeltas() {
      var calcDeltas = null;

      switch (this.activation) {
        case 'sigmoid':
          calcDeltas = calcDeltasSigmoid;
          break;

        case 'relu':
          calcDeltas = calcDeltasRelu;
          break;

        case 'leaky-relu':
          calcDeltas = calcDeltasLeakyRelu;
          break;

        case 'tanh':
          calcDeltas = calcDeltasTanh;
          break;

        default:
          throw new Error('unknown activation ' + this.activation);
      }

      for (var layer = this.outputLayer; layer > 0; layer--) {
        if (layer === this.outputLayer) {
          this.backwardPropagate[layer] = this.gpu.createKernelMap({
            error: (0, _gpu.alias)('calcErrorOutput', calcErrorOutput),
            deltas: (0, _gpu.alias)('calcDeltas', calcDeltas)
          }, function (outputs, targets) {
            var output = outputs[this.thread.x];
            return calcDeltas(calcErrorOutput(output, targets), output);
          }, {
            output: [this.sizes[layer]],
            pipeline: true
          });
        } else {
          this.backwardPropagate[layer] = this.gpu.createKernelMap({
            error: (0, _gpu.alias)('calcError', calcError),
            deltas: (0, _gpu.alias)('calcDeltas', calcDeltas)
          }, function (nextWeights, outputs, nextDeltas) {
            var output = outputs[this.thread.x];
            return calcDeltas(calcError(nextWeights, nextDeltas), output);
          }, {
            output: [this.sizes[layer]],
            pipeline: true,
            constants: {
              size: this.deltas[layer + 1].length
            }
          });
        }
      }
    }
  }, {
    key: 'calculateDeltas',
    value: function calculateDeltas(target) {
      for (var layer = this.outputLayer; layer > 0; layer--) {
        var output = void 0;

        if (layer === this.outputLayer) {
          output = this.backwardPropagate[layer](this.outputs[layer], target);
        } else {
          output = this.backwardPropagate[layer](this.weights[layer + 1], this.outputs[layer], this.deltas[layer + 1]);
        }

        this.deltas[layer] = output.deltas;
        this.errors[layer] = output.error;
      }
    }
  }, {
    key: 'buildGetChanges',
    value: function buildGetChanges() {
      var _this3 = this;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.changesPropagate[layer] = this.gpu.createKernelMap({
          weights: (0, _gpu.alias)('addWeights', addWeights),
          changes: (0, _gpu.alias)('calcChanges', calcChanges)
        }, function (previousOutputs, deltas, weights, changes) {
          var change = calcChanges(changes, deltas, previousOutputs);
          return addWeights(change, weights);
        }, {
          output: [this.sizes[layer - 1], this.sizes[layer]],
          pipeline: true,
          constants: {
            size: this.outputs[layer - 1].length,
            learningRate: this.trainOpts.learningRate,
            momentum: this.trainOpts.momentum
          }
        });
        this.copyChanges[layer] = this.gpu.createKernel(function (value) {
          return value[_this3.thread.y][_this3.thread.x];
        }, {
          output: this.changesPropagate[layer].output,
          pipeline: true
        });
        this.copyWeights[layer] = this.gpu.createKernel(function (value) {
          return value[_this3.thread.y][_this3.thread.x];
        }, {
          output: this.changesPropagate[layer].output,
          pipeline: true
        });
      }
    }
  }, {
    key: 'getChanges',
    value: function getChanges() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        var output = this.changesPropagate[layer](this.outputs[layer - 1], this.deltas[layer], this.weightsCopies[layer] || this.weights[layer], this.changesCopies[layer] || this.changes[layer]);
        this.changes[layer] = output.changes;
        this.weights[layer] = output.weights;
        this.changesCopies[layer] = this.copyChanges[layer](output.changes);
        this.weightsCopies[layer] = this.copyWeights[layer](output.weights);
      }
    }
  }, {
    key: 'buildChangeBiases',
    value: function buildChangeBiases() {
      var _this4 = this;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.biasesPropagate[layer] = this.gpu.createKernel(addBiases, {
          output: [this.sizes[layer]],
          pipeline: true,
          constants: {
            learningRate: this.trainOpts.learningRate
          }
        });
        this.copyBias[layer] = this.gpu.createKernel(function (value) {
          return value[_this4.thread.x];
        }, {
          output: this.biasesPropagate[layer].output,
          pipeline: true
        });
      }
    }
  }, {
    key: 'changeBiases',
    value: function changeBiases() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.biases[layer] = this.biasesPropagate[layer](this.biasCopies[layer] || this.biases[layer], this.deltas[layer]);
        this.biasCopies[layer] = this.copyBias[layer](this.biases[layer]);
      }
    }
  }, {
    key: 'buildGetMSE',
    value: function buildGetMSE() {
      this.getMSE = this.gpu.createKernel(mse, {
        output: [1],
        constants: {
          size: this.sizes[this.outputLayer]
        }
      });
    }
    /**
     *
     * @param input
     * @returns {*}
     */

  }, {
    key: 'run',
    value: function run(input) {
      if (!this.isRunnable) return null;

      if (this.inputLookup) {
        input = _lookup2.default.toArray(this.inputLookup, input);
      }

      var inputTexture = this._texturizeInputData(input);

      var outputTextures = this.runInput(inputTexture);
      var output = outputTextures.toArray(this.gpu);

      if (this.outputLookup) {
        output = _lookup2.default.toHash(this.outputLookup, output);
      }

      return output;
    }
    /**
     *
     * @param data
     * Verifies network sizes are initilaized
     * If they are not it will initialize them based off the data set.
     */

  }, {
    key: '_verifyIsInitialized',
    value: function _verifyIsInitialized(data) {
      var _this5 = this;

      if (this.sizes) return;
      this.sizes = [];

      if (!data[0].size) {
        data[0].size = {
          input: data[0].input.length,
          output: data[0].output.length
        };
      }

      this.sizes.push(data[0].size.input);

      if (!this.hiddenSizes) {
        this.sizes.push(Math.max(3, Math.floor(data[0].size.input / 2)));
      } else {
        this.hiddenSizes.forEach(function (size) {
          _this5.sizes.push(size);
        });
      }

      this.sizes.push(data[0].size.output);

      this._initialize();
    }
    /**
     *
     * @param data
     * @param options
     * @protected
     * @return { data, status, endTime }
     */

  }, {
    key: '_prepTraining',
    value: function _prepTraining(data, options) {
      var _this6 = this;

      this._updateTrainingOptions(options);

      data = this._formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;
      var status = {
        error: 1,
        iterations: 0
      };

      this._verifyIsInitialized(data);

      var texturizeOutputData = this.gpu.createKernel(function (value) {
        return value[_this6.thread.x];
      }, {
        output: [data[0].output.length],
        pipeline: true,
        immutable: true
      });
      return {
        data: data.map(function (set) {
          return {
            size: set.size,
            input: _this6._texturizeInputData(set.input),
            output: texturizeOutputData(set.output)
          };
        }),
        status: status,
        endTime: endTime
      };
    }
  }, {
    key: 'toFunction',
    value: function toFunction() {
      throw new Error(this.constructor.name + '-toFunction is not yet implemented');
    }
  }]);

  return NeuralNetworkGPU;
}(_neuralNetwork2.default);

exports.default = NeuralNetworkGPU;
},{"gpu.js":"Ft/B","./neural-network":"8epZ","./lookup":"Q1a6"}],"sLgS":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _types = require('./types');

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var RecurrentConnection = function (_Internal) {
  _inherits(RecurrentConnection, _Internal);

  function RecurrentConnection() {
    _classCallCheck(this, RecurrentConnection);

    return _possibleConstructorReturn(this, (RecurrentConnection.__proto__ || Object.getPrototypeOf(RecurrentConnection)).apply(this, arguments));
  }

  _createClass(RecurrentConnection, [{
    key: 'setLayer',
    value: function setLayer(layer) {
      this.layer = layer;
    }
  }, {
    key: 'predict',
    value: function predict() {// throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }, {
    key: 'learn',
    value: function learn() {
      this.layer.deltas = (0, _zeros2d2.default)(this.width, this.height);
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {// throw new Error(
      //   `${this.constructor.name}-setupKernels is not yet implemented`
      // )
    }
  }, {
    key: 'reuseKernels',
    value: function reuseKernels() {// throw new Error(
      //   `${this.constructor.name}-reuseKernels is not yet implemented`
      // )
    }
  }, {
    key: 'width',
    get: function get() {
      return this.layer.width;
    },
    set: function set(value) {
      throw new Error(this.constructor.name + '-width is not yet implemented');
    }
  }, {
    key: 'height',
    get: function get() {
      return this.layer.height;
    },
    set: function set(value) {
      throw new Error(this.constructor.name + '-height is not yet implemented');
    }
  }, {
    key: 'deltas',
    get: function get() {
      return this.layer.deltas;
    },
    set: function set(deltas) {
      this.layer.deltas = deltas;
    }
  }, {
    key: 'weights',
    get: function get() {
      return this.layer.weights;
    },
    set: function set(weights) {
      this.layer.weights = weights;
    }
  }]);

  return RecurrentConnection;
}(_types.Internal);

exports.default = RecurrentConnection;
},{"./types":"pX1U","../utilities/zeros-2d":"C4Cz"}],"kvWK":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _types = require('./types');

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // import zeros2D from '../utilities/zeros-2d'


var RecurrentInput = function (_Internal) {
  _inherits(RecurrentInput, _Internal);

  function RecurrentInput() {
    _classCallCheck(this, RecurrentInput);

    return _possibleConstructorReturn(this, (RecurrentInput.__proto__ || Object.getPrototypeOf(RecurrentInput)).apply(this, arguments));
  }

  _createClass(RecurrentInput, [{
    key: 'setRecurrentInput',
    value: function setRecurrentInput(recurrentInput) {
      this.recurrentInput = recurrentInput;
      this.validate();
    }
  }, {
    key: 'validate',
    value: function validate() {
      _base2.default.prototype.validate.call(this);

      if (this.width !== this.recurrentInput.width) {
        throw new Error(this.constructor.name + ' layer width ' + this.width + ' and ' + this.recurrentInput.constructor.name + ' width (' + this.recurrentInput.width + ') are not same');
      }

      if (this.height !== this.recurrentInput.height) {
        throw new Error(this.constructor.name + ' layer height ' + this.height + ' and ' + this.recurrentInput.constructor.name + ' width (' + this.recurrentInput.height + ') are not same');
      }
    }
  }, {
    key: 'setDimensions',
    value: function setDimensions(width, height) {
      this.width = width;
      this.height = height;
    }
  }, {
    key: 'predict',
    value: function predict() {// throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }, {
    key: 'learn',
    value: function learn() {// throw new Error(`${this.constructor.name}-learn is not yet implemented`)
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {// throw new Error(
      //   `${this.constructor.name}-setupKernels is not yet implemented`
      // )
    }
  }, {
    key: 'reuseKernels',
    value: function reuseKernels() {// throw new Error(
      //   `${this.constructor.name}-reuseKernels is not yet implemented`
      // )
    }
  }, {
    key: 'deltas',
    get: function get() {
      return this.recurrentInput.deltas;
    },
    set: function set(deltas) {
      this.recurrentInput.deltas = deltas;
    }
  }, {
    key: 'weights',
    get: function get() {
      return this.recurrentInput.weights;
    },
    set: function set(weights) {
      this.recurrentInput.weights = weights;
    }
  }]);

  return RecurrentInput;
}(_types.Internal);

exports.default = RecurrentInput;
},{"./types":"pX1U","./base":"kIeX"}],"7ZE4":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _zeros2d = require('../utilities/zeros-2d');

var _zeros2d2 = _interopRequireDefault(_zeros2d);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var RecurrentZeros = function (_Internal) {
  _inherits(RecurrentZeros, _Internal);

  function RecurrentZeros() {
    _classCallCheck(this, RecurrentZeros);

    return _possibleConstructorReturn(this, (RecurrentZeros.__proto__ || Object.getPrototypeOf(RecurrentZeros)).apply(this, arguments));
  }

  _createClass(RecurrentZeros, [{
    key: 'setDimensions',
    value: function setDimensions(width, height) {
      this.praxis = null;
      this.width = width;
      this.height = height;
      this.weights = (0, _zeros2d2.default)(width, height);
      this.deltas = (0, _zeros2d2.default)(width, height);
    }
  }, {
    key: 'setupKernels',
    value: function setupKernels() {// throw new Error(
      //   `${this.constructor.name}-setupKernels is not yet implemented`
      // )
    }
  }, {
    key: 'reuseKernels',
    value: function reuseKernels() {// throw new Error(
      //   `${this.constructor.name}-reuseKernels is not yet implemented`
      // )
    }
  }, {
    key: 'predict',
    value: function predict() {// throw new Error(`${this.constructor.name}-predict is not yet implemented`)
    }
  }, {
    key: 'compare',
    value: function compare() {// throw new Error(`${this.constructor.name}-compare is not yet implemented`)
    }
  }, {
    key: 'learn',
    value: function learn(previousLayer, nextLayer, learningRate) {
      this.weights = this.praxis.run(this, previousLayer, nextLayer, learningRate);
      this.deltas = (0, _zeros2d2.default)(this.width, this.height);
    }
  }, {
    key: 'validate',
    value: function validate() {
      throw new Error(this.constructor.name + '-validate is not yet implemented');
    }
  }, {
    key: 'reset',
    value: function reset() {
      throw new Error(this.constructor.name + '-reset is not yet implemented');
    }
  }]);

  return RecurrentZeros;
}(_types.Internal);

exports.default = RecurrentZeros;
},{"../utilities/zeros-2d":"C4Cz","./types":"pX1U"}],"JVtt":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var _recurrentConnection = require('./layer/recurrent-connection');

var _recurrentConnection2 = _interopRequireDefault(_recurrentConnection);

var _recurrentInput = require('./layer/recurrent-input');

var _recurrentInput2 = _interopRequireDefault(_recurrentInput);

var _recurrentZeros = require('./layer/recurrent-zeros');

var _recurrentZeros2 = _interopRequireDefault(_recurrentZeros);

var _flattenLayers = require('./utilities/flatten-layers');

var _flattenLayers2 = _interopRequireDefault(_flattenLayers);

var _mse2d = require('./utilities/mse-2d');

var _mse2d2 = _interopRequireDefault(_mse2d);

var _feedForward = require('./feed-forward');

var _feedForward2 = _interopRequireDefault(_feedForward);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // import Base from './layer/base'


var Recurrent = function (_FeedForward) {
  _inherits(Recurrent, _FeedForward);

  function Recurrent() {
    _classCallCheck(this, Recurrent);

    return _possibleConstructorReturn(this, (Recurrent.__proto__ || Object.getPrototypeOf(Recurrent)).apply(this, arguments));
  }

  _createClass(Recurrent, [{
    key: '_connectLayers',
    value: function _connectLayers() {
      var initialLayers = [];
      var inputLayer = this.inputLayer();

      var hiddenLayers = this._connectHiddenLayers(inputLayer);

      this._outputConnection.setLayer(hiddenLayers[hiddenLayers.length - 1]);

      var outputLayer = this.outputLayer(this._outputConnection, hiddenLayers.length);
      initialLayers.push(inputLayer);
      initialLayers.push.apply(initialLayers, _toConsumableArray(hiddenLayers));
      initialLayers.push(outputLayer);
      var flattenedLayers = (0, _flattenLayers2.default)(initialLayers);
      this._inputLayers = flattenedLayers.slice(0, flattenedLayers.indexOf(inputLayer) + 1);
      this._hiddenLayers = [flattenedLayers.slice(flattenedLayers.indexOf(inputLayer) + 1, flattenedLayers.indexOf(hiddenLayers[hiddenLayers.length - 1]) + 1)];
      this._outputLayers = flattenedLayers.slice(flattenedLayers.indexOf(hiddenLayers[hiddenLayers.length - 1]) + 1);

      this._outputLayers.unshift();

      this._recurrentIndices = [];
      this._model = [];

      for (var i = 0; i < this._hiddenLayers[0].length; i++) {
        if (Object.getPrototypeOf(this._hiddenLayers[0][i].constructor).name === 'Model') {
          this._model.push(this._hiddenLayers[0][i]);

          this._hiddenLayers[0].splice(i, 1);
        }
      }

      for (var _i = 0; _i < hiddenLayers.length; _i++) {
        this._recurrentIndices.push(this._hiddenLayers[0].indexOf(hiddenLayers[_i]));
      }
    }
  }, {
    key: '_connectHiddenLayers',
    value: function _connectHiddenLayers(previousLayer) {
      var hiddenLayers = [];

      for (var i = 0; i < this.hiddenLayers.length; i++) {
        var recurrentInput = new _recurrentZeros2.default();
        var hiddenLayer = this.hiddenLayers[i](previousLayer, recurrentInput, i);
        previousLayer = hiddenLayer;
        hiddenLayers.push(hiddenLayer);
      }

      return hiddenLayers;
    }
  }, {
    key: '_connectHiddenLayersDeep',
    value: function _connectHiddenLayersDeep() {
      var hiddenLayers = [];
      var previousHiddenLayers = this._hiddenLayers[this._hiddenLayers.length - 1];
      var firstLayer = this._hiddenLayers[0];
      var recurrentIndex = 0;

      for (var i = 0; i < previousHiddenLayers.length; i++) {
        var previousHiddenLayer = previousHiddenLayers[i];
        var layer = null;

        switch (Object.getPrototypeOf(firstLayer[i].constructor).name) {
          case 'Activation':
            {
              var inputLayer = hiddenLayers[previousHiddenLayers.indexOf(previousHiddenLayer.inputLayer)] || previousHiddenLayer.inputLayer;
              layer = new previousHiddenLayer.constructor(inputLayer);
              break;
            }

          case 'Filter':
            {
              var settings = previousHiddenLayer;

              var _inputLayer = hiddenLayers[previousHiddenLayers.indexOf(previousHiddenLayer.inputLayer)] || previousHiddenLayer.inputLayer;

              layer = new previousHiddenLayer.constructor(settings, _inputLayer);
              break;
            }

          case 'Internal':
            {
              switch (previousHiddenLayer.constructor.name) {
                case 'RecurrentConnection':
                  break;

                case 'RecurrentInput':
                case 'RecurrentZeros':
                default:
                  layer = new _recurrentInput2.default();
                  layer.setDimensions(previousHiddenLayer.width, previousHiddenLayer.height);
                  layer.setRecurrentInput(previousHiddenLayers[this._recurrentIndices[recurrentIndex]]);
                  recurrentIndex++;
                  break;
              }

              break;
            }

          case 'Model':
            {
              layer = previousHiddenLayer;
              break;
            }

          case 'Modifier':
            {
              var _inputLayer2 = hiddenLayers[previousHiddenLayers.indexOf(previousHiddenLayer.inputLayer)] || previousHiddenLayer.inputLayer;

              layer = new previousHiddenLayer.constructor(_inputLayer2);
              break;
            }

          case 'Operator':
            {
              var inputLayer1 = hiddenLayers[previousHiddenLayers.indexOf(previousHiddenLayer.inputLayer1)] || previousHiddenLayer.inputLayer1;
              var inputLayer2 = hiddenLayers[previousHiddenLayers.indexOf(previousHiddenLayer.inputLayer2)] || previousHiddenLayer.inputLayer2;
              layer = new previousHiddenLayer.constructor(inputLayer1, inputLayer2);
              break;
            }

          default:
            throw new Error('hidden layer ' + previousHiddenLayer.constructor.name + ' extends unknown hidden layer ' + Object.getPrototypeOf(previousHiddenLayer.constructor).name);
        }

        hiddenLayers[i] = layer;
      }

      this._hiddenLayers.push(hiddenLayers);

      return hiddenLayers;
    }
  }, {
    key: 'initialize',
    value: function initialize() {
      this._previousInputs = [];
      this._outputConnection = new _recurrentConnection2.default();

      this._connectLayers();

      this.initializeLayers(this._model);
      this.initializeLayers(this._inputLayers);
      this.initializeLayers(this._hiddenLayers[0]);
      this.initializeLayers(this._outputLayers);
    }
  }, {
    key: 'initializeDeep',
    value: function initializeDeep() {
      var hiddenLayers = this._connectHiddenLayersDeep();

      for (var i = 0; i < hiddenLayers.length; i++) {
        var hiddenLayer = hiddenLayers[i];
        hiddenLayer.reuseKernels(this._hiddenLayers[0][i]);
      }
    }
  }, {
    key: 'runInput',
    value: function runInput(input) {
      var max = input.length - 1;

      for (var x = 0; x < max; x++) {
        var hiddenLayers = this._hiddenLayers[x];
        var hiddenConnection = hiddenLayers[hiddenLayers.length - 1];

        this._outputConnection.setLayer(hiddenConnection);

        this._inputLayers[0].predict([input[x]]);

        this._previousInputs.push(this._inputLayers[0].weights);

        for (var i = 1; i < this._inputLayers.length; i++) {
          this._inputLayers[i].predict();
        }

        for (var _i2 = 0; _i2 < this._hiddenLayers[x].length; _i2++) {
          this._hiddenLayers[x][_i2].predict();
        }

        for (var _i3 = 0; _i3 < this._outputLayers.length; _i3++) {
          this._outputLayers[_i3].predict();
        }
      }

      return this._outputLayers[this._outputLayers.length - 1].weights;
    }
  }, {
    key: '_prepTraining',
    value: function _prepTraining(data, options) {
      var stats = _get(Recurrent.prototype.__proto__ || Object.getPrototypeOf(Recurrent.prototype), '_prepTraining', this).call(this, data, options);

      this.initializeDeep();
      return stats;
    }
  }, {
    key: '_calculateDeltas',
    value: function _calculateDeltas(target, offset) {
      for (var x = target.length - 1; x >= 0; x--) {
        var hiddenLayersIndex = offset + x;
        var hiddenLayers = this._hiddenLayers[hiddenLayersIndex];
        var hiddenConnection = hiddenLayers[hiddenLayers.length - 1];

        this._outputConnection.setLayer(hiddenConnection);

        if (this._previousInputs.length > 0) {
          this._inputLayers[0].weights = this._previousInputs.pop();
        }

        this._outputLayers[this._outputLayers.length - 1].compare([target[x]]);

        for (var i = this._outputLayers.length - 2; i >= 0; i--) {
          this._outputLayers[i].compare();
        }

        for (var _i4 = hiddenLayers.length - 1; _i4 >= 0; _i4--) {
          hiddenLayers[_i4].compare();
        }

        for (var _i5 = this._inputLayers.length - 1; _i5 >= 1; _i5--) {
          this._inputLayers[_i5].compare();
        }
      }
    }
  }, {
    key: '_adjustWeights',
    value: function _adjustWeights() {
      for (var hiddenLayersIndex = 0; hiddenLayersIndex < this._hiddenLayers.length; hiddenLayersIndex++) {
        var hiddenLayers = this._hiddenLayers[hiddenLayersIndex];
        var hiddenConnection = hiddenLayers[hiddenLayers.length - 1];

        this._outputConnection.setLayer(hiddenConnection);

        for (var i = 0; i < this._inputLayers.length; i++) {
          this._inputLayers[i].learn();
        }

        for (var _i6 = 0; _i6 < hiddenLayers.length; _i6++) {
          hiddenLayers[_i6].learn();
        }

        for (var _i7 = 0; _i7 < this._outputLayers.length; _i7++) {
          this._outputLayers[_i7].learn();
        }

        for (var _i8 = 0; _i8 < this._model.length; _i8++) {
          this._model[_i8].learn();
        }
      }
    }
    /**
     *
     * @param {number[]} input
     * @param {number[]} target
     * @param {Boolean} [logErrorRate]
     */

  }, {
    key: '_trainPattern',
    value: function _trainPattern(input, target, logErrorRate) {
      // forward propagate
      this.runInput(input); // back propagate

      this._calculateDeltas(target, input.length - 1);

      this._calculateDeltas(input.slice(1), 0);

      this._adjustWeights();

      if (logErrorRate) {
        var outputLayer = this._outputLayers[this._outputLayers.length - 1];
        return (0, _mse2d2.default)(outputLayer.errors.hasOwnProperty('toArray') ? outputLayer.errors.toArray() : outputLayer.errors);
      }

      return null;
    }
  }], [{
    key: 'structure',
    get: function get() {
      return {
        /**
         *
         * _inputLayers are a 1 dimensional array of input layers defined once
         * @type Object[]
         * @private
         */
        _inputLayers: null,

        /**
         * _hiddenLayers are a 2 dimensional array of hidden layers defined for each recursion
         * @type Object[][]
         * @private
         */
        _hiddenLayers: null,

        /**
         * _outputLayers are a 1 dimensional array of output layers defined once
         * @type Object[]
         * @private
         */
        _outputLayers: null,
        _outputConnection: null,
        _previousInputs: null,
        _model: null,
        _recurrentIndices: null
      };
    }
  }]);

  return Recurrent;
}(_feedForward2.default);

exports.default = Recurrent;
},{"./layer/recurrent-connection":"sLgS","./layer/recurrent-input":"kvWK","./layer/recurrent-zeros":"7ZE4","./utilities/flatten-layers":"4Z71","./utilities/mse-2d":"3u/j","./feed-forward":"eqC7"}],"v84l":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _zeros = require('../../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/**
 * A matrix
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @constructor
 */


var Matrix = function () {
  function Matrix(rows, columns) {
    _classCallCheck(this, Matrix);

    if (rows === undefined) return;
    if (columns === undefined) return;
    this.rows = rows;
    this.columns = columns;
    this.weights = (0, _zeros2.default)(rows * columns);
    this.deltas = (0, _zeros2.default)(rows * columns);
  }
  /**
   *
   * @param {Number} row
   * @param {Number} col
   * @returns {Float32Array|Array}
   */


  _createClass(Matrix, [{
    key: 'getWeights',
    value: function getWeights(row, col) {
      // slow but careful accessor function
      // we want row-major order
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('get accessor is skewed');
      return this.weights[ix];
    }
    /**
     *
     * @param {Number} row
     * @param {Number} col
     * @param v
     * @returns {Matrix}
     */

  }, {
    key: 'setWeight',
    value: function setWeight(row, col, v) {
      // slow but careful accessor function
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');
      this.weights[ix] = v;
    }
    /**
     *
     * @param {Number} row
     * @param {Number} col
     * @param v
     * @returns {Matrix}
     */

  }, {
    key: 'setDeltas',
    value: function setDeltas(row, col, v) {
      // slow but careful accessor function
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');
      this.deltas[ix] = v;
    }
    /**
     *
     * @returns {{rows: *, columns: *, weights: Array}}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        rows: this.rows,
        columns: this.columns,
        weights: this.weights.slice(0)
      };
    }
  }, {
    key: 'weightsToArray',
    value: function weightsToArray() {
      var deltas = [];
      var row = 0;
      var column = 0;

      for (var i = 0; i < this.weights.length; i++) {
        if (column === 0) {
          deltas.push([]);
        }

        deltas[row].push(this.weights[i]);
        column++;

        if (column >= this.columns) {
          column = 0;
          row++;
        }
      }

      return deltas;
    }
  }, {
    key: 'deltasToArray',
    value: function deltasToArray() {
      var deltas = [];
      var row = 0;
      var column = 0;

      for (var i = 0; i < this.deltas.length; i++) {
        if (column === 0) {
          deltas.push([]);
        }

        deltas[row].push(this.deltas[i]);
        column++;

        if (column >= this.columns) {
          column = 0;
          row++;
        }
      }

      return deltas;
    }
  }], [{
    key: 'fromJSON',
    value: function fromJSON(json) {
      var matrix = new Matrix(json.rows, json.columns);

      for (var i = 0, max = json.rows * json.columns; i < max; i++) {
        matrix.weights[i] = json.weights[i]; // copy over weights
      }

      return matrix;
    }
    /**
     *
     * @param weightRows
     * @param [deltasRows]
     * @returns {Matrix}
     */

  }, {
    key: 'fromArray',
    value: function fromArray(weightRows, deltasRows) {
      var rows = weightRows.length;
      var columns = weightRows[0].length;
      var m = new Matrix(rows, columns);
      deltasRows = deltasRows || weightRows;

      for (var rowIndex = 0; rowIndex < rows; rowIndex++) {
        var weightValues = weightRows[rowIndex];
        var deltasValues = deltasRows[rowIndex];

        for (var columnIndex = 0; columnIndex < columns; columnIndex++) {
          m.setWeight(rowIndex, columnIndex, weightValues[columnIndex]);
          m.setDeltas(rowIndex, columnIndex, deltasValues[columnIndex]);
        }
      }

      return m;
    }
  }]);

  return Matrix;
}();

exports.default = Matrix;
},{"../../utilities/zeros":"M4LY"}],"Sd27":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomFloat = randomFloat;
exports.randomInteger = randomInteger;
exports.randomN = randomN;

function randomFloat(a, b) {
  return Math.random() * (b - a) + a;
} // Random numbers utils


function gaussRandom() {
  if (gaussRandom.returnV) {
    gaussRandom.returnV = false;
    return gaussRandom.vVal;
  }

  var u = 2 * Math.random() - 1;
  var v = 2 * Math.random() - 1;
  var r = u * u + v * v;

  if (r === 0 || r > 1) {
    return gaussRandom();
  }

  var c = Math.sqrt(-2 * Math.log(r) / r);
  gaussRandom.vVal = v * c; // cache this

  gaussRandom.returnV = true;
  return u * c;
}

function randomInteger(a, b) {
  return Math.floor(Math.random() * (b - a) + a);
}

function randomN(mu, std) {
  return mu + gaussRandom() * std;
}

gaussRandom.returnV = false;
gaussRandom.vVal = 0;
exports.default = {
  randomFloat: randomFloat,
  randomInteger: randomInteger,
  randomN: randomN
};
},{}],"zGuK":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('.');

var _2 = _interopRequireDefault(_);

var _random = require('../../utilities/random');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
/** return Matrix but filled with random numbers from gaussian
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @param std
 * @constructor
 */


var RandomMatrix = function (_Matrix) {
  _inherits(RandomMatrix, _Matrix);

  function RandomMatrix(rows, columns, std) {
    _classCallCheck(this, RandomMatrix);

    var _this = _possibleConstructorReturn(this, (RandomMatrix.__proto__ || Object.getPrototypeOf(RandomMatrix)).call(this, rows, columns));

    _this.rows = rows;
    _this.columns = columns;
    _this.std = std;

    for (var i = 0, max = _this.weights.length; i < max; i++) {
      _this.weights[i] = (0, _random.randomFloat)(-std, std);
    }

    return _this;
  }

  return RandomMatrix;
}(_2.default);

exports.default = RandomMatrix;
},{".":"v84l","../../utilities/random":"Sd27"}],"yuFB":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('.');

var _2 = _interopRequireDefault(_);

var _ones = require('../../utilities/ones');

var _ones2 = _interopRequireDefault(_ones);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
/** return Matrix but filled with random numbers from gaussian
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @constructor
 */


var OnesMatrix = function (_Matrix) {
  _inherits(OnesMatrix, _Matrix);

  function OnesMatrix(rows, columns) {
    _classCallCheck(this, OnesMatrix);

    var _this = _possibleConstructorReturn(this, (OnesMatrix.__proto__ || Object.getPrototypeOf(OnesMatrix)).call(this, rows, columns));

    _this.rows = rows;
    _this.columns = columns;
    _this.weights = (0, _ones2.default)(rows * columns);
    _this.deltas = (0, _ones2.default)(rows * columns);
    return _this;
  }

  return OnesMatrix;
}(_2.default);

exports.default = OnesMatrix;
},{".":"v84l","../../utilities/ones":"f7P8"}],"SjoR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = copy;
/*
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */

function copy(product, left) {
  product.rows = parseInt(left.rows, 10);
  product.columns = parseInt(left.columns, 10);
  product.weights = left.weights.slice(0);
  product.deltas = left.deltas.slice(0);
}
},{}],"gPcR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNegative;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */

function cloneNegative(product, left) {
  product.rows = parseInt(left.rows, 10);
  product.columns = parseInt(left.columns, 10);
  product.weights = left.weights.slice(0);
  product.deltas = left.deltas.slice(0);

  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = -left.weights[i];
    product.deltas[i] = 0;
  }
}
},{}],"2Be3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = add;
/**
 * add {left} and {right} matrix weights into {into}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function add(product, left, right) {
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = left.weights[i] + right.weights[i];
    product.deltas[i] = 0;
  }
}
},{}],"//pG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addB;
/**
 * adds {from} deltas to {left} and {right} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function addB(product, left, right) {
  for (var i = 0; i < product.deltas.length; i++) {
    left.deltas[i] = product.deltas[i];
    right.deltas[i] = product.deltas[i];
  }
}
},{}],"WPA9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = allOnes;
/**
 * makes matrix weights and deltas all ones
 * @param {Matrix} product
 */

function allOnes(product) {
  for (var i = 0; i < product.weights.length; i++) {
    product.weights[i] = 1;
    product.deltas[i] = 0;
  }
}
},{}],"7/in":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiply;
/**
 * multiply {left} and {right} matrix weights to {into}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function multiply(product, left, right) {
  var leftRows = left.rows;
  var leftColumns = left.columns;
  var rightColumns = right.columns; // loop over rows of left

  for (var leftRow = 0; leftRow < leftRows; leftRow++) {
    var leftRowBase = leftColumns * leftRow;
    var rightRowBase = rightColumns * leftRow; // loop over cols of right

    for (var rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
      // dot product loop
      var dot = 0; // loop over columns of left

      for (var leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
        var rightColumnBase = rightColumns * leftColumn;
        var leftIndex = leftRowBase + leftColumn;
        var rightIndex = rightColumnBase + rightColumn;
        dot += left.weights[leftIndex] * right.weights[rightIndex];
        left.deltas[leftIndex] = 0;
        right.deltas[rightIndex] = 0;
      }

      product.weights[rightRowBase + rightColumn] = dot;
    }
  }
}
},{}],"UbH8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyB;
/**
 * multiplies {from} deltas to {left} and {right}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function multiplyB(product, left, right) {
  var leftRows = left.rows;
  var leftColumns = left.columns;
  var rightColumns = right.columns; // loop over rows of left

  for (var leftRowRoot = 0; leftRowRoot < leftRows; leftRowRoot++) {
    var leftRowBase = leftColumns * leftRowRoot;
    var rightRowBase = rightColumns * leftRowRoot; // loop over cols of right

    for (var rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
      // loop over columns of left
      for (var leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
        var rightColumnBase = rightColumns * leftColumn;
        var leftRow = leftRowBase + leftColumn;
        var rightRow = rightColumnBase + rightColumn;
        var backPropagateValue = product.deltas[rightRowBase + rightColumn];
        left.deltas[leftRow] += right.weights[rightRow] * backPropagateValue;
        right.deltas[rightRow] += left.weights[leftRow] * backPropagateValue;
      }
    }
  }
}
},{}],"lIUj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyElement;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function multiplyElement(product, left, right) {
  var weights = left.weights;

  for (var i = 0; i < weights.length; i++) {
    product.weights[i] = left.weights[i] * right.weights[i];
    product.deltas[i] = 0;
  }
}
},{}],"zl5N":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyElementB;
/**
 * multiplies {left} and {right} weight by {from} deltas into {left} and {right} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */

function multiplyElementB(product, left, right) {
  for (var i = 0; i < left.weights.length; i++) {
    left.deltas[i] = right.weights[i] * product.deltas[i];
    right.deltas[i] = left.weights[i] * product.deltas[i];
  }
}
},{}],"i7sA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = relu;
/**
 *
 * relu {m} weights to {into} weights
 * @param {Matrix} product
 * @param {Matrix} left
 */

function relu(product, left) {
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = Math.max(0, left.weights[i]); // relu

    product.deltas[i] = 0;
  }
}
},{}],"2PfX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reluB;
/**
 * adds {from} deltas to {m} deltas when {m} weights are above other a threshold of 0
 * @param {Matrix} product
 * @param {Matrix} m
 */

function reluB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    left.deltas[i] = left.weights[i] > 0 ? product.deltas[i] : 0;
  }
}
},{}],"OR1n":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowPluck;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Number} rowPluckIndex
 */

function rowPluck(product, left, rowPluckIndex) {
  var columns = left.columns;
  var rowBase = columns * rowPluckIndex;

  for (var column = 0; column < columns; column++) {
    product.weights[column] = left.weights[rowBase + column];
    product.deltas[column] = 0;
  }
}
},{}],"+DWT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowPluckB;
/**
 * adds {from} deltas into {m} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Number} rowIndex
 */

function rowPluckB(product, left, rowIndex) {
  var columns = left.columns;
  var rowBase = columns * rowIndex;

  for (var column = 0; column < columns; column++) {
    left.deltas[rowBase + column] = product.deltas[column];
  }
}
},{}],"flLU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sigmoid;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 */

function sigmoid(product, left) {
  // sigmoid nonlinearity
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = 1 / (1 + Math.exp(-left.weights[i]));
    product.deltas[i] = 0;
  }
}

function sig(x) {
  // helper function for computing sigmoid
  return 1 / (1 + Math.exp(-x));
}
},{}],"QxYO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sigmoidB;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */

function sigmoidB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    var mwi = product.weights[i];
    left.deltas[i] = mwi * (1 - mwi) * product.deltas[i];
  }
}
},{}],"OmLq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tanh;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 */

function tanh(product, left) {
  // tanh nonlinearity
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = Math.tanh(left.weights[i]);
    product.deltas[i] = 0;
  }
}
},{}],"fARu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tanhB;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */

function tanhB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    // grad for z = tanh(x) is (1 - z^2)
    var mwi = product.weights[i];
    left.deltas[i] = (1 - mwi * mwi) * product.deltas[i];
  }
}
},{}],"ytIu":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _ = require('.');

var _2 = _interopRequireDefault(_);

var _onesMatrix = require('./ones-matrix');

var _onesMatrix2 = _interopRequireDefault(_onesMatrix);

var _copy = require('./copy');

var _copy2 = _interopRequireDefault(_copy);

var _cloneNegative2 = require('./clone-negative');

var _cloneNegative3 = _interopRequireDefault(_cloneNegative2);

var _add2 = require('./add');

var _add3 = _interopRequireDefault(_add2);

var _addB = require('./add-b');

var _addB2 = _interopRequireDefault(_addB);

var _allOnes2 = require('./all-ones');

var _allOnes3 = _interopRequireDefault(_allOnes2);

var _multiply2 = require('./multiply');

var _multiply3 = _interopRequireDefault(_multiply2);

var _multiplyB = require('./multiply-b');

var _multiplyB2 = _interopRequireDefault(_multiplyB);

var _multiplyElement2 = require('./multiply-element');

var _multiplyElement3 = _interopRequireDefault(_multiplyElement2);

var _multiplyElementB = require('./multiply-element-b');

var _multiplyElementB2 = _interopRequireDefault(_multiplyElementB);

var _relu2 = require('./relu');

var _relu3 = _interopRequireDefault(_relu2);

var _reluB = require('./relu-b');

var _reluB2 = _interopRequireDefault(_reluB);

var _rowPluck = require('./row-pluck');

var _rowPluck2 = _interopRequireDefault(_rowPluck);

var _rowPluckB = require('./row-pluck-b');

var _rowPluckB2 = _interopRequireDefault(_rowPluckB);

var _sigmoid2 = require('./sigmoid');

var _sigmoid3 = _interopRequireDefault(_sigmoid2);

var _sigmoidB = require('./sigmoid-b');

var _sigmoidB2 = _interopRequireDefault(_sigmoidB);

var _tanh2 = require('./tanh');

var _tanh3 = _interopRequireDefault(_tanh2);

var _tanhB = require('./tanh-b');

var _tanhB2 = _interopRequireDefault(_tanhB);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Equation = function () {
  function Equation() {
    _classCallCheck(this, Equation);

    this.inputRow = 0;
    this.inputValue = null;
    this.states = [];
  }
  /**
   * connects two matrices together by add
   * @param {Matrix} left
   * @param {Matrix} right
   * @returns {Matrix}
   */


  _createClass(Equation, [{
    key: 'add',
    value: function add(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }

      var product = new _2.default(left.rows, left.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _add3.default,
        backpropagationFn: _addB2.default
      });
      return product;
    }
    /**
     *
     * @param {Number} rows
     * @param {Number} columns
     * @returns {Matrix}
     */

  }, {
    key: 'allOnes',
    value: function allOnes(rows, columns) {
      var product = new _2.default(rows, columns);
      this.states.push({
        left: product,
        product: product,
        forwardFn: _allOnes3.default
      });
      return product;
    }
    /**
     *
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'cloneNegative',
    value: function cloneNegative(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _cloneNegative3.default
      });
      return product;
    }
    /**
     * connects two matrices together by subtract
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'subtract',
    value: function subtract(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }

      return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);
    }
    /**
     * connects two matrices together by multiply
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'multiply',
    value: function multiply(left, right) {
      if (left.columns !== right.rows) {
        throw new Error('misaligned matrices');
      }

      var product = new _2.default(left.rows, right.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _multiply3.default,
        backpropagationFn: _multiplyB2.default
      });
      return product;
    }
    /**
     * connects two matrices together by multiplyElement
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'multiplyElement',
    value: function multiplyElement(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }

      var product = new _2.default(left.rows, left.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _multiplyElement3.default,
        backpropagationFn: _multiplyElementB2.default
      });
      return product;
    }
    /**
     * connects a matrix to relu
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'relu',
    value: function relu(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _relu3.default,
        backpropagationFn: _reluB2.default
      });
      return product;
    }
    /**
     * copy a matrix
     * @param {Matrix} input
     * @returns {Matrix}
     */

  }, {
    key: 'input',
    value: function input(_input) {
      var self = this;
      this.states.push({
        product: _input,
        forwardFn: function forwardFn() {
          _input.weights = self.inputValue;
        }
      });
      return _input;
    }
    /**
     * connects a matrix via a row
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'inputMatrixToRow',
    value: function inputMatrixToRow(m) {
      var self = this;
      var product = new _2.default(m.columns, 1);
      this.states.push({
        left: m,

        get right() {
          return self.inputRow;
        },

        product: product,
        forwardFn: _rowPluck2.default,
        backpropagationFn: _rowPluckB2.default
      });
      return product;
    }
    /**
     * connects a matrix to sigmoid
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'sigmoid',
    value: function sigmoid(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _sigmoid3.default,
        backpropagationFn: _sigmoidB2.default
      });
      return product;
    }
    /**
     * connects a matrix to tanh
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'tanh',
    value: function tanh(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _tanh3.default,
        backpropagationFn: _tanhB2.default
      });
      return product;
    }
    /**
     *
     * @param m
     * @returns {Matrix}
     */

  }, {
    key: 'observe',
    value: function observe(m) {
      var iForward = 0;
      var iBackpropagate = 0;
      this.states.push({
        forwardFn: function forwardFn() {
          iForward++;
        },
        backpropagationFn: function backpropagationFn() {
          iBackpropagate++;
        }
      });
      return m;
    }
    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'run',
    value: function run() {
      var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.inputRow = rowIndex;
      var state = void 0;

      for (var i = 0, max = this.states.length; i < max; i++) {
        state = this.states[i];

        if (!state.hasOwnProperty('forwardFn')) {
          continue;
        }

        state.forwardFn(state.product, state.left, state.right);
      }

      return state.product;
    }
    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'runInput',
    value: function runInput(inputValue) {
      this.inputValue = inputValue;
      var state = void 0;

      for (var i = 0, max = this.states.length; i < max; i++) {
        state = this.states[i];

        if (!state.hasOwnProperty('forwardFn')) {
          continue;
        }

        state.forwardFn(state.product, state.left, state.right);
      }

      return state.product;
    }
    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'runBackpropagate',
    value: function runBackpropagate() {
      var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.inputRow = rowIndex;
      var i = this.states.length;
      var state = void 0;

      while (i-- > 0) {
        state = this.states[i];

        if (!state.hasOwnProperty('backpropagationFn')) {
          continue;
        }

        state.backpropagationFn(state.product, state.left, state.right);
      }

      return state.product;
    }
  }]);

  return Equation;
}();

exports.default = Equation;
},{".":"v84l","./ones-matrix":"yuFB","./copy":"SjoR","./clone-negative":"gPcR","./add":"2Be3","./add-b":"//pG","./all-ones":"WPA9","./multiply":"7/in","./multiply-b":"UbH8","./multiply-element":"lIUj","./multiply-element-b":"zl5N","./relu":"i7sA","./relu-b":"2PfX","./row-pluck":"OR1n","./row-pluck-b":"+DWT","./sigmoid":"flLU","./sigmoid-b":"QxYO","./tanh":"OmLq","./tanh-b":"fARu"}],"lOwB":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sampleI;

var _random = require('../../utilities/random'); // prevent parser from renaming when calling toString() method later


var randomF = _random.randomFloat;
/**
 *
 * @param {Matrix} m
 * @returns {number}
 */

function sampleI(m) {
  // sample argmax from w, assuming w are
  // probabilities that sum to one
  var r = randomF(0, 1);
  var x = 0;
  var i = 0;
  var w = m.weights;

  while (true) {
    x += w[i];

    if (x > r) {
      return i;
    }

    i++;
  }
}
},{"../../utilities/random":"Sd27"}],"2wnU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = maxI;
/**
 *
 * @param {Matrix} m
 * @returns {number}
 */

function maxI(m) {
  // argmax of array w
  var weights = m.weights;
  var maxv = weights[0];
  var maxix = 0;

  for (var i = 1; i < weights.length; i++) {
    var v = weights[i];
    if (v < maxv) continue;
    maxix = i;
    maxv = v;
  }

  return maxix;
}
},{}],"Ens1":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = softmax;

var _ = require('.');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 *
 * @param {Matrix} m
 * @returns {Matrix}
 */


function softmax(m) {
  var result = new _2.default(m.rows, m.columns); // probability volume

  var maxVal = -999999;

  for (var i = 0; i < m.weights.length; i++) {
    if (m.weights[i] > maxVal) {
      maxVal = m.weights[i];
    }
  }

  var s = 0;

  for (var _i = 0; _i < m.weights.length; _i++) {
    result.weights[_i] = Math.exp(m.weights[_i] - maxVal);
    s += result.weights[_i];
  }

  for (var _i2 = 0; _i2 < m.weights.length; _i2++) {
    result.weights[_i2] /= s;
  } // no backward pass here needed
  // since we will use the computed probabilities outside
  // to set gradients directly on m


  return result;
}
},{".":"v84l"}],"91u3":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/**
 *
 * @param {String[]|Number[]} values
 * @param maxThreshold
 * @constructor
 */


var DataFormatter = function () {
  function DataFormatter(values) {
    var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, DataFormatter);

    if (values === undefined) return;
    this.values = values; // go over all characters and keep track of all unique ones seen
    // count up all characters

    this.indexTable = {};
    this.characterTable = {};
    this.characters = [];
    this.buildCharactersFromIterable(values);
    this.buildTables(maxThreshold);
  }

  _createClass(DataFormatter, [{
    key: 'buildCharactersFromIterable',
    value: function buildCharactersFromIterable(values) {
      var tempCharactersTable = {};

      for (var dataFormatterIndex = 0, dataFormatterLength = values.length; dataFormatterIndex < dataFormatterLength; dataFormatterIndex++) {
        var characters = values[dataFormatterIndex];

        if (characters.hasOwnProperty('length')) {
          for (var characterIndex = 0, charactersLength = characters.length; characterIndex < charactersLength; characterIndex++) {
            var character = characters[characterIndex];
            if (tempCharactersTable.hasOwnProperty(character)) continue;
            tempCharactersTable[character] = true;
            this.characters.push(character);
          }
        } else {
          var _character = values[dataFormatterIndex];
          if (tempCharactersTable.hasOwnProperty(_character)) continue;
          tempCharactersTable[dataFormatterIndex] = true;
          this.characters.push(_character);
        }
      }
    }
  }, {
    key: 'buildTables',
    value: function buildTables(maxThreshold) {
      // filter by count threshold and create pointers
      var charactersLength = this.characters.length;

      for (var characterIndex = 0; characterIndex < charactersLength; characterIndex++) {
        var character = this.characters[characterIndex];

        if (characterIndex >= maxThreshold) {
          // add character to dataFormatter
          this.indexTable[character] = characterIndex;
          this.characterTable[characterIndex] = character;
        }
      }
    }
  }, {
    key: 'toIndexes',
    value: function toIndexes(value) {
      var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var result = [];
      var indexTable = this.indexTable;

      for (var i = 0, max = value.length; i < max; i++) {
        var character = value[i];
        var index = indexTable[character];

        if (index === undefined) {
          throw new Error('unrecognized character "' + character + '"');
        }

        if (index < maxThreshold) continue;
        result.push(index);
      }

      return result;
    }
  }, {
    key: 'toIndexesInputOutput',
    value: function toIndexesInputOutput(value1) {
      var value2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var maxThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var result = void 0;

      if (typeof value1 === 'string') {
        result = this.toIndexes(value1.split('').concat(['stop-input', 'start-output']), maxThreshold);
      } else {
        result = this.toIndexes(value1.concat(['stop-input', 'start-output']), maxThreshold);
      }

      if (value2 === null) return result;

      if (typeof value2 === 'string') {
        return result.concat(this.toIndexes(value2.split(''), maxThreshold));
      }

      return result.concat(this.toIndexes(value2, maxThreshold));
    }
  }, {
    key: 'toCharacters',
    value: function toCharacters(indices) {
      var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var result = [];
      var characterTable = this.characterTable;

      for (var i = 0, max = indices.length; i < max; i++) {
        var index = indices[i];
        if (index < maxThreshold) continue;
        var character = characterTable[index];

        if (character === undefined) {
          throw new Error('unrecognized index "' + index + '"');
        }

        result.push(character);
      }

      return result;
    }
  }, {
    key: 'toString',
    value: function toString(indices, maxThreshold) {
      return this.toCharacters(indices, maxThreshold).join('');
    }
  }, {
    key: 'addInputOutput',
    value: function addInputOutput() {
      this.addSpecial('stop-input');
      this.addSpecial('start-output');
    }
  }, {
    key: 'addSpecial',
    value: function addSpecial() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var i = 0; i < args.length; i++) {
        var special = args[i];
        this.indexTable[special] = this.characters.length;
        var specialIndex = this.indexTable[special];
        this.characterTable[specialIndex] = special;
        this.characters.push(special);
      }
    }
  }, {
    key: 'toFunctionString',
    value: function toFunctionString() {
      return '\nvar characterTable = ' + JSON.stringify(this.characterTable) + ';\nvar indexTable = ' + JSON.stringify(this.indexTable) + ';\nvar characters = ' + JSON.stringify(this.characters) + ';\n' + this.toIndexes.toString().replace(/(let|var) indexTable = this[.]indexTable;\n/, '').replace(/this[.]/g, '') + '\n' + this.toIndexesInputOutput.toString().replace(/this[.]/g, '') + '\n' + this.toCharacters.toString().replace(/(let|var) characterTable = this[.]characterTable;\n/g, '').replace(/this[.]/, '') + '\n';
    }
  }], [{
    key: 'fromAllPrintable',
    value: function fromAllPrintable(maxThreshold) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['\n'];

      for (var i = 32; i <= 126; i++) {
        values.push(String.fromCharCode(i));
      }

      return new DataFormatter(values, maxThreshold);
    }
  }, {
    key: 'fromAllPrintableInputOutput',
    value: function fromAllPrintableInputOutput(maxThreshold) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['\n'];
      var dataFormatter = DataFormatter.fromAllPrintable(maxThreshold, values);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromStringInputOutput',
    value: function fromStringInputOutput(string, maxThreshold) {
      var _String$prototype;

      var values = (_String$prototype = String.prototype).concat.apply(_String$prototype, _toConsumableArray(new Set(string)));

      var dataFormatter = new DataFormatter(values, maxThreshold);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromArrayInputOutput',
    value: function fromArrayInputOutput(array, maxThreshold) {
      var dataFormatter = new DataFormatter(array.filter(function (v, i, a) {
        return a.indexOf(v) === i;
      }).sort(), maxThreshold);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromString',
    value: function fromString(string, maxThreshold) {
      var _String$prototype2;

      var values = (_String$prototype2 = String.prototype).concat.apply(_String$prototype2, _toConsumableArray(new Set(string)));

      return new DataFormatter(values, maxThreshold);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var dataFormatter = new DataFormatter();
      dataFormatter.indexTable = json.indexTable;
      dataFormatter.characterTable = json.characterTable;
      dataFormatter.values = json.values;
      dataFormatter.characters = json.characters;
      return dataFormatter;
    }
  }]);

  return DataFormatter;
}();

exports.default = DataFormatter;
},{}],"gJGF":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _equation = require('./matrix/equation');

var _equation2 = _interopRequireDefault(_equation);

var _sampleI = require('./matrix/sample-i');

var _sampleI2 = _interopRequireDefault(_sampleI);

var _maxI = require('./matrix/max-i');

var _maxI2 = _interopRequireDefault(_maxI);

var _softmax = require('./matrix/softmax');

var _softmax2 = _interopRequireDefault(_softmax);

var _copy = require('./matrix/copy');

var _copy2 = _interopRequireDefault(_copy);

var _random = require('../utilities/random');

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _dataFormatter = require('../utilities/data-formatter');

var _dataFormatter2 = _interopRequireDefault(_dataFormatter);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var RNN = function () {
  function RNN() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RNN);

    var defaults = this.constructor.defaults;
    Object.assign(this, defaults, options);
    this.stepCache = {};
    this.runs = 0;
    this.totalCost = null;
    this.ratioClipped = null;
    this.model = null;
    this.initialLayerInputs = this.hiddenSizes.map(function () {
      return new _matrix2.default(_this.hiddenSizes[0], 1);
    });
    this.inputLookup = null;
    this.outputLookup = null;
    this.initialize();
  }

  _createClass(RNN, [{
    key: 'initialize',
    value: function initialize() {
      this.model = {
        input: null,
        hiddenLayers: [],
        output: null,
        equations: [],
        allMatrices: [],
        equationConnections: []
      };

      if (this.dataFormatter !== null) {
        this.outputSize = this.dataFormatter.characters.length;
        this.inputRange = this.outputSize;
        this.inputSize = this.inputRange;
      }

      if (this.json) {
        this.fromJSON(this.json);
      } else {
        this.mapModel();
      }
    }
  }, {
    key: 'createHiddenLayers',
    value: function createHiddenLayers() {
      var model = this.model,
          hiddenSizes = this.hiddenSizes;
      var hiddenLayers = model.hiddenLayers; // 0 is end, so add 1 to offset

      hiddenLayers.push(RNN.getModel(hiddenSizes[0], this.inputSize));
      var prevSize = hiddenSizes[0];

      for (var d = 1; d < hiddenSizes.length; d++) {
        // loop over depths
        var hiddenSize = hiddenSizes[d];
        hiddenLayers.push(RNN.getModel(hiddenSize, prevSize));
        prevSize = hiddenSize;
      }
    }
    /**
     *
     * @param {Number} hiddenSize
     * @param {Number} prevSize
     * @returns {object}
     */

  }, {
    key: 'createInputMatrix',
    value: function createInputMatrix() {
      // 0 is end, so add 1 to offset
      this.model.input = new _randomMatrix2.default(this.inputRange + 1, this.inputSize, 0.08);
    }
  }, {
    key: 'createOutputMatrix',
    value: function createOutputMatrix() {
      var _model = this.model,
          model = _model.model,
          outputSize = _model.outputSize;
      var lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1]; // 0 is end, so add 1 to offset
      // whd

      model.outputConnector = new _randomMatrix2.default(outputSize + 1, lastHiddenSize, 0.08); // 0 is end, so add 1 to offset
      // bd

      model.output = new _matrix2.default(outputSize + 1, 1);
    }
  }, {
    key: 'bindEquation',
    value: function bindEquation() {
      var _model2 = this.model,
          model = _model2.model,
          hiddenSizes = _model2.hiddenSizes;
      var hiddenLayers = model.hiddenLayers;
      var equation = new _equation2.default();
      var outputs = [];
      var equationConnection = model.equationConnections.length > 0 ? model.equationConnections[model.equationConnections.length - 1] : this.initialLayerInputs; // 0 index

      var output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], hiddenLayers[0]);
      outputs.push(output); // 1+ indices

      for (var i = 1, max = hiddenSizes.length; i < max; i++) {
        output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);
        outputs.push(output);
      }

      model.equationConnections.push(outputs);
      equation.add(equation.multiply(model.outputConnector, output), model.output);
      model.equations.push(equation);
    }
  }, {
    key: 'mapModel',
    value: function mapModel() {
      var model = this.model;
      var hiddenLayers = model.hiddenLayers,
          allMatrices = model.allMatrices;
      this.createInputMatrix();
      if (!model.input) throw new Error('net.model.input not set');
      allMatrices.push(model.input);
      this.createHiddenLayers();
      if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');

      for (var i = 0, max = hiddenLayers.length; i < max; i++) {
        Object.values(hiddenLayers[i]).forEach(function (val) {
          allMatrices.push(val);
        });
      }

      this.createOutputMatrix();
      if (!model.outputConnector) throw new Error('net.model.outputConnector not set');
      if (!model.output) throw new Error('net.model.output not set');
      allMatrices.push(model.outputConnector);
      allMatrices.push(model.output);
    }
    /**
     *
     * @param {Number[]} input
     * @param {Number} [learningRate]
     * @returns {number}
     */

  }, {
    key: 'trainPattern',
    value: function trainPattern(input) {
      var learningRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var error = this.runInput(input);
      this.runBackpropagate(input);
      this.step(learningRate);
      return error;
    }
    /**
     *
     * @param {Number[]} input
     * @returns {number}
     */

  }, {
    key: 'runInput',
    value: function runInput(input) {
      this.runs++;
      var model = this.model;
      var max = input.length;
      var log2ppl = 0;
      var cost = 0;
      var equation = void 0;

      while (model.equations.length <= input.length + 1) {
        // last is zero
        this.bindEquation();
      }

      for (var inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {
        // start and end tokens are zeros
        var equationIndex = inputIndex + 1;
        equation = model.equations[equationIndex];
        var source = inputIndex === -1 ? 0 : input[inputIndex] + 1; // first step: start with START token

        var target = inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1; // last step: end with END token

        var output = equation.run(source); // set gradients into log probabilities

        var logProbabilities = output; // interpret output as log probabilities

        var probabilities = (0, _softmax2.default)(output); // compute the softmax probabilities

        log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing

        cost += -Math.log(probabilities.weights[target]); // write gradients into log probabilities

        logProbabilities.deltas = probabilities.weights.slice(0);
        logProbabilities.deltas[target] -= 1;
      }

      this.totalCost = cost;
      return Math.pow(2, log2ppl / (max - 1));
    }
    /**
     * @param {Number[]} input
     */

  }, {
    key: 'runBackpropagate',
    value: function runBackpropagate(input) {
      var i = input.length;
      var model = this.model;
      var equations = model.equations;

      while (i > 0) {
        equations[i].runBackpropagate(input[i - 1] + 1);
        i--;
      }

      equations[0].runBackpropagate(0);
    }
    /**
     *
     * @param {Number} [learningRate]
     */

  }, {
    key: 'step',
    value: function step() {
      var learningRate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; // perform parameter update
      // TODO: still not sure if this is ready for learningRate

      var stepSize = learningRate || this.learningRate;
      var regc = this.regc,
          clipval = this.clipval,
          model = this.model;
      var numClipped = 0;
      var numTot = 0;
      var allMatrices = model.allMatrices;

      for (var matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {
        var matrix = allMatrices[matrixIndex];
        var weights = matrix.weights,
            deltas = matrix.deltas;

        if (!(matrixIndex in this.stepCache)) {
          this.stepCache[matrixIndex] = (0, _zeros2.default)(matrix.rows * matrix.columns);
        }

        var cache = this.stepCache[matrixIndex];

        for (var i = 0; i < weights.length; i++) {
          var r = deltas[i];
          var w = weights[i]; // rmsprop adaptive learning rate

          cache[i] = cache[i] * this.decayRate + (1 - this.decayRate) * r * r; // gradient clip

          if (r > clipval) {
            r = clipval;
            numClipped++;
          }

          if (r < -clipval) {
            r = -clipval;
            numClipped++;
          }

          numTot++; // update (and regularize)

          weights[i] = w + -stepSize * r / Math.sqrt(cache[i] + this.smoothEps) - regc * w;
        }
      }

      this.ratioClipped = numClipped / numTot;
    }
    /**
     *
     * @returns boolean
     */

  }, {
    key: 'run',

    /**
     *
     * @param {Number[]|*} [rawInput]
     * @param {Number} [maxPredictionLength]
     * @param {Boolean} [isSampleI]
     * @param {Number} temperature
     * @returns {*}
     */
    value: function run() {
      var rawInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var maxPredictionLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var isSampleI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var temperature = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (!this.isRunnable) return null;
      var input = this.formatDataIn(rawInput);
      var model = this.model;
      var output = [];
      var i = 0;

      while (model.equations.length < maxPredictionLength) {
        this.bindEquation();
      }

      while (true) {
        /* eslint-disable */
        var previousIndex = i === 0 ? 0 : i < input.length ? input[i - 1] + 1 : output[i - 1];
        /* eslint-enable */

        var equation = model.equations[i]; // sample predicted letter

        var outputMatrix = equation.run(previousIndex);
        var logProbabilities = new _matrix2.default(model.output.rows, model.output.columns);
        (0, _copy2.default)(logProbabilities, outputMatrix);

        if (temperature !== 1 && isSampleI) {
          /**
           * scale log probabilities by temperature and re-normalize
           * if temperature is high, logProbabilities will go towards zero
           * and the softmax outputs will be more diffuse. if temperature is
           * very low, the softmax outputs will be more peaky
           */
          for (var j = 0, max = logProbabilities.weights.length; j < max; j++) {
            logProbabilities.weights[j] /= temperature;
          }
        }

        var probs = (0, _softmax2.default)(logProbabilities);
        var nextIndex = isSampleI ? (0, _sampleI2.default)(probs) : (0, _maxI2.default)(probs);
        i++;

        if (nextIndex === 0) {
          // END token predicted, break out
          break;
        }

        if (i >= maxPredictionLength) {
          // something is wrong
          break;
        }

        output.push(nextIndex);
      }
      /**
       * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the
       * network what is contained in input, so the data is essentially guessed by the network what could be next, till it
       * locks in on a value.
       * Kind of like this, values are from input:
       * 0 -> 4 (or in English: "beginning on input" -> "I have no idea? I'll guess what they want next!")
       * 2 -> 2 (oh how interesting, I've narrowed down values...)
       * 1 -> 9 (oh how interesting, I've now know what the values are...)
       * then the output looks like: [4, 2, 9,...]
       * so we then remove the erroneous data to get our true output
       */


      return this.formatDataOut(input, output.slice(input.length).map(function (value) {
        return value - 1;
      }));
    }
    /**
     *
     * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings
     * @param {Object} [options]
     * @returns {{error: number, iterations: number}}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options = Object.assign({}, this.constructor.trainDefaults, options);
      var _options = options,
          iterations = _options.iterations,
          errorThresh = _options.errorThresh,
          logPeriod = _options.logPeriod,
          callback = _options.callback,
          callbackPeriod = _options.callbackPeriod;
      var log = options.log === true ? console.log : options.log;
      var learningRate = options.learningRate || this.learningRate;
      var error = Infinity;
      var i = void 0;

      if (this.hasOwnProperty('setupData')) {
        data = this.setupData(data);
      }

      if (!options.keepNetworkIntact) {
        this.initialize();
      }

      for (i = 0; i < iterations && error > errorThresh; i++) {
        var sum = 0;

        for (var j = 0; j < data.length; j++) {
          var err = this.trainPattern(data[j], learningRate);
          sum += err;
        }

        error = sum / data.length;
        if (Number.isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');

        if (log && i % logPeriod === 0) {
          log('iterations:', i, 'training error:', error);
        }

        if (callback && i % callbackPeriod === 0) {
          callback({
            error: error,
            iterations: i
          });
        }
      }

      return {
        error: error,
        iterations: i
      };
    }
    /**
     *
     * @param data
     * @returns {
     *  {
     *    error: number,
     *    misclasses: Array
     *  }
     * }
     */

  }, {
    key: 'test',
    value: function test() {
      throw new Error(this.constructor.name + '-test is not yet implemented');
    }
    /**
     *
     * @returns {Object}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var _this2 = this;

      var defaults = this.constructor.defaults;
      var model = this.model;
      var options = {};
      Object.keys(defaults).forEach(function (p) {
        options[p] = _this2[p];
      });
      return {
        type: this.constructor.name,
        options: options,
        input: model.input.toJSON(),
        hiddenLayers: model.hiddenLayers.map(function (hiddenLayer) {
          var layers = {};
          Object.keys(hiddenLayer).forEach(function (p) {
            layers[p] = hiddenLayer[p].toJSON();
          });
          return layers;
        }),
        outputConnector: this.model.outputConnector.toJSON(),
        output: this.model.output.toJSON()
      };
    }
  }, {
    key: 'toJSONString',
    value: function toJSONString() {
      return JSON.stringify(this.toJSON());
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var _this3 = this;

      this.json = json;
      var defaults = this.constructor.defaults;
      var model = this.model.model;
      var options = json.options;
      var allMatrices = model.allMatrices;
      model.input = _matrix2.default.fromJSON(json.input);
      allMatrices.push(model.input);
      model.hiddenLayers = json.hiddenLayers.map(function (hiddenLayer) {
        var layers = {};
        Object.keys(hiddenLayer).forEach(function (p) {
          layers[p] = _matrix2.default.fromJSON(hiddenLayer[p]);
          allMatrices.push(layers[p]);
        });
        return layers;
      });
      model.outputConnector = _matrix2.default.fromJSON(json.outputConnector);
      model.output = _matrix2.default.fromJSON(json.output);
      allMatrices.push(model.outputConnector);
      allMatrices.push(model.output);
      Object.keys(defaults).forEach(function (p) {
        _this3[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];
      });

      if (options.hasOwnProperty('dataFormatter') && options.dataFormatter !== null) {
        this.dataFormatter = _dataFormatter2.default.fromJSON(options.dataFormatter);
        delete options.dataFormatter;
      }

      this.bindEquation();
    }
  }, {
    key: 'fromJSONString',
    value: function fromJSONString(json) {
      return this.fromJSON(JSON.parse(json));
    }
    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      var model = this.model;
      var equations = this.model.equations;
      var equation = equations[1];
      var states = equation.states;
      var jsonString = JSON.stringify(this.toJSON());

      function previousConnectionIndex(m) {
        var connection = model.equationConnections[0];
        var states0 = equations[0].states0;

        for (var i = 0, max = states0.length; i < max; i++) {
          if (states0[i].product === m) {
            return i;
          }
        }

        return connection.indexOf(m);
      }

      function matrixOrigin(m, stateIndex) {
        for (var i = 0, max = states.length; i < max; i++) {
          var state = states[i];

          if (i === stateIndex) {
            var j = previousConnectionIndex(m);

            switch (m) {
              case state.left:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }

                break;

              case state.right:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }

                break;

              case state.product:
                return 'new Matrix(' + m.rows + ', ' + m.columns + ')';

              default:
                throw Error('unknown state');
            }
          }

          if (m === state.product) return 'states[' + i + '].product';
          if (m === state.right) return 'states[' + i + '].right';
          if (m === state.left) return 'states[' + i + '].left';
        }

        return null;
      }

      function matrixToString(m, stateIndex) {
        if (!m || !m.rows || !m.columns) return 'null';
        if (m === model.input) return 'json.input';
        if (m === model.outputConnector) return 'json.outputConnector';
        if (m === model.output) return 'json.output';

        var _loop = function _loop(i, max) {
          var hiddenLayer = model.hiddenLayers[i]; // eslint-disable-next-line

          Object.keys(hiddenLayer).forEach(function (p) {
            if (hiddenLayer[p] === m) {
              return 'json.hiddenLayers[' + i + '].' + p;
            }
          });
        };

        for (var i = 0, max = model.hiddenLayers.length; i < max; i++) {
          _loop(i, max);
        }

        return matrixOrigin(m, stateIndex);
      }

      function toInner(fnString) {
        // crude, but should be sufficient for now
        // function() { body }
        fnString = fnString.toString().split('{');
        fnString.shift(); // body }

        fnString = fnString.join('{');
        fnString = fnString.split('}');
        fnString.pop(); // body

        return fnString.join('}').split('\n').join('\n        ').replace('product.deltas[i] = 0;', '').replace('product.deltas[column] = 0;', '').replace('left.deltas[leftIndex] = 0;', '').replace('right.deltas[rightIndex] = 0;', '').replace('product.deltas = left.deltas.slice(0);', '');
      }

      function fileName(fnName) {
        return 'src/recurrent/matrix/' + fnName.replace(/[A-Z]/g, function (value) {
          return '-' + value.toLowerCase();
        }) + '.js';
      }

      var statesRaw = [];
      var usedFunctionNames = {};
      var innerFunctionsSwitch = [];

      for (var i = 0, max = states.length; i < max; i++) {
        var state = states[i];
        statesRaw.push('states[' + i + '] = {\n      name: \'' + state.forwardFn.name + '\',\n      left: ' + matrixToString(state.left, i) + ',\n      right: ' + matrixToString(state.right, i) + ',\n      product: ' + matrixToString(state.product, i) + '\n    }');
        var fnName = state.forwardFn.name;

        if (!usedFunctionNames[fnName]) {
          usedFunctionNames[fnName] = true;
          innerFunctionsSwitch.push('        case \'' + fnName + '\': //compiled from ' + fileName(fnName) + '\n          ' + toInner(state.forwardFn.toString()) + '\n          break;');
        }
      }

      var src = '\n  if (typeof rawInput === \'undefined\') rawInput = [];\n  if (typeof maxPredictionLength === \'undefined\') maxPredictionLength = 100;\n  if (typeof isSampleI === \'undefined\') isSampleI = false;\n  if (typeof temperature === \'undefined\') temperature = 1;\n  ' + (this.dataFormatter !== null ? this.dataFormatter.toFunctionString() : '') + '\n\n  var input = ' + (this.dataFormatter !== null && typeof this.formatDataIn === 'function' ? 'formatDataIn(rawInput)' : 'rawInput') + ';\n  var json = ' + jsonString + ';\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    prevStates = states;\n    states = [];\n    ' + statesRaw.join(';\n    ') + ';\n    for (var stateIndex = 0, stateMax = ' + statesRaw.length + '; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n\n      switch (state.name) {\n' + innerFunctionsSwitch.join('\n') + '\n      }\n    }\n\n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n\n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ' + (this.dataFormatter !== null && typeof this.formatDataOut === 'function' ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))' : 'return output.slice(input.length).map(function(value) { return value - 1; })') + ';\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ' + (this.dataFormatter !== null && typeof this.formatDataIn === 'function' ? 'function formatDataIn(input, output) { ' + toInner(this.formatDataIn.toString()).replace(/this[.]dataFormatter[\n\s]+[.]/g, '').replace(/this[.]dataFormatter[.]/g, '').replace(/this[.]dataFormatter/g, 'true') + ' }' : '') + '\n  ' + (this.dataFormatter !== null && typeof this.formatDataOut === 'function' ? 'function formatDataOut(input, output) { ' + toInner(this.formatDataOut.toString()).replace(/this[.]dataFormatter[\n\s]+[.]/g, '').replace(/this[.]dataFormatter[.]/g, '').replace(/this[.]dataFormatter/g, 'true') + ' }' : '') + '\n  ' + _zeros2.default.toString() + '\n  ' + _softmax2.default.toString().replace('_2.default', 'Matrix') + '\n  ' + _random.randomFloat.toString() + '\n  ' + _sampleI2.default.toString() + '\n  ' + _maxI2.default.toString(); // eslint-disable-next-line


      return new Function('rawInput', 'maxPredictionLength', 'isSampleI', 'temperature', src);
    }
  }, {
    key: 'isRunnable',
    get: function get() {
      if (this.model.equations.length === 0) {
        console.error('No equations bound, did you run train()?');
        return false;
      }

      return true;
    }
  }], [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        // wxh
        weight: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // whh
        transition: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bhh
        bias: new _matrix2.default(hiddenSize, 1)
      };
    }
    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var relu = equation.relu.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);
      return relu(add(add(multiply(hiddenLayer.weight, inputMatrix), multiply(hiddenLayer.transition, previousResult)), hiddenLayer.bias));
    }
  }]);

  return RNN;
}();

exports.default = RNN;
RNN.defaults = {
  inputSize: 20,
  inputRange: 20,
  hiddenSizes: [20, 20],
  outputSize: 20,
  learningRate: 0.01,
  decayRate: 0.999,
  smoothEps: 1e-8,
  regc: 0.000001,
  clipval: 5,
  json: null,

  /**
   *
   * @param {*[]} data
   * @returns {Number[]}
   */
  setupData: function setupData(data) {
    if (typeof data[0] !== 'string' && !Array.isArray(data[0]) && (!data[0].hasOwnProperty('input') || !data[0].hasOwnProperty('output'))) {
      return data;
    }

    var values = [];
    var result = [];

    if (typeof data[0] === 'string' || Array.isArray(data[0])) {
      if (this.dataFormatter === null) {
        for (var i = 0; i < data.length; i++) {
          values.push(data[i]);
        }

        this.dataFormatter = new _dataFormatter2.default(values);
      }

      for (var _i = 0, max = data.length; _i < max; _i++) {
        result.push(this.formatDataIn(data[_i]));
      }
    } else {
      if (this.dataFormatter === null) {
        for (var _i2 = 0; _i2 < data.length; _i2++) {
          values.push(data[_i2].input);
          values.push(data[_i2].output);
        }

        this.dataFormatter = _dataFormatter2.default.fromArrayInputOutput(values);
      }

      for (var _i3 = 0, _max = data.length; _i3 < _max; _i3++) {
        result.push(this.formatDataIn(data[_i3].input, data[_i3].output));
      }
    }

    return result;
  },

  /**
   *
   * @param {*[]} input
   * @param {*[]} output
   * @returns {Number[]}
   */
  formatDataIn: function formatDataIn(input) {
    var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (this.dataFormatter !== null) {
      if (this.dataFormatter.indexTable.hasOwnProperty('stop-input')) {
        return this.dataFormatter.toIndexesInputOutput(input, output);
      }

      return this.dataFormatter.toIndexes(input);
    }

    return input;
  },

  /**
   *
   * @param {Number[]} input
   * @param {Number[]} output
   * @returns {*}
   */
  formatDataOut: function formatDataOut(input, output) {
    if (this.dataFormatter !== null) {
      return this.dataFormatter.toCharacters(output).join('');
    }

    return output;
  },
  dataFormatter: null
};
RNN.trainDefaults = {
  iterations: 20000,
  errorThresh: 0.005,
  log: false,
  logPeriod: 10,
  learningRate: 0.3,
  callback: null,
  callbackPeriod: 10,
  keepNetworkIntact: false
};
},{"./matrix":"v84l","./matrix/random-matrix":"zGuK","./matrix/equation":"ytIu","./matrix/sample-i":"lOwB","./matrix/max-i":"2wnU","./matrix/softmax":"Ens1","./matrix/copy":"SjoR","../utilities/random":"Sd27","../utilities/zeros":"M4LY","../utilities/data-formatter":"91u3"}],"zri4":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _equation = require('./matrix/equation');

var _equation2 = _interopRequireDefault(_equation);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var RNNTimeStep = function (_RNN) {
  _inherits(RNNTimeStep, _RNN); // eslint-disable-next-line


  function RNNTimeStep(options) {
    _classCallCheck(this, RNNTimeStep);

    return _possibleConstructorReturn(this, (RNNTimeStep.__proto__ || Object.getPrototypeOf(RNNTimeStep)).call(this, options));
  }

  _createClass(RNNTimeStep, [{
    key: 'createInputMatrix',
    value: function createInputMatrix() {
      this.model.input = new _randomMatrix2.default(this.inputSize, 1, 0.08);
    }
  }, {
    key: 'createOutputMatrix',
    value: function createOutputMatrix() {
      var model = this.model,
          outputSize = this.outputSize;
      var lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1]; // whd

      model.outputConnector = new _randomMatrix2.default(outputSize, lastHiddenSize, 0.08); // bd

      model.output = new _matrix2.default(outputSize, 1);
    }
  }, {
    key: 'bindEquation',
    value: function bindEquation() {
      var model = this.model,
          hiddenSizes = this.hiddenSizes;
      var hiddenLayers = model.hiddenLayers;
      var equation = new _equation2.default();
      var outputs = [];
      var equationConnection = model.equationConnections.length > 0 ? model.equationConnections[model.equationConnections.length - 1] : this.initialLayerInputs; // 0 index

      var output = RNNTimeStep.getEquation(equation, equation.input(model.input), equationConnection[0], hiddenLayers[0]);
      outputs.push(output); // 1+ indices

      for (var i = 1, max = hiddenSizes.length; i < max; i++) {
        output = RNNTimeStep.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);
        outputs.push(output);
      }

      model.equationConnections.push(outputs);
      equation.add(equation.multiply(model.outputConnector, output), model.output);
      model.equations.push(equation);
    }
    /**
     *
     * @param {Number[]} input
     * @returns {number}
     */

  }, {
    key: 'runInput',
    value: function runInput(input) {
      this.runs++;
      var model = this.model;
      var errorSum = 0;
      var equation = void 0;

      while (model.equations.length < input.length - 1) {
        this.bindEquation();
      }

      var outputs = [];

      if (this.inputSize === 1) {
        for (var inputIndex = 0, max = input.length - 1; inputIndex < max; inputIndex++) {
          // start and end tokens are zeros
          equation = model.equations[inputIndex];
          var current = input[inputIndex];
          var next = input[inputIndex + 1];
          var output = equation.runInput([current]);

          for (var i = 0; i < output.weights.length; i++) {
            var error = output.weights[i] - next; // set gradients into log probabilities

            errorSum += Math.abs(error); // write gradients into log probabilities

            output.deltas[i] = error;
            outputs.push(output.weights);
          }
        }
      } else {
        for (var _inputIndex = 0, _max = input.length - 1; _inputIndex < _max; _inputIndex++) {
          // start and end tokens are zeros
          equation = model.equations[_inputIndex];
          var _current = input[_inputIndex];
          var _next = input[_inputIndex + 1];

          var _output = equation.runInput(_current);

          for (var _i = 0; _i < _output.weights.length; _i++) {
            var _error = _output.weights[_i] - _next[_i]; // set gradients into log probabilities


            errorSum += Math.abs(_error); // write gradients into log probabilities

            _output.deltas[_i] = _error;
            outputs.push(_output.weights);
          }
        }
      } // this.model.equations.length - 1;


      this.totalCost = errorSum;
      return errorSum;
    }
  }, {
    key: 'runBackpropagate',
    value: function runBackpropagate() {
      for (var i = this.model.equations.length - 1; i > -1; i--) {
        this.model.equations[i].runBackpropagate();
      }
    }
    /**
     *
     * @param {Number[]|Number} [input]
     * @param {Number} [maxPredictionLength]
     * @param {Boolean} [isSampleI]
     * @param {Number} temperature
     * @returns {Number[]|Number}
     */

  }, {
    key: 'run',
    value: function run()
    /* , isSampleI = false, temperature = 1 */
    {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var maxPredictionLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (!this.isRunnable) return null;
      var model = this.model;

      while (model.equations.length < maxPredictionLength) {
        this.bindEquation();
      }

      var lastOutput = void 0;

      if (this.inputSize === 1) {
        for (var i = 0; i < input.length; i++) {
          var outputMatrix = model.equations[i].runInput([input[i]]);
          lastOutput = outputMatrix.weights;
        }
      } else {
        for (var _i2 = 0; _i2 < input.length; _i2++) {
          var _outputMatrix = model.equations[_i2].runInput(input[_i2]);

          lastOutput = _outputMatrix.weights;
        }
      }

      if (this.outputSize === 1) {
        return lastOutput[0];
      }

      return lastOutput;
    }
    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      throw new Error(this.constructor.name + '-toFunction is not yet implemented');
    }
  }]);

  return RNNTimeStep;
}(_rnn2.default);

exports.default = RNNTimeStep;
RNNTimeStep.defaults = {
  inputSize: 1,
  hiddenSizes: [20],
  outputSize: 1,
  learningRate: 0.01,
  decayRate: 0.999,
  smoothEps: 1e-8,
  regc: 0.000001,
  clipval: 5,
  json: null,
  dataFormatter: null
};
RNNTimeStep.trainDefaults = _rnn2.default.trainDefaults;
},{"./matrix":"v84l","./matrix/random-matrix":"zGuK","./matrix/equation":"ytIu","./rnn":"gJGF"}],"e2+i":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var LSTM = function (_RNN) {
  _inherits(LSTM, _RNN);

  function LSTM() {
    _classCallCheck(this, LSTM);

    return _possibleConstructorReturn(this, (LSTM.__proto__ || Object.getPrototypeOf(LSTM)).apply(this, arguments));
  }

  _createClass(LSTM, null, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        // gates parameters
        // wix
        inputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wih
        inputHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bi
        inputBias: new _matrix2.default(hiddenSize, 1),
        // wfx
        forgetMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wfh
        forgetHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bf
        forgetBias: new _matrix2.default(hiddenSize, 1),
        // wox
        outputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // woh
        outputHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bo
        outputBias: new _matrix2.default(hiddenSize, 1),
        // cell write params
        // wcx
        cellActivationMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wch
        cellActivationHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bc
        cellActivationBias: new _matrix2.default(hiddenSize, 1)
      };
    }
    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var sigmoid = equation.sigmoid.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);
      var multiplyElement = equation.multiplyElement.bind(equation);
      var tanh = equation.tanh.bind(equation);
      var inputGate = sigmoid(add(add(multiply(hiddenLayer.inputMatrix, inputMatrix), multiply(hiddenLayer.inputHidden, previousResult)), hiddenLayer.inputBias));
      var forgetGate = sigmoid(add(add(multiply(hiddenLayer.forgetMatrix, inputMatrix), multiply(hiddenLayer.forgetHidden, previousResult)), hiddenLayer.forgetBias)); // output gate

      var outputGate = sigmoid(add(add(multiply(hiddenLayer.outputMatrix, inputMatrix), multiply(hiddenLayer.outputHidden, previousResult)), hiddenLayer.outputBias)); // write operation on cells

      var cellWrite = tanh(add(add(multiply(hiddenLayer.cellActivationMatrix, inputMatrix), multiply(hiddenLayer.cellActivationHidden, previousResult)), hiddenLayer.cellActivationBias)); // compute new cell activation

      var retainCell = multiplyElement(forgetGate, previousResult); // what do we keep from cell

      var writeCell = multiplyElement(inputGate, cellWrite); // what do we write to cell

      var cell = add(retainCell, writeCell); // new cell contents
      // compute hidden state as gated, saturated cell activations

      return multiplyElement(outputGate, tanh(cell));
    }
  }]);

  return LSTM;
}(_rnn2.default);

exports.default = LSTM;
},{"./matrix":"v84l","./matrix/random-matrix":"zGuK","./rnn":"gJGF"}],"hEPI":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _lstm = require('./lstm');

var _lstm2 = _interopRequireDefault(_lstm);

var _rnnTimeStep = require('./rnn-time-step');

var _rnnTimeStep2 = _interopRequireDefault(_rnnTimeStep);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var LSTMTimeStep = function (_RNNTimeStep) {
  _inherits(LSTMTimeStep, _RNNTimeStep);

  function LSTMTimeStep() {
    _classCallCheck(this, LSTMTimeStep);

    return _possibleConstructorReturn(this, (LSTMTimeStep.__proto__ || Object.getPrototypeOf(LSTMTimeStep)).apply(this, arguments));
  }

  _createClass(LSTMTimeStep, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return _lstm2.default.prototype.getModel.call(this, hiddenSize, prevSize);
    }
    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      return _lstm2.default.prototype.getEquation.call(this, equation, inputMatrix, previousResult, hiddenLayer);
    }
  }]);

  return LSTMTimeStep;
}(_rnnTimeStep2.default);

exports.default = LSTMTimeStep;
},{"./matrix":"v84l","./lstm":"e2+i","./rnn-time-step":"zri4"}],"wLPK":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var GRU = function (_RNN) {
  _inherits(GRU, _RNN);

  function GRU() {
    _classCallCheck(this, GRU);

    return _possibleConstructorReturn(this, (GRU.__proto__ || Object.getPrototypeOf(GRU)).apply(this, arguments));
  }

  _createClass(GRU, null, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        // update Gate
        // wzxh
        updateGateInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wzhh
        updateGateHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bz
        updateGateBias: new _matrix2.default(hiddenSize, 1),
        // reset Gate
        // wrxh
        resetGateInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wrhh
        resetGateHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // br
        resetGateBias: new _matrix2.default(hiddenSize, 1),
        // cell write parameters
        // wcxh
        cellWriteInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        // wchh
        cellWriteHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        // bc
        cellWriteBias: new _matrix2.default(hiddenSize, 1)
      };
    }
    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var sigmoid = equation.sigmoid.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);
      var multiplyElement = equation.multiplyElement.bind(equation);
      var tanh = equation.tanh.bind(equation);
      var allOnes = equation.allOnes.bind(equation);
      var cloneNegative = equation.cloneNegative.bind(equation); // update gate

      var updateGate = sigmoid(add(add(multiply(hiddenLayer.updateGateInputMatrix, inputMatrix), multiply(hiddenLayer.updateGateHiddenMatrix, previousResult)), hiddenLayer.updateGateBias)); // reset gate

      var resetGate = sigmoid(add(add(multiply(hiddenLayer.resetGateInputMatrix, inputMatrix), multiply(hiddenLayer.resetGateHiddenMatrix, previousResult)), hiddenLayer.resetGateBias)); // cell

      var cell = tanh(add(add(multiply(hiddenLayer.cellWriteInputMatrix, inputMatrix), multiply(hiddenLayer.cellWriteHiddenMatrix, multiplyElement(resetGate, previousResult))), hiddenLayer.cellWriteBias)); // compute hidden state as gated, saturated cell activations
      // negate updateGate

      return add(multiplyElement(add(allOnes(updateGate.rows, updateGate.columns), cloneNegative(updateGate)), cell), multiplyElement(previousResult, updateGate));
    }
  }]);

  return GRU;
}(_rnn2.default);

exports.default = GRU;
},{"./matrix":"v84l","./matrix/random-matrix":"zGuK","./rnn":"gJGF"}],"+7gC":[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj); };

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _gru = require('./gru');

var _gru2 = _interopRequireDefault(_gru);

var _rnnTimeStep = require('./rnn-time-step');

var _rnnTimeStep2 = _interopRequireDefault(_rnnTimeStep);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // import Matrix from './matrix'


var GRUTimeStep = function (_RNNTimeStep) {
  _inherits(GRUTimeStep, _RNNTimeStep);

  function GRUTimeStep() {
    _classCallCheck(this, GRUTimeStep);

    return _possibleConstructorReturn(this, (GRUTimeStep.__proto__ || Object.getPrototypeOf(GRUTimeStep)).apply(this, arguments));
  }

  _createClass(GRUTimeStep, null, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return _gru2.default.prototype.getModel(hiddenSize, prevSize);
    }
    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      return _gru2.default.prototype.getEquation(equation, inputMatrix, previousResult, hiddenLayer);
    }
  }]);

  return GRUTimeStep;
}(_rnnTimeStep2.default);

exports.default = GRUTimeStep;
},{"./gru":"wLPK","./rnn-time-step":"zri4"}],"nL/1":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = feedForward;

var _index = require('./index');

function feedForward(settings, input) {
  var height = settings.height;
  var weights = (0, _index.random)({
    name: 'weights',
    height: height,
    width: input.height
  });
  var biases = (0, _index.random)({
    name: 'biases',
    height: height
  });
  return (0, _index.sigmoid)((0, _index.add)((0, _index.multiply)(weights, input), biases));
}
},{"./index":"X3lc"}],"v+cs":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('.');

exports.default = function (settings, recurrentInput, input) {
  var height = settings.height;
  var updateGateWeights = (0, _.random)({
    height: height,
    width: input.height
  });
  var updateGatePeepholes = (0, _.random)({
    width: height,
    height: height
  });
  var updateGateBias = (0, _.zeros)({
    height: height
  });
  var updateGate = (0, _.sigmoid)((0, _.add)((0, _.add)((0, _.multiply)(updateGateWeights, input), (0, _.multiply)(updateGatePeepholes, recurrentInput)), updateGateBias));
  var resetGateWeights = (0, _.random)({
    height: height,
    width: input.height
  });
  var resetGatePeepholes = (0, _.random)({
    width: height,
    height: height
  });
  var resetGateBias = (0, _.zeros)({
    height: height
  });
  var resetGate = (0, _.sigmoid)((0, _.add)((0, _.add)((0, _.multiply)(resetGateWeights, input), (0, _.multiply)(resetGatePeepholes, recurrentInput)), resetGateBias));
  var cellWeights = (0, _.random)({
    height: height,
    width: input.height
  });
  var cellPeepholes = (0, _.random)({
    width: height,
    height: height
  });
  var cellBias = (0, _.zeros)({
    height: height
  });
  var cell = (0, _.tanh)((0, _.add)((0, _.add)((0, _.multiply)(cellWeights, input), (0, _.multiply)(cellPeepholes, (0, _.multiplyElement)(resetGate, recurrentInput))), cellBias)); // compute hidden state as gated, saturated cell activations
  // negate updateGate

  return (0, _.add)((0, _.multiplyElement)((0, _.add)((0, _.ones)(updateGate.rows, updateGate.columns), (0, _.negative)(updateGate)), cell), (0, _.multiplyElement)(recurrentInput, updateGate));
};
},{".":"X3lc"}],"Mqbi":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

exports.default = function (settings, recurrentInput, input) {
  var height = settings.height;
  var inputGateWeights = (0, _index.random)({
    height: height,
    width: input.height
  });
  var inputGatePeepholes = (0, _index.random)({
    width: height,
    height: height
  });
  var inputGateBias = (0, _index.zeros)({
    height: height
  });
  var inputGate = (0, _index.sigmoid)((0, _index.add)((0, _index.add)((0, _index.multiply)(inputGateWeights, input), (0, _index.multiply)(inputGatePeepholes, recurrentInput)), inputGateBias));
  var forgetGateWeights = (0, _index.random)({
    height: height,
    width: input.height
  });
  var forgetGatePeepholes = (0, _index.random)({
    width: height,
    height: height
  });
  var forgetGateBias = (0, _index.zeros)({
    height: height
  });
  var forgetGate = (0, _index.sigmoid)((0, _index.add)((0, _index.add)((0, _index.multiply)(forgetGateWeights, input), (0, _index.multiply)(forgetGatePeepholes, recurrentInput)), forgetGateBias));
  var outputGateWeights = (0, _index.random)({
    height: height,
    width: input.height
  });
  var outputGatePeepholes = (0, _index.random)({
    width: height,
    height: height
  });
  var outputGateBias = (0, _index.zeros)({
    height: height
  });
  var outputGate = (0, _index.sigmoid)((0, _index.add)((0, _index.add)((0, _index.multiply)(outputGateWeights, input), (0, _index.multiply)(outputGatePeepholes, recurrentInput)), outputGateBias));
  var memoryWeights = (0, _index.random)({
    height: height,
    width: input.height
  });
  var memoryPeepholes = (0, _index.random)({
    width: height,
    height: height
  });
  var memoryBias = (0, _index.zeros)({
    height: height
  });
  var memory = (0, _index.tanh)((0, _index.add)((0, _index.add)((0, _index.multiply)(memoryWeights, input), (0, _index.multiply)(memoryPeepholes, recurrentInput)), memoryBias)); // compute new cell activation

  var retainCell = (0, _index.multiplyElement)(forgetGate, input); // what do we keep from cell

  var writeCell = (0, _index.multiplyElement)(inputGate, memory); // what do we write to cell

  var cell = (0, _index.add)(retainCell, writeCell); // new cell contents
  // compute hidden state as gated, saturated cell activations

  return (0, _index.multiplyElement)(outputGate, (0, _index.tanh)(cell));
};
},{"./index":"X3lc"}],"7ERy":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('.');

exports.default = function (settings, input, recurrentInput) {
  var height = settings.height;
  recurrentInput.setDimensions(1, height); // wxh

  var weight = (0, _.random)({
    name: 'weight',
    height: height,
    width: input.height
  }); // whh

  var transition = (0, _.random)({
    name: 'transition',
    height: height,
    width: height
  }); // bhh

  var bias = (0, _.zeros)({
    name: 'bias',
    height: height
  });
  return (0, _.relu)((0, _.add)((0, _.add)((0, _.multiply)(weight, input), (0, _.multiply)(transition, recurrentInput)), bias));
};
},{".":"X3lc"}],"YS3q":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('.');

exports.default = function (settings, inputLayer) {
  var height = settings.height;
  var outputGate = (0, _.random)({
    height: height,
    width: inputLayer.height
  });
  var output = (0, _.zeros)({
    height: height
  });
  var outputGateConnector = (0, _.multiply)(outputGate, inputLayer);
  return (0, _.target)(settings, (0, _.add)(outputGateConnector, output));
};
},{".":"X3lc"}],"Focm":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _activation = require('./activation');

var _activation2 = _interopRequireDefault(_activation);

var _crossValidate = require('./cross-validate');

var _crossValidate2 = _interopRequireDefault(_crossValidate);

var _layer = require('./layer');

var layer = _interopRequireWildcard(_layer);

var _likely = require('./likely');

var _likely2 = _interopRequireDefault(_likely);

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

var _praxis = require('./praxis');

var _praxis2 = _interopRequireDefault(_praxis);

var _feedForward = require('./feed-forward');

var _feedForward2 = _interopRequireDefault(_feedForward);

var _neuralNetwork = require('./neural-network');

var _neuralNetwork2 = _interopRequireDefault(_neuralNetwork);

var _neuralNetworkGpu = require('./neural-network-gpu');

var _neuralNetworkGpu2 = _interopRequireDefault(_neuralNetworkGpu);

var _trainStream = require('./train-stream');

var _trainStream2 = _interopRequireDefault(_trainStream);

var _recurrent = require('./recurrent');

var _recurrent2 = _interopRequireDefault(_recurrent);

var _rnnTimeStep = require('./recurrent/rnn-time-step');

var _rnnTimeStep2 = _interopRequireDefault(_rnnTimeStep);

var _lstmTimeStep = require('./recurrent/lstm-time-step');

var _lstmTimeStep2 = _interopRequireDefault(_lstmTimeStep);

var _gruTimeStep = require('./recurrent/gru-time-step');

var _gruTimeStep2 = _interopRequireDefault(_gruTimeStep);

var _rnn = require('./recurrent/rnn');

var _rnn2 = _interopRequireDefault(_rnn);

var _lstm = require('./recurrent/lstm');

var _lstm2 = _interopRequireDefault(_lstm);

var _gru = require('./recurrent/gru');

var _gru2 = _interopRequireDefault(_gru);

var _max = require('./utilities/max');

var _max2 = _interopRequireDefault(_max);

var _mse = require('./utilities/mse');

var _mse2 = _interopRequireDefault(_mse);

var _ones = require('./utilities/ones');

var _ones2 = _interopRequireDefault(_ones);

var _random = require('./utilities/random');

var _random2 = _interopRequireDefault(_random);

var _randomWeight = require('./utilities/random-weight');

var _randomWeight2 = _interopRequireDefault(_randomWeight);

var _randos = require('./utilities/randos');

var _randos2 = _interopRequireDefault(_randos);

var _range = require('./utilities/range');

var _range2 = _interopRequireDefault(_range);

var _toArray = require('./utilities/to-array');

var _toArray2 = _interopRequireDefault(_toArray);

var _dataFormatter = require('./utilities/data-formatter');

var _dataFormatter2 = _interopRequireDefault(_dataFormatter);

var _zeros = require('./utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _feedForward3 = require('./layer/feed-forward');

var _feedForward4 = _interopRequireDefault(_feedForward3);

var _gru3 = require('./layer/gru');

var _gru4 = _interopRequireDefault(_gru3);

var _lstm3 = require('./layer/lstm');

var _lstm4 = _interopRequireDefault(_lstm3);

var _recurrent3 = require('./layer/recurrent');

var _recurrent4 = _interopRequireDefault(_recurrent3);

var _output = require('./layer/output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

layer.feedForward = _feedForward4.default; // layer deps

layer.gru = _gru4.default;
layer.lstm = _lstm4.default;
layer.recurrent = _recurrent4.default;
layer.output = _output2.default;
var brain = {
  activation: _activation2.default,
  crossValidate: _crossValidate2.default,
  likely: _likely2.default,
  layer: layer,
  lookup: _lookup2.default,
  praxis: _praxis2.default,
  FeedForward: _feedForward2.default,
  NeuralNetwork: _neuralNetwork2.default,
  NeuralNetworkGPU: _neuralNetworkGpu2.default,
  Recurrent: _recurrent2.default,
  TrainStream: _trainStream2.default,
  recurrent: {
    RNNTimeStep: _rnnTimeStep2.default,
    LSTMTimeStep: _lstmTimeStep2.default,
    GRUTimeStep: _gruTimeStep2.default,
    RNN: _rnn2.default,
    LSTM: _lstm2.default,
    GRU: _gru2.default
  },
  utilities: {
    max: _max2.default,
    mse: _mse2.default,
    ones: _ones2.default,
    random: _random2.default,
    randomWeight: _randomWeight2.default,
    randos: _randos2.default,
    range: _range2.default,
    toArray: _toArray2.default,
    DataFormatter: _dataFormatter2.default,
    zeros: _zeros2.default
  }
};

if (typeof window !== 'undefined') {
  window.brain = brain; //eslint-disable-line
}

exports.default = brain;
},{"./activation":"l4U/","./cross-validate":"+wYj","./layer":"X3lc","./likely":"dfGl","./lookup":"Q1a6","./praxis":"4P9L","./feed-forward":"eqC7","./neural-network":"8epZ","./neural-network-gpu":"6trg","./train-stream":"vEEq","./recurrent":"JVtt","./recurrent/rnn-time-step":"zri4","./recurrent/lstm-time-step":"hEPI","./recurrent/gru-time-step":"+7gC","./recurrent/rnn":"gJGF","./recurrent/lstm":"e2+i","./recurrent/gru":"wLPK","./utilities/max":"UFcl","./utilities/mse":"YGn7","./utilities/ones":"f7P8","./utilities/random":"Sd27","./utilities/random-weight":"TX07","./utilities/randos":"S8tM","./utilities/range":"YhH7","./utilities/to-array":"HBY8","./utilities/data-formatter":"91u3","./utilities/zeros":"M4LY","./layer/feed-forward":"nL/1","./layer/gru":"v+cs","./layer/lstm":"Mqbi","./layer/recurrent":"7ERy","./layer/output":"YS3q"}]},{},["Focm"], null)
//# sourceMappingURL=/brain-browser.js.map