{"version":3,"sources":["../src/cross-validate.js"],"names":["CrossValidate","Classifier","options","json","trainOpts","trainSet","testSet","classifier","beginTrain","Date","now","trainingStats","train","beginTest","testStats","test","endTest","stats","Object","assign","trainTime","testTime","iterations","trainError","error","learningRate","hiddenLayers","network","toJSON","array","i","length","j","Math","floor","random","temp","data","k","Error","size","constructor","Array","shuffleArray","newData","keys","forEach","key","avgs","truePos","trueNeg","falsePos","falseNeg","total","results","stat","sum","dclone","slice","splice","result","testPartition","push","precision","recall","accuracy","testSize","trainSize","sets","fromJSON","crossValidateJson","reduce","prev","cur","Infinity","instance"],"mappings":"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","file":"cross-validate.js","sourcesContent":["export default class CrossValidate {\r\n\r\n  /**\r\n   *\r\n   * @param {NeuralNetwork|constructor} Classifier\r\n   * @param {object} [options]\r\n   */\r\n  constructor(Classifier, options) {\r\n    this.Classifier = Classifier;\r\n    this.options = options;\r\n    this.json = null;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {object} trainOpts\r\n   * @param {object} trainSet\r\n   * @param {object} testSet\r\n   * @returns {void|*}\r\n   */\r\n  testPartition(trainOpts, trainSet, testSet) {\r\n    let classifier = new this.Classifier(this.options);\r\n    let beginTrain = Date.now();\r\n    let trainingStats = classifier.train(trainSet, trainOpts);\r\n    let beginTest = Date.now();\r\n    let testStats = classifier.test(testSet);\r\n    let endTest = Date.now();\r\n    let stats = Object.assign({}, testStats, {\r\n      trainTime: beginTest - beginTrain,\r\n      testTime: endTest - beginTest,\r\n      iterations: trainingStats.iterations,\r\n      trainError: trainingStats.error,\r\n      learningRate: trainOpts.learningRate,\r\n      hiddenLayers: classifier.hiddenLayers,\r\n      network: classifier.toJSON()\r\n    });\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Randomize array element order in-place.\r\n   * Using Durstenfeld shuffle algorithm.\r\n   * source: http://stackoverflow.com/a/12646864/1324039\r\n   */\r\n  shuffleArray(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      let j = Math.floor(Math.random() * (i + 1));\r\n      let temp = array[i];\r\n      array[i] = array[j];\r\n      array[j] = temp;\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {object} data\r\n   * @param {object} trainOpts\r\n   * @param {number} [k]\r\n   * @returns {\r\n   *  {\r\n   *    avgs: {\r\n   *      error: number,\r\n   *      trainTime: number,\r\n   *      testTime: number,\r\n   *      iterations: number,\r\n   *      trainError: number\r\n   *    },\r\n   *    stats: {\r\n   *      truePos: number,\r\n   *      trueNeg: number,\r\n   *      falsePos: number,\r\n   *      falseNeg: number,\r\n   *      total: number\r\n   *    },\r\n   *    sets: Array\r\n   *  }\r\n   * }\r\n   */\r\n  train(data, trainOpts = {}, k = 4) {\r\n    if (data.length <= k) {\r\n      throw new Error(`Training set size is too small for ${ data.length } k folds of ${ k }`);\r\n    }\r\n    let size = data.length / k;\r\n\r\n    if (data.constructor === Array) {\r\n      this.shuffleArray(data);\r\n    } else {\r\n      let newData = {};\r\n      this.shuffleArray(Object.keys(data)).forEach((key) => {\r\n        newData[key] = data[key];\r\n      });\r\n      data = newData;\r\n    }\r\n\r\n    let avgs = {\r\n      error: 0,\r\n      trainTime: 0,\r\n      testTime: 0,\r\n      iterations: 0,\r\n      trainError: 0\r\n    };\r\n\r\n    let stats = {\r\n      truePos: 0,\r\n      trueNeg: 0,\r\n      falsePos: 0,\r\n      falseNeg: 0,\r\n      total: 0\r\n    };\r\n\r\n    let results = [];\r\n    let stat;\r\n    let sum;\r\n\r\n    for (let i = 0; i < k; i++) {\r\n      let dclone = data.slice(0);\r\n      let testSet = dclone.splice(i * size, size);\r\n      let trainSet = dclone;\r\n      let result = this.testPartition(trainOpts, trainSet, testSet);\r\n      for (stat in avgs) {\r\n        if (stat in avgs) {\r\n          sum = avgs[stat];\r\n          avgs[stat] = sum + result[stat];\r\n        }\r\n      }\r\n\r\n      for (stat in stats) {\r\n        if (stat in stats) {\r\n          sum = stats[stat];\r\n          stats[stat] = sum + result[stat];\r\n        }\r\n      }\r\n\r\n      results.push(result);\r\n    }\r\n\r\n    for (stat in avgs) {\r\n      if (stat in avgs) {\r\n        sum = avgs[stat];\r\n        avgs[stat] = sum / k;\r\n      }\r\n    }\r\n\r\n    stats.precision = stats.truePos / (stats.truePos + stats.falsePos);\r\n    stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);\r\n    stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;\r\n\r\n    stats.testSize = size;\r\n    stats.trainSize = data.length - size;\r\n\r\n\r\n    this.json = {\r\n      avgs: avgs,\r\n      stats: stats,\r\n      sets: results\r\n    };\r\n  }\r\n\r\n  toNeuralNetwork() {\r\n    return this.fromJSON(this.json);\r\n  }\r\n\r\n  toJSON() {\r\n    return this.json;\r\n  }\r\n\r\n  fromJSON(crossValidateJson) {\r\n    const Classifier = this.Classifier;\r\n    const json = crossValidateJson.sets.reduce((prev, cur) => prev.error < cur.error ? prev : cur, {error: Infinity}).network;\r\n    if (Classifier.fromJSON) {\r\n      return Classifier.fromJSON(json);\r\n    }\r\n    const instance = new Classifier();\r\n    instance.fromJSON(json);\r\n    return instance;\r\n  }\r\n}\r\n"]}