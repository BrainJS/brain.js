{"version":3,"sources":["../src/cross-validate.js"],"names":["testPartition","shuffleArray","crossValidate","Classifier","opts","trainOpts","trainSet","testSet","classifier","beginTrain","Date","now","trainingStats","train","beginTest","testStats","test","endTest","stats","Object","assign","trainTime","testTime","iterations","trainError","error","learningRate","hidden","hiddenSizes","network","toJSON","array","i","length","j","Math","floor","random","temp","data","k","size","constructor","Array","newData","keys","forEach","key","avgs","truePos","trueNeg","falsePos","falseNeg","total","misclasses","results","stat","sum","dclone","slice","splice","result","concat","push","precision","recall","accuracy","testSize","trainSize","sets"],"mappings":";;;;;QASgBA,a,GAAAA,a;QAyBAC,Y,GAAAA,Y;kBAsCQC,a;AAxExB;;;;;;;;;AASO,SAASF,aAAT,CAAuBG,UAAvB,EAAmCC,IAAnC,EAAyCC,SAAzC,EAAoDC,QAApD,EAA8DC,OAA9D,EAAuE;AAC5E,MAAIC,aAAa,IAAIL,UAAJ,CAAeC,IAAf,CAAjB;AACA,MAAIK,aAAaC,KAAKC,GAAL,EAAjB;AACA,MAAIC,gBAAgBJ,WAAWK,KAAX,CAAiBP,QAAjB,EAA2BD,SAA3B,CAApB;AACA,MAAIS,YAAYJ,KAAKC,GAAL,EAAhB;AACA,MAAII,YAAYP,WAAWQ,IAAX,CAAgBT,OAAhB,CAAhB;AACA,MAAIU,UAAUP,KAAKC,GAAL,EAAd;AACA,MAAIO,QAAQC,OAAOC,MAAP,CAAc,EAAd,EAAkBL,SAAlB,EAA6B;AACvCM,eAAYP,YAAYL,UADe;AAEvCa,cAAWL,UAAUH,SAFkB;AAGvCS,gBAAYX,cAAcW,UAHa;AAIvCC,gBAAYZ,cAAca,KAJa;AAKvCC,kBAAcrB,UAAUqB,YALe;AAMvCC,YAAQnB,WAAWoB,WANoB;AAOvCC,aAASrB,WAAWsB,MAAX;AAP8B,GAA7B,CAAZ;;AAUA,SAAOZ,KAAP;AACD;;AAED;;;;;AAKO,SAASjB,YAAT,CAAsB8B,KAAtB,EAA6B;AAClC,OAAK,IAAIC,IAAID,MAAME,MAAN,GAAe,CAA5B,EAA+BD,IAAI,CAAnC,EAAsCA,GAAtC,EAA2C;AACzC,QAAIE,IAAIC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,MAAiBL,IAAI,CAArB,CAAX,CAAR;AACA,QAAIM,OAAOP,MAAMC,CAAN,CAAX;AACAD,UAAMC,CAAN,IAAWD,MAAMG,CAAN,CAAX;AACAH,UAAMG,CAAN,IAAWI,IAAX;AACD;AACD,SAAOP,KAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4Be,SAAS7B,aAAT,CAAuBC,UAAvB,EAAmCoC,IAAnC,EAAyCnC,IAAzC,EAA+CC,SAA/C,EAA0DmC,CAA1D,EAA6D;AAC1EA,MAAIA,KAAK,CAAT;AACA,MAAIC,OAAOF,KAAKN,MAAL,GAAcO,CAAzB;;AAEA,MAAID,KAAKG,WAAL,KAAqBC,KAAzB,EAAgC;AAC9B1C,iBAAasC,IAAb;AACD,GAFD,MAEO;AACL,QAAIK,UAAU,EAAd;AACA3C,iBAAakB,OAAO0B,IAAP,CAAYN,IAAZ,CAAb,EAAgCO,OAAhC,CAAwC,UAACC,GAAD,EAAS;AAC/CH,cAAQG,GAAR,IAAeR,KAAKQ,GAAL,CAAf;AACD,KAFD;AAGAR,WAAOK,OAAP;AACD;;AAED,MAAII,OAAO;AACTvB,WAAQ,CADC;AAETJ,eAAY,CAFH;AAGTC,cAAW,CAHF;AAITC,gBAAY,CAJH;AAKTC,gBAAY;AALH,GAAX;;AAQA,MAAIN,QAAQ;AACV+B,aAAS,CADC;AAEVC,aAAS,CAFC;AAGVC,cAAU,CAHA;AAIVC,cAAU,CAJA;AAKVC,WAAO;AALG,GAAZ;;AAQA,MAAIC,aAAa,EAAjB;AACA,MAAIC,UAAU,EAAd;AACA,MAAIC,aAAJ;AACA,MAAIC,YAAJ;;AAEA,OAAK,IAAIzB,IAAI,CAAb,EAAgBA,IAAIQ,CAApB,EAAuBR,GAAvB,EAA4B;AAC1B,QAAI0B,SAASnB,KAAKoB,KAAL,CAAW,CAAX,CAAb;AACA,QAAIpD,UAAUmD,OAAOE,MAAP,CAAc5B,IAAIS,IAAlB,EAAwBA,IAAxB,CAAd;AACA,QAAInC,WAAWoD,MAAf;AACA,QAAIG,SAAS7D,cAAcG,UAAd,EAA0BC,IAA1B,EAAgCC,SAAhC,EAA2CC,QAA3C,EAAqDC,OAArD,CAAb;AACA,SAAKiD,IAAL,IAAaR,IAAb,EAAmB;AACjB,UAAIQ,QAAQR,IAAZ,EAAkB;AAChBS,cAAMT,KAAKQ,IAAL,CAAN;AACAR,aAAKQ,IAAL,IAAaC,MAAMI,OAAOL,IAAP,CAAnB;AACD;AACF;;AAED,SAAKA,IAAL,IAAatC,KAAb,EAAoB;AAClB,UAAIsC,QAAQtC,KAAZ,EAAmB;AACjBuC,cAAMvC,MAAMsC,IAAN,CAAN;AACAtC,cAAMsC,IAAN,IAAcC,MAAMI,OAAOL,IAAP,CAApB;AACD;AACF;;AAEDF,eAAWQ,MAAX,CAAkBP,QAAQD,UAA1B;;AAEAC,YAAQQ,IAAR,CAAaF,MAAb;AACD;;AAED,OAAKL,IAAL,IAAaR,IAAb,EAAmB;AACjB,QAAIQ,QAAQR,IAAZ,EAAkB;AAChBS,YAAMT,KAAKQ,IAAL,CAAN;AACAR,WAAKQ,IAAL,IAAaC,MAAMjB,CAAnB;AACD;AACF;;AAEDtB,QAAM8C,SAAN,GAAkB9C,MAAM+B,OAAN,IAAiB/B,MAAM+B,OAAN,GAAgB/B,MAAMiC,QAAvC,CAAlB;AACAjC,QAAM+C,MAAN,GAAe/C,MAAM+B,OAAN,IAAiB/B,MAAM+B,OAAN,GAAgB/B,MAAMkC,QAAvC,CAAf;AACAlC,QAAMgD,QAAN,GAAiB,CAAChD,MAAMgC,OAAN,GAAgBhC,MAAM+B,OAAvB,IAAkC/B,MAAMmC,KAAzD;;AAEAnC,QAAMiD,QAAN,GAAiB1B,IAAjB;AACAvB,QAAMkD,SAAN,GAAkB7B,KAAKN,MAAL,GAAcQ,IAAhC;;AAEA,SAAO;AACLO,UAAMA,IADD;AAEL9B,WAAOA,KAFF;AAGLmD,UAAMd,OAHD;AAILD,gBAAYA;AAJP,GAAP;AAMD","file":"cross-validate.js","sourcesContent":["/**\r\n *\r\n * @param {NeuralNetwork|constructor} Classifier\r\n * @param {object} opts\r\n * @param {object} trainOpts\r\n * @param {object} trainSet\r\n * @param {object} testSet\r\n * @returns {void|*}\r\n */\r\nexport function testPartition(Classifier, opts, trainOpts, trainSet, testSet) {\r\n  let classifier = new Classifier(opts);\r\n  let beginTrain = Date.now();\r\n  let trainingStats = classifier.train(trainSet, trainOpts);\r\n  let beginTest = Date.now();\r\n  let testStats = classifier.test(testSet);\r\n  let endTest = Date.now();\r\n  let stats = Object.assign({}, testStats, {\r\n    trainTime : beginTest - beginTrain,\r\n    testTime : endTest - beginTest,\r\n    iterations: trainingStats.iterations,\r\n    trainError: trainingStats.error,\r\n    learningRate: trainOpts.learningRate,\r\n    hidden: classifier.hiddenSizes,\r\n    network: classifier.toJSON()\r\n  });\r\n\r\n  return stats;\r\n}\r\n\r\n/**\r\n * Randomize array element order in-place.\r\n * Using Durstenfeld shuffle algorithm.\r\n * source: http://stackoverflow.com/a/12646864/1324039\r\n */\r\nexport function shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    let j = Math.floor(Math.random() * (i + 1));\r\n    let temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n *\r\n * @param {NeuralNetwork|constructor} Classifier\r\n * @param {object} data\r\n * @param {object} opts\r\n * @param {object} trainOpts\r\n * @param {number} k\r\n * @returns {\r\n *  {\r\n *    avgs: {\r\n *      error: number,\r\n *      trainTime: number,\r\n *      testTime: number,\r\n *      iterations: number,\r\n *      trainError: number\r\n *    },\r\n *    stats: {\r\n *      truePos: number,\r\n *      trueNeg: number,\r\n *      falsePos: number,\r\n *      falseNeg: number,\r\n *      total: number\r\n *    },\r\n *    sets: Array,\r\n *    misclasses: Array\r\n *  }\r\n * }\r\n */\r\nexport default function crossValidate(Classifier, data, opts, trainOpts, k) {\r\n  k = k || 4;\r\n  let size = data.length / k;\r\n\r\n  if (data.constructor === Array) {\r\n    shuffleArray(data);\r\n  } else {\r\n    let newData = {};\r\n    shuffleArray(Object.keys(data)).forEach((key) => {\r\n      newData[key] = data[key];\r\n    });\r\n    data = newData;\r\n  }\r\n\r\n  let avgs = {\r\n    error : 0,\r\n    trainTime : 0,\r\n    testTime : 0,\r\n    iterations: 0,\r\n    trainError: 0\r\n  };\r\n\r\n  let stats = {\r\n    truePos: 0,\r\n    trueNeg: 0,\r\n    falsePos: 0,\r\n    falseNeg: 0,\r\n    total: 0\r\n  };\r\n\r\n  let misclasses = [];\r\n  let results = [];\r\n  let stat;\r\n  let sum;\r\n\r\n  for (let i = 0; i < k; i++) {\r\n    let dclone = data.slice(0);\r\n    let testSet = dclone.splice(i * size, size);\r\n    let trainSet = dclone;\r\n    let result = testPartition(Classifier, opts, trainOpts, trainSet, testSet);\r\n    for (stat in avgs) {\r\n      if (stat in avgs) {\r\n        sum = avgs[stat];\r\n        avgs[stat] = sum + result[stat];\r\n      }\r\n    }\r\n\r\n    for (stat in stats) {\r\n      if (stat in stats) {\r\n        sum = stats[stat];\r\n        stats[stat] = sum + result[stat];\r\n      }\r\n    }\r\n\r\n    misclasses.concat(results.misclasses);\r\n\r\n    results.push(result);\r\n  }\r\n\r\n  for (stat in avgs) {\r\n    if (stat in avgs) {\r\n      sum = avgs[stat];\r\n      avgs[stat] = sum / k;\r\n    }\r\n  }\r\n\r\n  stats.precision = stats.truePos / (stats.truePos + stats.falsePos);\r\n  stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);\r\n  stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;\r\n\r\n  stats.testSize = size;\r\n  stats.trainSize = data.length - size;\r\n\r\n  return {\r\n    avgs: avgs,\r\n    stats: stats,\r\n    sets: results,\r\n    misclasses: misclasses\r\n  };\r\n}\r\n"]}