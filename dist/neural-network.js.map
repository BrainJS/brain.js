{"version":3,"sources":["../src/neural-network.js"],"names":["availableActivations","activationFn","sum","Math","exp","deltaFn","output","error","max","tanh","NeuralNetwork","options","validations","iterations","val","errorThresh","log","logPeriod","learningRate","momentum","callback","callbackPeriod","timeout","Object","keys","trainDefaults","forEach","hasOwnProperty","key","Error","Infinity","binaryThresh","hiddenLayers","activation","assign","constructor","defaults","hiddenSizes","trainOpts","_updateTrainingOptions","sizes","outputLayer","biases","weights","outputs","deltas","changes","errors","errorCheckInterval","prototype","runInput","calculateDeltas","length","layer","size","Array","node","prevSize","setActivation","activationList","includes","join","_createRunInput","_createCalculateDeltas","input","isRunnable","inputLookup","lookup","toArray","outputLookup","toHash","_runInput","k","data","push","floor","_initialize","opts","opt","_validateTrainingOptions","_setLogMethod","reduce","console","i","_trainPattern","status","endTime","Date","now","_calculateTrainingError","_trainPatterns","_formatData","_verifyIsInitialized","_prepTraining","_trainingTick","Promise","resolve","reject","thawedTrain","Thaw","delay","each","stop","done","tick","trainError","target","logErrorRate","_adjustWeights","_calcuateDeltas","incoming","delta","change","isArray","tmp","datum","Float32Array","buildLookup","map","value","array","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","indexOf","misclass","stats","total","precision","recall","accuracy","layers","nodes","j","bias","index","_getTrainOptsJSON","json","lookupFromHash","nodeHandle","layerNumber","nodeKey","result","w","toString","toJSON","layersAsMath","Function","neuralNetwork","trainStream","TrainStream","checkFns","filter","c"],"mappings":"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","file":"neural-network.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport randos from './utilities/randos';\nimport range from './utilities/range';\nimport toArray from './utilities/to-array';\nimport zeros from './utilities/zeros';\nimport Thaw from 'thaw.js';\n\nconst availableActivations = {\n  'sigmoid': {\n    activationFn: (sum) => 1 / (1 + Math.exp(-sum)),\n    deltaFn: (output, error) => error * output * (1 - output)\n  },\n  'relu': {\n    activationFn: (sum) => Math.max(0, sum),\n    deltaFn: (output, error) => output > 0 ? error : 0\n  },\n  'leaky-relu': {\n    activationFn: (sum) => sum < 0 ? 0 : 0.01 * sum,\n    deltaFn: (output, error) => output > 0 ? error : 0.01 * error\n  },\n  'tanh': {\n    activationFn: (sum) => Math.tanh(sum),\n    deltaFn: (output, error) => (1 - output * output) * error\n  }\n};\n\n/**\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetwork {\n  static get trainDefaults() {\n    return {\n      iterations: 20000,    // the maximum times to iterate the training data\n      errorThresh: 0.005,   // the acceptable error percentage from training data\n      log: false,           // true to use console.log, when a function is supplied it is used\n      logPeriod: 10,        // iterations between logging out\n      learningRate: 0.3,    // multiply's against the input and the delta then adds to momentum\n      momentum: 0.1,        // multiply's against the specified \"change\" then adds to learning rate for change\n      callback: null,       // a periodic call back that can be triggered while training\n      callbackPeriod: 10,   // the number of iterations through the training data between callback calls\n      timeout: Infinity     // the max number of milliseconds to train for\n    };\n  }\n\n  static get defaults() {\n    return {\n      binaryThresh: 0.5,     // ¯\\_(ツ)_/¯\n      hiddenLayers: [3],     // array of ints for the sizes of the hidden layers in the network\n      activation: 'sigmoid'  // Supported activation types ['sigmoid', 'relu', 'leaky-relu', 'tanh']\n    };\n  }\n\n  /**\n   *\n   * @param options\n   * @private\n   */\n  static _validateTrainingOptions(options) {\n    const validations = {\n      iterations: val => typeof val === 'number' && val > 0,\n      errorThresh: val => typeof val === 'number' && val > 0 && val < 1,\n      log: val => typeof val === 'function' || typeof val === 'boolean',\n      logPeriod: val => typeof val === 'number' && val > 0,\n      learningRate: val => typeof val === 'number' && val > 0 && val < 1,\n      momentum: val => typeof val === 'number' && val > 0 && val < 1,\n      callback: val => typeof val === 'function' || val === null,\n      callbackPeriod: val => typeof val === 'number' && val > 0,\n      timeout: val => typeof val === 'number' && val > 0\n    };\n    Object.keys(NeuralNetwork.trainDefaults).forEach(key => {\n      if (validations.hasOwnProperty(key) && !validations[key](options[key])) {\n        throw new Error(`[${key}, ${options[key]}] is out of normal training range, your network will probably not train.`);\n      }\n    });\n  }\n\n  constructor(options = {}) {\n    Object.assign(this, this.constructor.defaults, options);\n    this.hiddenSizes = options.hiddenLayers;\n    this.trainOpts = {};\n    this._updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));\n\n    this.sizes = null;\n    this.outputLayer = null;\n    this.biases = null; // weights for bias nodes\n    this.weights = null;\n    this.outputs = null;\n\n    // state for training\n    this.deltas = null;\n    this.changes = null; // for momentum\n    this.errors = null;\n    this.errorCheckInterval = 1;\n    if (!this.constructor.prototype.hasOwnProperty('runInput')) {\n      this.runInput = null;\n    }\n    if (!this.constructor.prototype.hasOwnProperty('calculateDeltas')) {\n      this.calculateDeltas = null;\n    }\n  }\n\n  /**\n   *\n   * Expects this.sizes to have been set\n   */\n  _initialize() {\n    if (!this.sizes) throw new Error ('Sizes must be set before initializing');\n\n    this.outputLayer = this.sizes.length - 1;\n    this.biases = []; // weights for bias nodes\n    this.weights = [];\n    this.outputs = [];\n\n    // state for training\n    this.deltas = [];\n    this.changes = []; // for momentum\n    this.errors = [];\n\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      let size = this.sizes[layer];\n      this.deltas[layer] = zeros(size);\n      this.errors[layer] = zeros(size);\n      this.outputs[layer] = zeros(size);\n\n      if (layer > 0) {\n        this.biases[layer] = randos(size);\n        this.weights[layer] = new Array(size);\n        this.changes[layer] = new Array(size);\n\n        for (let node = 0; node < size; node++) {\n          let prevSize = this.sizes[layer - 1];\n          this.weights[layer][node] = randos(prevSize);\n          this.changes[layer][node] = zeros(prevSize);\n        }\n      }\n    }\n\n    this.setActivation();\n  }\n\n  /**\n   *\n   * @param activation supported inputs: 'sigmoid', 'relu', 'leaky-relu', 'tanh'\n   */\n  setActivation(activation) {\n    const activationList = Object.keys(availableActivations);\n    this.activation = activation || this.activation;\n\n    if (!activationList.includes(this.activation)) {\n      throw new Error(`Unknown activation ${this.activation}, The activation should be one of ['${activationList.join('\\', \\'')}']`);\n    }\n\n    const { activationFn, deltaFn } = availableActivations[this.activation];\n\n    this.runInput = this.runInput || this._createRunInput(activationFn);\n    this.calculateDeltas = this.calculateDeltas || this._createCalculateDeltas(deltaFn);\n  }\n  \n  /**\n   *\n   * @returns boolean\n   */\n  get isRunnable(){\n    if(!this.runInput){\n      console.error('Activation function has not been initialized, did you run train()?');\n      return false;\n    }\n\n    const checkFns = [\n      'sizes',\n      'outputLayer',\n      'biases',\n      'weights',\n      'outputs',\n      'deltas',\n      'changes',\n      'errors',\n    ].filter(c => this[c] === null);\n\n    if(checkFns.length > 0){\n      console.error(`Some settings have not been initialized correctly, did you run train()? Found issues with: ${checkFns.join(', ')}`);\n      return false;\n    }\n    return true;\n  }\n\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (!this.isRunnable) return null;\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = [...this.runInput(input)];\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   * \n   * @param {Function} activationFn \n   * @returns {Function}\n   */\n  _createRunInput(activationFn) {\n    return function _runInput(input) {\n      this.outputs[0] = input;  // set output state of input layer\n\n      let output = null;\n      for (let layer = 1; layer <= this.outputLayer; layer++) {\n        for (let node = 0; node < this.sizes[layer]; node++) {\n          const weights = this.weights[layer][node];\n\n          let sum = this.biases[layer][node];\n          for (let k = 0; k < weights.length; k++) {\n            sum += weights[k] * input[k];\n          }\n          \n          this.outputs[layer][node] = activationFn(sum);\n        }\n        output = input = this.outputs[layer];\n      }\n      return output;\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * Verifies network sizes are initilaized\n   * If they are not it will initialize them based off the data set.\n   */\n  _verifyIsInitialized(data) {\n    if (this.sizes) return;\n\n    this.sizes = [];\n    this.sizes.push(data[0].input.length);\n    if (!this.hiddenSizes) {\n      this.sizes.push(Math.max(3, Math.floor(data[0].input.length / 2)));\n    } else {\n      this.hiddenSizes.forEach(size => {\n        this.sizes.push(size);\n      });\n    }\n    this.sizes.push(data[0].output.length);\n\n    this._initialize();\n  }\n\n  /**\n   *\n   * @param opts\n   *    Supports all `trainDefaults` properties\n   *    also supports:\n   *       learningRate: (number),\n   *       momentum: (number),\n   *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'\n   */\n  _updateTrainingOptions(opts) {\n    Object.keys(NeuralNetwork.trainDefaults).forEach(opt => this.trainOpts[opt] = (opts.hasOwnProperty(opt)) ? opts[opt] : this.trainOpts[opt]);\n    NeuralNetwork._validateTrainingOptions(this.trainOpts);\n    this._setLogMethod(opts.log || this.trainOpts.log);\n    this.activation = opts.activation || this.activation;\n  }\n\n  /**\n   *\n   *  Gets JSON of trainOpts object\n   *    NOTE: Activation is stored directly on JSON object and not in the training options\n   */\n  _getTrainOptsJSON() {\n    return Object.keys(NeuralNetwork.trainDefaults)\n      .reduce((opts, opt) => {\n        if (opt === 'timeout' && this.trainOpts[opt] === Infinity) return opts;\n        if (this.trainOpts[opt]) opts[opt] = this.trainOpts[opt];\n        if (opt === 'log') opts.log = typeof opts.log === 'function';\n        return opts;\n      }, {});\n  }\n\n  /**\n   *\n   * @param log\n   * if a method is passed in method is used\n   * if false passed in nothing is logged\n   * @returns error\n   */\n  _setLogMethod(log) {\n    if (typeof log === 'function'){\n      this.trainOpts.log = log;\n    } else if (log) {\n      this.trainOpts.log = console.log;\n    } else {\n      this.trainOpts.log = false;\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {Number} error\n   */\n  _calculateTrainingError(data) {\n    let sum = 0;\n    for (let i = 0; i < data.length; ++i) {\n      sum += this._trainPattern(data[i].input, data[i].output, true);\n    }\n    return sum / data.length;\n  }\n\n  /**\n   * @param data\n   * @private\n   */\n  _trainPatterns(data) {\n    for (let i = 0; i < data.length; ++i) {\n      this._trainPattern(data[i].input, data[i].output, false);\n    }\n  }\n\n  /**\n   *\n   * @param {object} data\n   * @param {object} status { iterations: number, error: number }\n   * @param endTime\n   */\n  _trainingTick(data, status, endTime) {\n    if (status.iterations >= this.trainOpts.iterations || status.error <= this.trainOpts.errorThresh || Date.now() >= endTime) {\n      return false;\n    }\n\n    status.iterations++;\n\n    if (this.trainOpts.log && (status.iterations % this.trainOpts.logPeriod === 0)) {\n      status.error = this._calculateTrainingError(data);\n      this.trainOpts.log(`iterations: ${status.iterations}, training error: ${status.error}`);\n    } else {\n      if (status.iterations % this.errorCheckInterval === 0) {\n        status.error = this._calculateTrainingError(data);\n      } else {\n        this._trainPatterns(data);\n      }\n    }\n\n    if (this.trainOpts.callback && (status.iterations % this.trainOpts.callbackPeriod === 0)) {\n      this.trainOpts.callback(Object.assign(status));\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @protected\n   * @return { data, status, endTime }\n   */\n  _prepTraining(data, options) {\n    this._updateTrainingOptions(options);\n    data = this._formatData(data);\n    const endTime = Date.now() + this.trainOpts.timeout;\n\n    const status = {\n      error: 1,\n      iterations: 0\n    };\n\n    this._verifyIsInitialized(data);\n\n    return {\n      data,\n      status,\n      endTime\n    };\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options = {}) {\n    let status, endTime;\n    ({ data, status, endTime } = this._prepTraining(data, options));\n\n    while (this._trainingTick(data, status, endTime));\n    return status;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {Promise}\n   * @resolves {{error: number, iterations: number}}\n   * @rejects {{trainError: string, status: {error: number, iterations: number}}\n   */\n  trainAsync(data, options = {}) {\n    let status, endTime;\n    ({ data, status, endTime } = this._prepTraining(data, options));\n\n    return new Promise((resolve, reject) => {\n      try {\n        const thawedTrain = new Thaw(new Array(this.trainOpts.iterations), {\n          delay: true,\n          each: () => this._trainingTick(data, status, endTime) || thawedTrain.stop(),\n          done: () => resolve(status)\n        });\n        thawedTrain.tick();\n      } catch (trainError) {\n        reject({trainError, status});\n      }\n    });\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   */\n  _trainPattern(input, target, logErrorRate) {\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this._adjustWeights();\n\n    if  (logErrorRate) {\n      return mse(this.errors[this.outputLayer]);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * \n   * @param {Function} deltaFn \n   * @returns {Function}\n   */\n  _createCalculateDeltas(deltaFn) {\n    return function _calcuateDeltas(target) {\n      for (let layer = this.outputLayer; layer >= 0; layer--) {\n        for (let node = 0; node < this.sizes[layer]; node++) {\n          const output = this.outputs[layer][node];\n  \n          let error = 0;\n          if (layer === this.outputLayer) {\n            error = target[node] - output;\n          }\n          else {\n            const deltas = this.deltas[layer + 1];\n            for (let k = 0; k < deltas.length; k++) {\n              error += deltas[k] * this.weights[layer + 1][k][node];\n            }\n          }\n          this.errors[layer][node] = error;\n          this.deltas[layer][node] = deltaFn(output, error);\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * Changes weights of networks\n   */\n  _adjustWeights() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let incoming = this.outputs[layer - 1];\n\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let delta = this.deltas[layer][node];\n\n        for (let k = 0; k < incoming.length; k++) {\n          let change = this.changes[layer][node][k];\n\n          change = (this.trainOpts.learningRate * delta * incoming[k])\n            + (this.trainOpts.momentum * change);\n\n          this.changes[layer][node][k] = change;\n          this.weights[layer][node][k] += change;\n        }\n        this.biases[layer][node] += this.trainOpts.learningRate * delta;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  _formatData(data) {\n    if (!Array.isArray(data)) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (!Array.isArray(datum) && !(datum instanceof Float32Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (!Array.isArray(data[0].output)) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this._formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length === 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual !== expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual === 0 && expected === 0) {\n          trueNeg++;\n        } else if (actual === 1 && expected === 1) {\n          truePos++;\n        } else if (actual === 0 && expected === 1) {\n          falseNeg++;\n        } else if (actual === 1 && expected === 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   * @returns\n   *  {\n   *    layers: [\n   *      {\n   *        x: {},\n   *        y: {}\n   *      },\n   *      {\n   *        '0': {\n   *          bias: -0.98771313,\n   *          weights: {\n   *            x: 0.8374838,\n   *            y: 1.245858\n   *          },\n   *        '1': {\n   *          bias: 3.48192004,\n   *          weights: {\n   *            x: 1.7825821,\n   *            y: -2.67899\n   *          }\n   *        }\n   *      },\n   *      {\n   *        f: {\n   *          bias: 0.27205739,\n   *          weights: {\n   *            '0': 1.3161821,\n   *            '1': 2.00436\n   *          }\n   *        }\n   *      }\n   *    ]\n   *  }\n   */\n  toJSON() {\n    let layers = [];\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      layers[layer] = {};\n\n      let nodes;\n      // turn any internal arrays back into hashes for readable json\n      if (layer === 0 && this.inputLookup) {\n        nodes = Object.keys(this.inputLookup);\n      }\n      else if (layer === this.outputLayer && this.outputLookup) {\n        nodes = Object.keys(this.outputLookup);\n      }\n      else {\n        nodes = range(0, this.sizes[layer]);\n      }\n\n      for (let j = 0; j < nodes.length; j++) {\n        let node = nodes[j];\n        layers[layer][node] = {};\n\n        if (layer > 0) {\n          layers[layer][node].bias = this.biases[layer][j];\n          layers[layer][node].weights = {};\n          for (let k in layers[layer - 1]) {\n            let index = k;\n            if (layer === 1 && this.inputLookup) {\n              index = this.inputLookup[k];\n            }\n            layers[layer][node].weights[k] = this.weights[layer][j][index];\n          }\n        }\n      }\n    }\n    return {\n      sizes: this.sizes,\n      layers,\n      outputLookup:!!this.outputLookup,\n      inputLookup:!!this.inputLookup,\n      activation: this.activation,\n      trainOpts: this._getTrainOptsJSON()\n    };\n  }\n\n  /**\n   *\n   * @param json\n   * @returns {NeuralNetwork}\n   */\n  fromJSON(json) {\n    this.sizes = json.sizes;\n    this._initialize();\n\n    for (let i = 0; i <= this.outputLayer; i++) {\n      let layer = json.layers[i];\n      if (i === 0 && (!layer[0] || json.inputLookup)) {\n        this.inputLookup = lookup.lookupFromHash(layer);\n      }\n      else if (i === this.outputLayer && (!layer[0] || json.outputLookup)) {\n        this.outputLookup = lookup.lookupFromHash(layer);\n      }\n      if (i > 0) {\n        const nodes = Object.keys(layer);\n        this.sizes[i] = nodes.length;\n        for (let j in nodes) {\n          const node = nodes[j];\n          this.biases[i][j] = layer[node].bias;\n          this.weights[i][j] = toArray(layer[node].weights);\n        }\n      }\n    }\n    if (json.hasOwnProperty('trainOpts')) {\n      this._updateTrainingOptions(json.trainOpts);\n    }\n    this.setActivation(this.activation || 'sigmoid');\n    return this;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    const activation = this.activation;\n\n    if (!Object.keys(availableActivations).includes(activation)) {\n      throw new Error(`unknown activation type ${activation}`);\n    }\n\n    function nodeHandle(layers, layerNumber, nodeKey) {\n      if (layerNumber === 0) {\n        return (typeof nodeKey === 'string'\n          ? `input['${nodeKey}']`\n          : `input[${nodeKey}]`);\n      }\n\n      const layer = layers[layerNumber];\n      const node = layer[nodeKey];\n      let result = [node.bias];\n      for (let w in node.weights) {\n        result.push(\n          `${node.weights[w] < 0 ? '' : '+'}${node.weights[w]}*(${nodeHandle(layers, layerNumber - 1, w)})`\n        );\n      }\n\n      return `(${availableActivations[activation].activationFn.toString()})(${result.join('')})`;\n    }\n\n    const layers = this.toJSON().layers;\n    const layersAsMath = [];\n    let result;\n    for (let i in layers[layers.length - 1]) {\n      layersAsMath.push(nodeHandle(layers, layers.length - 1, i));\n    }\n    if (this.outputLookup) {\n      result = `{${\n        Object.keys(this.outputLookup)\n          .map((key, i) => `'${key}':${layersAsMath[i]}`)\n      }}`;\n    } else {\n      result = `[${layersAsMath.join(',')}]`;\n    }\n    return new Function('input', `return ${result}`);\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    opts = opts || {};\n    opts.neuralNetwork = this;\n    this.setActivation();\n    this.trainStream = new TrainStream(opts);\n    return this.trainStream;\n  }\n}\n"]}