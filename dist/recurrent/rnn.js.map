{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["RNN","options","defaults","constructor","Object","assign","trainOpts","updateTrainingOptions","trainDefaults","stepCache","runs","ratioClipped","model","inputLookup","inputLookupLength","outputLookup","outputLookupLength","json","fromJSON","input","hiddenLayers","output","equations","allMatrices","equationConnections","outputConnector","dataFormatter","inputSize","inputRange","outputSize","characters","length","mapModel","push","getModel","prevSize","d","hiddenSize","weight","RandomMatrix","transition","bias","Matrix","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","lastHiddenSize","Equation","outputs","equationConnection","initialLayerInputs","getEquation","inputMatrixToRow","i","max","map","size","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","hasOwnProperty","createOutputMatrix","logErrorRate","error","trainInput","backpropagate","adjustWeights","log2ppl","bindEquation","inputIndex","inputMax","equationIndex","source","target","predictTargetIndex","Math","pow","backpropagateIndex","regc","clipval","decayRate","smoothEps","learningRate","numClipped","numTot","matrixIndex","matrix","weights","deltas","rows","columns","cache","r","w","sqrt","rawInput","isSampleI","temperature","maxPredictionLength","specialIndexes","isRunnable","formatDataIn","previousIndex","outputMatrix","runIndex","logProbabilities","j","probs","nextIndex","formatDataOut","slice","value","data","initialize","keys","forEach","p","validateTrainingOptions","setLogMethod","log","activation","NeuralNetwork","prototype","call","console","formatData","endTime","Date","now","timeout","status","iterations","verifyIsInitialized","errorThresh","logPeriod","callback","callbackPeriod","Infinity","setupData","sum","err","trainPattern","isNaN","type","name","toJSON","layers","hiddenSizes","DataFormatter","states","jsonString","JSON","stringify","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","replace","fileName","fnName","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","src","toFunctionString","zeros","softmax","randomF","sampleI","maxI","Function","Array","isArray","values","result","fromArrayInputOutput","addUnrecognized","indexTable","toIndexesInputOutput","toIndexes","toCharacters"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\r\nimport RandomMatrix from './matrix/random-matrix';\r\nimport Equation from './matrix/equation';\r\nimport sampleI from './matrix/sample-i';\r\nimport maxI from './matrix/max-i';\r\nimport softmax from './matrix/softmax';\r\nimport copy from './matrix/copy';\r\nimport { randomF } from '../utilities/random';\r\nimport zeros from '../utilities/zeros';\r\nimport DataFormatter from '../utilities/data-formatter';\r\nimport NeuralNetwork from '../neural-network';\r\n\r\nexport default class RNN {\r\n  constructor(options = {}) {\r\n    const defaults = this.constructor.defaults;\r\n\r\n    Object.assign(this, defaults, options);\r\n    this.trainOpts = {};\r\n    this.updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));\r\n\r\n    this.stepCache = {};\r\n    this.runs = 0;\r\n    this.ratioClipped = null;\r\n    this.model = null;\r\n    this.inputLookup = null;\r\n    this.inputLookupLength = null;\r\n    this.outputLookup = null;\r\n    this.outputLookupLength = null;\r\n\r\n    if (options.json) {\r\n      this.fromJSON(options.json);\r\n    }\r\n  }\r\n\r\n  initialize() {\r\n    this.model = {\r\n      input: null,\r\n      hiddenLayers: [],\r\n      output: null,\r\n      equations: [],\r\n      allMatrices: [],\r\n      equationConnections: [],\r\n      outputConnector: null,\r\n    };\r\n\r\n    if (this.dataFormatter) {\r\n      this.inputSize =\r\n      this.inputRange =\r\n      this.outputSize = this.dataFormatter.characters.length;\r\n    }\r\n    this.mapModel();\r\n  }\r\n\r\n  createHiddenLayers() {\r\n    //0 is end, so add 1 to offset\r\n    this.model.hiddenLayers.push(this.getModel(this.hiddenLayers[0], this.inputSize));\r\n    let prevSize = this.hiddenLayers[0];\r\n\r\n    for (let d = 1; d < this.hiddenLayers.length; d++) { // loop over depths\r\n      let hiddenSize = this.hiddenLayers[d];\r\n      this.model.hiddenLayers.push(this.getModel(hiddenSize, prevSize));\r\n      prevSize = hiddenSize;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number} hiddenSize\r\n   * @param {Number} prevSize\r\n   * @returns {object}\r\n   */\r\n  getModel(hiddenSize, prevSize) {\r\n    return {\r\n      //wxh\r\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\r\n      //whh\r\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\r\n      //bhh\r\n      bias: new Matrix(hiddenSize, 1)\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Equation} equation\r\n   * @param {Matrix} inputMatrix\r\n   * @param {Matrix} previousResult\r\n   * @param {Object} hiddenLayer\r\n   * @returns {Matrix}\r\n   */\r\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\r\n    let relu = equation.relu.bind(equation);\r\n    let add = equation.add.bind(equation);\r\n    let multiply = equation.multiply.bind(equation);\r\n\r\n    return relu(\r\n      add(\r\n        add(\r\n          multiply(\r\n            hiddenLayer.weight,\r\n            inputMatrix\r\n          ),\r\n          multiply(\r\n            hiddenLayer.transition,\r\n            previousResult\r\n          )\r\n        ),\r\n        hiddenLayer.bias\r\n      )\r\n    );\r\n  }\r\n\r\n  createInputMatrix() {\r\n    //0 is end, so add 1 to offset\r\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\r\n  }\r\n\r\n  createOutputMatrix() {\r\n    let model = this.model;\r\n    let outputSize = this.outputSize;\r\n    let lastHiddenSize = this.hiddenLayers[this.hiddenLayers.length - 1];\r\n\r\n    //0 is end, so add 1 to offset\r\n    //whd\r\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\r\n    //0 is end, so add 1 to offset\r\n    //bd\r\n    model.output = new Matrix(outputSize + 1, 1);\r\n  }\r\n\r\n  bindEquation() {\r\n    const model = this.model;\r\n    const equation = new Equation();\r\n    const outputs = [];\r\n    const equationConnection = model.equationConnections.length > 0\r\n      ? model.equationConnections[model.equationConnections.length - 1]\r\n      : this.initialLayerInputs\r\n      ;\r\n\r\n      // 0 index\r\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], model.hiddenLayers[0]);\r\n    outputs.push(output);\r\n    // 1+ indices\r\n    for (let i = 1, max = this.hiddenLayers.length; i < max; i++) {\r\n      output = this.getEquation(equation, output, equationConnection[i], model.hiddenLayers[i]);\r\n      outputs.push(output);\r\n    }\r\n\r\n    model.equationConnections.push(outputs);\r\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\r\n    model.equations.push(equation);\r\n  }\r\n\r\n  mapModel() {\r\n    const model = this.model;\r\n    const hiddenLayers = model.hiddenLayers;\r\n    const allMatrices = model.allMatrices;\r\n    this.initialLayerInputs = this.hiddenLayers.map((size) => new Matrix(size, 1));\r\n\r\n    this.createInputMatrix();\r\n    if (!model.input) throw new Error('net.model.input not set');\r\n    allMatrices.push(model.input);\r\n\r\n    this.createHiddenLayers();\r\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\r\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\r\n      let hiddenMatrix = hiddenLayers[i];\r\n      for (let property in hiddenMatrix) {\r\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\r\n        allMatrices.push(hiddenMatrix[property]);\r\n      }\r\n    }\r\n\r\n    this.createOutputMatrix();\r\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\r\n    if (!model.output) throw new Error('net.model.output not set');\r\n\r\n    allMatrices.push(model.outputConnector);\r\n    allMatrices.push(model.output);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]|string[]|string} input\r\n   * @param {boolean} [logErrorRate]\r\n   * @returns {number}\r\n   */\r\n  trainPattern(input, logErrorRate) {\r\n    const error = this.trainInput(input);\r\n    this.backpropagate(input);\r\n    this.adjustWeights();\r\n\r\n    if (logErrorRate) {\r\n      return error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]} input\r\n   * @returns {number}\r\n   */\r\n  trainInput(input) {\r\n    this.runs++;\r\n    let model = this.model;\r\n    let max = input.length;\r\n    let log2ppl = 0;\r\n    let equation;\r\n    while (model.equations.length <= input.length + 1) {//last is zero\r\n      this.bindEquation();\r\n    }\r\n    for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\r\n      // start and end tokens are zeros\r\n      let equationIndex = inputIndex + 1;\r\n      equation = model.equations[equationIndex];\r\n\r\n      let source = (inputIndex === -1 ? 0 : input[inputIndex] + 1); // first step: start with START token\r\n      let target = (inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1); // last step: end with END token\r\n      log2ppl += equation.predictTargetIndex(source, target);\r\n    }\r\n    return Math.pow(2, log2ppl / (max - 1)) / 100;\r\n  }\r\n\r\n  /**\r\n   * @param {Number[]} input\r\n   */\r\n  backpropagate(input) {\r\n    let i = input.length;\r\n    let model = this.model;\r\n    let equations = model.equations;\r\n    while(i > 0) {\r\n      equations[i].backpropagateIndex(input[i - 1] + 1);\r\n      i--;\r\n    }\r\n    equations[0].backpropagateIndex(0);\r\n  }\r\n\r\n  adjustWeights() {\r\n    const { regc, clipval, model, decayRate, stepCache, smoothEps, trainOpts } = this;\r\n    const { learningRate } = trainOpts;\r\n    const { allMatrices } = model;\r\n    let numClipped = 0;\r\n    let numTot = 0;\r\n    for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {\r\n      const matrix = allMatrices[matrixIndex];\r\n      const { weights, deltas }  = matrix;\r\n      if (!(matrixIndex in stepCache)) {\r\n        stepCache[matrixIndex] = zeros(matrix.rows * matrix.columns);\r\n      }\r\n      const cache = stepCache[matrixIndex];\r\n      for (let i = 0; i < weights.length; i++) {\r\n        let r = deltas[i];\r\n        let w = weights[i];\r\n        // rmsprop adaptive learning rate\r\n        cache[i] = cache[i] * decayRate + (1 - decayRate) * r * r;\r\n        // gradient clip\r\n        if (r > clipval) {\r\n          r = clipval;\r\n          numClipped++;\r\n        }\r\n        if (r < -clipval) {\r\n          r = -clipval;\r\n          numClipped++;\r\n        }\r\n        numTot++;\r\n        // update (and regularize)\r\n        weights[i] = w + -learningRate * r / Math.sqrt(cache[i] + smoothEps) - regc * w;\r\n      }\r\n    }\r\n    this.ratioClipped = numClipped / numTot;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @returns boolean\r\n   */\r\n  get isRunnable(){\r\n    if (this.model.equations.length === 0) {\r\n      console.error(`No equations bound, did you run train()?`);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]|*} [rawInput]\r\n   * @param {Boolean} [isSampleI]\r\n   * @param {Number} temperature\r\n   * @returns {*}\r\n   */\r\n  run(rawInput = [], isSampleI = false, temperature = 1) {\r\n    const maxPredictionLength = this.maxPredictionLength + rawInput.length + (this.dataFormatter ? this.dataFormatter.specialIndexes.length : 0);\r\n    if (!this.isRunnable) return null;\r\n    const input = this.formatDataIn(rawInput);\r\n    const model = this.model;\r\n    const output = [];\r\n    let i = 0;\r\n    while (true) {\r\n      let previousIndex = (i === 0\r\n        ? 0\r\n        : i < input.length\r\n          ? input[i - 1] + 1\r\n          : output[i - 1])\r\n          ;\r\n      while (model.equations.length <= i) {\r\n        this.bindEquation();\r\n      }\r\n      let equation = model.equations[i];\r\n      // sample predicted letter\r\n      let outputMatrix = equation.runIndex(previousIndex);\r\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\r\n      copy(logProbabilities, outputMatrix);\r\n      if (temperature !== 1 && isSampleI) {\r\n        /**\r\n         * scale log probabilities by temperature and re-normalize\r\n         * if temperature is high, logProbabilities will go towards zero\r\n         * and the softmax outputs will be more diffuse. if temperature is\r\n         * very low, the softmax outputs will be more peaky\r\n         */\r\n        for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {\r\n          logProbabilities.weights[j] /= temperature;\r\n        }\r\n      }\r\n\r\n      let probs = softmax(logProbabilities);\r\n      let nextIndex = (isSampleI ? sampleI(probs) : maxI(probs));\r\n\r\n      i++;\r\n      if (nextIndex === 0) {\r\n        // END token predicted, break out\r\n        break;\r\n      }\r\n      if (i >= maxPredictionLength) {\r\n        // something is wrong\r\n        break;\r\n      }\r\n\r\n      output.push(nextIndex);\r\n    }\r\n\r\n    /**\r\n     * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the\r\n     * network what is contained in input, so the data is essentially guessed by the network what could be next, till it\r\n     * locks in on a value.\r\n     * Kind of like this, values are from input:\r\n     * 0 -> 4 (or in English: \"beginning on input\" -> \"I have no idea? I'll guess what they want next!\")\r\n     * 2 -> 2 (oh how interesting, I've narrowed down values...)\r\n     * 1 -> 9 (oh how interesting, I've now know what the values are...)\r\n     * then the output looks like: [4, 2, 9,...]\r\n     * so we then remove the erroneous data to get our true output\r\n     */\r\n    return this.formatDataOut(\r\n      input,\r\n      output\r\n        .slice(input.length)\r\n        .map(value => value - 1)\r\n    );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param data\r\n   * Verifies network sizes are initilaized\r\n   * If they are not it will initialize them based off the data set.\r\n   */\r\n  verifyIsInitialized(data) {\r\n    if (!this.model) {\r\n      this.initialize();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param options\r\n   *    Supports all `trainDefaults` properties\r\n   *    also supports:\r\n   *       learningRate: (number),\r\n   *       momentum: (number),\r\n   *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'\r\n   */\r\n  updateTrainingOptions(options) {\r\n    Object.keys(this.constructor.trainDefaults).forEach(p => this.trainOpts[p] = (options.hasOwnProperty(p)) ? options[p] : this.trainOpts[p]);\r\n    this.validateTrainingOptions(this.trainOpts);\r\n    this.setLogMethod(options.log || this.trainOpts.log);\r\n    this.activation = options.activation || this.activation;\r\n  }\r\n\r\n  validateTrainingOptions(options) {\r\n    NeuralNetwork.prototype.validateTrainingOptions.call(this, options);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param log\r\n   * if a method is passed in method is used\r\n   * if false passed in nothing is logged\r\n   * @returns error\r\n   */\r\n  setLogMethod(log) {\r\n    if (typeof log === 'function'){\r\n      this.trainOpts.log = log;\r\n    } else if (log) {\r\n      this.trainOpts.log = console.log;\r\n    } else {\r\n      this.trainOpts.log = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param data\r\n   * @param options\r\n   * @protected\r\n   * @return {object} { data, status, endTime }\r\n   */\r\n  prepTraining(data, options) {\r\n    this.updateTrainingOptions(options);\r\n    data = this.formatData(data);\r\n    const endTime = Date.now() + this.trainOpts.timeout;\r\n\r\n    const status = {\r\n      error: 1,\r\n      iterations: 0\r\n    };\r\n\r\n    this.verifyIsInitialized(data);\r\n\r\n    return {\r\n      data,\r\n      status,\r\n      endTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings\r\n   * @param {Object} [options]\r\n   * @returns {{error: number, iterations: number}}\r\n   */\r\n  train(data, options = {}) {\r\n    this.trainOpts = options = Object.assign({}, this.constructor.trainDefaults, options);\r\n    let iterations = options.iterations;\r\n    let errorThresh = options.errorThresh;\r\n    let log = options.log === true ? console.log : options.log;\r\n    let logPeriod = options.logPeriod;\r\n    let callback = options.callback;\r\n    let callbackPeriod = options.callbackPeriod;\r\n    let error = Infinity;\r\n    let i;\r\n\r\n    if (this.hasOwnProperty('setupData')) {\r\n      data = this.setupData(data);\r\n    }\r\n\r\n    this.verifyIsInitialized();\r\n\r\n    for (i = 0; i < iterations && error > errorThresh; i++) {\r\n      let sum = 0;\r\n      for (let j = 0; j < data.length; j++) {\r\n        const err = this.trainPattern(data[j], true);\r\n        sum += err;\r\n      }\r\n      error = sum / data.length;\r\n\r\n      if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\r\n      if (log && (i % logPeriod === 0)) {\r\n        log(`iterations: ${ i }, training error: ${ error }`);\r\n      }\r\n      if (callback && (i % callbackPeriod === 0)) {\r\n        callback({ error: error, iterations: i });\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      iterations: i\r\n    };\r\n  }\r\n\r\n  addFormat() {\r\n    throw new Error('not yet implemented');\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  toJSON() {\r\n    const defaults = this.constructor.defaults;\r\n    if (!this.model) {\r\n      this.initialize();\r\n    }\r\n    let model = this.model;\r\n    let options = {};\r\n    for (let p in defaults) {\r\n      if (defaults.hasOwnProperty(p)) {\r\n        options[p] = this[p];\r\n      }\r\n    }\r\n\r\n    return {\r\n      type: this.constructor.name,\r\n      options: options,\r\n      input: model.input.toJSON(),\r\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\r\n        let layers = {};\r\n        for (let p in hiddenLayer) {\r\n          layers[p] = hiddenLayer[p].toJSON();\r\n        }\r\n        return layers;\r\n      }),\r\n      outputConnector: this.model.outputConnector.toJSON(),\r\n      output: this.model.output.toJSON()\r\n    };\r\n  }\r\n\r\n  fromJSON(json) {\r\n    const defaults = this.constructor.defaults;\r\n    const options = json.options;\r\n    this.model = null;\r\n    this.hiddenLayers = null;\r\n    const allMatrices = [];\r\n    const input = Matrix.fromJSON(json.input);\r\n    allMatrices.push(input);\r\n    const hiddenLayers = [];\r\n\r\n    // backward compatibility for hiddenSizes\r\n    (json.hiddenLayers || json.hiddenSizes).forEach((hiddenLayer) => {\r\n      let layers = {};\r\n      for (let p in hiddenLayer) {\r\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\r\n        allMatrices.push(layers[p]);\r\n      }\r\n      hiddenLayers.push(layers);\r\n    });\r\n\r\n    const outputConnector = Matrix.fromJSON(json.outputConnector);\r\n    allMatrices.push(outputConnector);\r\n    const output = Matrix.fromJSON(json.output);\r\n    allMatrices.push(output);\r\n\r\n    Object.assign(this, defaults, options);\r\n\r\n    // backward compatibility\r\n    if (options.hiddenSizes) {\r\n      this.hiddenLayers = options.hiddenSizes;\r\n    }\r\n\r\n    if (options.dataFormatter) {\r\n      this.dataFormatter = DataFormatter.fromJSON(options.dataFormatter);\r\n    }\r\n\r\n    this.model = {\r\n      input,\r\n      hiddenLayers,\r\n      output,\r\n      allMatrices,\r\n      outputConnector,\r\n      equations: [],\r\n      equationConnections: [],\r\n    };\r\n    this.initialLayerInputs = this.hiddenLayers.map((size) => new Matrix(size, 1));\r\n    this.bindEquation();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {Function}\r\n   */\r\n  toFunction() {\r\n    let model = this.model;\r\n    let equations = this.model.equations;\r\n    let equation = equations[1];\r\n    let states = equation.states;\r\n    let jsonString = JSON.stringify(this.toJSON());\r\n\r\n    function matrixOrigin(m, stateIndex) {\r\n      for (let i = 0, max = states.length; i < max; i++) {\r\n        let state = states[i];\r\n\r\n        if (i === stateIndex) {\r\n          let j = previousConnectionIndex(m);\r\n          switch (m) {\r\n            case state.left:\r\n              if (j > -1) {\r\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\r\n              }\r\n            case state.right:\r\n              if (j > -1) {\r\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\r\n              }\r\n            case state.product:\r\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\r\n            default:\r\n              throw Error('unknown state');\r\n          }\r\n        }\r\n\r\n        if (m === state.product) return `states[${ i }].product`;\r\n        if (m === state.right) return `states[${ i }].right`;\r\n        if (m === state.left) return `states[${ i }].left`;\r\n      }\r\n    }\r\n\r\n    function previousConnectionIndex(m) {\r\n      const connection = model.equationConnections[0];\r\n      const states = equations[0].states;\r\n      for (let i = 0, max = states.length; i < max; i++) {\r\n        if (states[i].product === m) {\r\n          return i;\r\n        }\r\n      }\r\n      return connection.indexOf(m);\r\n    }\r\n\r\n    function matrixToString(m, stateIndex) {\r\n      if (!m || !m.rows || !m.columns) return 'null';\r\n\r\n      if (m === model.input) return `json.input`;\r\n      if (m === model.outputConnector) return `json.outputConnector`;\r\n      if (m === model.output) return `json.output`;\r\n\r\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\r\n        let hiddenLayer = model.hiddenLayers[i];\r\n        for (let p in hiddenLayer) {\r\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\r\n          if (hiddenLayer[p] !== m) continue;\r\n          return `json.hiddenLayers[${ i }].${ p }`;\r\n        }\r\n      }\r\n\r\n      return matrixOrigin(m, stateIndex);\r\n    }\r\n\r\n    function toInner(fnString) {\r\n      // crude, but should be sufficient for now\r\n      // function() { body }\r\n      fnString = fnString.toString().split('{');\r\n      fnString.shift();\r\n      // body }\r\n      fnString = fnString.join('{');\r\n      fnString = fnString.split('}');\r\n      fnString.pop();\r\n      // body\r\n      return fnString.join('}').split('\\n').join('\\n        ')\r\n        .replace('product.deltas[i] = 0;', '')\r\n        .replace('product.deltas[column] = 0;', '')\r\n        .replace('left.deltas[leftIndex] = 0;', '')\r\n        .replace('right.deltas[rightIndex] = 0;', '')\r\n        .replace('product.deltas = left.deltas.slice(0);', '');\r\n    }\r\n\r\n    function fileName(fnName) {\r\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\r\n    }\r\n\r\n    let statesRaw = [];\r\n    let usedFunctionNames = {};\r\n    let innerFunctionsSwitch = [];\r\n    for (let i = 0, max = states.length; i < max; i++) {\r\n      let state = states[i];\r\n      statesRaw.push(`states[${ i }] = {\r\n      name: '${ state.forwardFn.name }',\r\n      left: ${ matrixToString(state.left, i) },\r\n      right: ${ matrixToString(state.right, i) },\r\n      product: ${ matrixToString(state.product, i) }\r\n    }`);\r\n\r\n      let fnName = state.forwardFn.name;\r\n      if (!usedFunctionNames[fnName]) {\r\n        usedFunctionNames[fnName] = true;\r\n        innerFunctionsSwitch.push(\r\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\r\n          ${ toInner(state.forwardFn.toString()) }\r\n          break;`\r\n        );\r\n      }\r\n    }\r\n\r\n    const src = `\r\n  if (typeof rawInput === 'undefined') rawInput = [];\r\n  if (typeof isSampleI === 'undefined') isSampleI = false;\r\n  if (typeof temperature === 'undefined') temperature = 1;\r\n  ${ this.dataFormatter ? this.dataFormatter.toFunctionString() : '' }\r\n  \r\n  var input = ${\r\n      (this.dataFormatter && typeof this.formatDataIn === 'function')\r\n        ? 'formatDataIn(rawInput)' \r\n        : 'rawInput'\r\n    };\r\n  var json = ${ jsonString };\r\n  var maxPredictionLength = input.length + ${ this.maxPredictionLength };\r\n  var _i = 0;\r\n  var output = [];\r\n  var states = [];\r\n  var prevStates;\r\n  while (true) {\r\n    var previousIndex = (_i === 0\r\n        ? 0\r\n        : _i < input.length\r\n          ? input[_i - 1] + 1\r\n          : output[_i - 1])\r\n          ;\r\n    var rowPluckIndex = previousIndex;\r\n    var state;\r\n    prevStates = states;\r\n    states = [];\r\n    ${ statesRaw.join(';\\n    ') };\r\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\r\n      state = states[stateIndex];\r\n      var product = state.product;\r\n      var left = state.left;\r\n      var right = state.right;\r\n      \r\n      switch (state.name) {\r\n${ innerFunctionsSwitch.join('\\n') }\r\n      }\r\n    }\r\n    \r\n    var logProbabilities = state.product;\r\n    if (temperature !== 1 && isSampleI) {\r\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\r\n        logProbabilities.weights[q] /= temperature;\r\n      }\r\n    }\r\n\r\n    var probs = softmax(logProbabilities);\r\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\r\n    \r\n    _i++;\r\n    if (nextIndex === 0) {\r\n      break;\r\n    }\r\n    if (_i >= maxPredictionLength) {\r\n      break;\r\n    }\r\n\r\n    output.push(nextIndex);\r\n  }\r\n  ${ (this.dataFormatter && typeof this.formatDataOut === 'function') \r\n      ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))'\r\n      : 'return output.slice(input.length).map(function(value) { return value - 1; })' };\r\n  function Matrix(rows, columns) {\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n    this.weights = zeros(rows * columns);\r\n  }\r\n  ${ this.dataFormatter && typeof this.formatDataIn === 'function'\r\n      ? `function formatDataIn(input, output) { ${\r\n          toInner(this.formatDataIn.toString())\r\n            .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\r\n            .replace(/this[.]dataFormatter[.]/g, '')\r\n            .replace(/this[.]dataFormatter/g, 'true')\r\n        } }`\r\n      : '' }\r\n  ${ this.dataFormatter !== null && typeof this.formatDataOut === 'function'\r\n        ? `function formatDataOut(input, output) { ${\r\n            toInner(this.formatDataOut.toString())\r\n              .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\r\n              .replace(/this[.]dataFormatter[.]/g, '')\r\n              .replace(/this[.]dataFormatter/g, 'true')\r\n          } }` \r\n        : '' }\r\n  ${ zeros.toString() }\r\n  ${ softmax.toString().replace('_2.default', 'Matrix') }\r\n  ${ randomF.toString() }\r\n  ${ sampleI.toString() }\r\n  ${ maxI.toString() }`;\r\n    return new Function('rawInput', 'isSampleI', 'temperature', src);\r\n  }\r\n}\r\n\r\nRNN.defaults = {\r\n  inputSize: 20,\r\n  inputRange: 20,\r\n  hiddenLayers: [20,20],\r\n  outputSize: 20,\r\n  decayRate: 0.999,\r\n  smoothEps: 1e-8,\r\n  regc: 0.000001,\r\n  clipval: 5,\r\n  maxPredictionLength: 100,\r\n  /**\r\n   *\r\n   * @param {*[]} data\r\n   * @returns {Number[]}\r\n   */\r\n  setupData: function(data) {\r\n    if (\r\n      typeof data[0] !== 'string'\r\n      && !Array.isArray(data[0])\r\n      && (\r\n        !data[0].hasOwnProperty('input')\r\n        || !data[0].hasOwnProperty('output')\r\n      )\r\n    ) {\r\n      return data;\r\n    }\r\n    let values = [];\r\n    const result = [];\r\n    if (typeof data[0] === 'string' || Array.isArray(data[0])) {\r\n      if (!this.dataFormatter) {\r\n        for (let i = 0; i < data.length; i++) {\r\n          values.push(data[i]);\r\n        }\r\n        this.dataFormatter = new DataFormatter(values);\r\n      }\r\n      for (let i = 0, max = data.length; i < max; i++) {\r\n        result.push(this.formatDataIn(data[i]));\r\n      }\r\n    } else {\r\n      if (!this.dataFormatter) {\r\n        for (let i = 0; i < data.length; i++) {\r\n          values.push(data[i].input);\r\n          values.push(data[i].output);\r\n        }\r\n        this.dataFormatter = DataFormatter.fromArrayInputOutput(values);\r\n        this.dataFormatter.addUnrecognized();\r\n      }\r\n      for (let i = 0, max = data.length; i < max; i++) {\r\n        result.push(this.formatDataIn(data[i].input, data[i].output));\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n  /**\r\n   *\r\n   * @param {*[]} input\r\n   * @param {*[]} output\r\n   * @returns {Number[]}\r\n   */\r\n  formatDataIn: function(input, output = null) {\r\n    if (this.dataFormatter) {\r\n      if (this.dataFormatter.indexTable.hasOwnProperty('stop-input')) {\r\n        return this.dataFormatter.toIndexesInputOutput(input, output);\r\n      } else {\r\n        return this.dataFormatter.toIndexes(input);\r\n      }\r\n    }\r\n    return input;\r\n  },\r\n  /**\r\n   *\r\n   * @param {Number[]} input\r\n   * @param {Number[]} output\r\n   * @returns {*}\r\n   */\r\n  formatDataOut: function(input, output) {\r\n    if (this.dataFormatter) {\r\n      return this.dataFormatter\r\n        .toCharacters(output)\r\n        .join('');\r\n    }\r\n    return output;\r\n  },\r\n  dataFormatter: null\r\n};\r\n\r\nRNN.trainDefaults = {\r\n  iterations: 20000,\r\n  errorThresh: 0.005,\r\n  log: false,\r\n  logPeriod: 10,\r\n  learningRate: 0.01,\r\n  callback: null,\r\n  callbackPeriod: 10\r\n};\r\n"]}