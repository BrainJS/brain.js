{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["RNN","options","defaults","p","hasOwnProperty","stepCache","runs","totalCost","ratioClipped","model","initialLayerInputs","hiddenSizes","map","size","inputLookup","outputLookup","initialize","input","hiddenLayers","output","equations","allMatrices","equationConnections","dataFormatter","inputSize","inputRange","outputSize","characters","length","json","fromJSON","mapModel","push","getModel","prevSize","d","hiddenSize","weight","transition","bias","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","lastHiddenSize","outputConnector","outputs","equationConnection","getEquation","inputMatrixToRow","i","max","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","learningRate","error","runInput","runBackpropagate","step","log2ppl","cost","bindEquation","inputIndex","inputMax","equationIndex","source","target","run","logProbabilities","probabilities","Math","log2","weights","log","deltas","slice","pow","stepSize","regc","clipval","numClipped","numTot","matrixIndex","matrix","rows","columns","cache","r","w","decayRate","sqrt","smoothEps","rawInput","maxPredictionLength","isSampleI","temperature","formatDataIn","previousIndex","outputMatrix","j","probs","nextIndex","formatDataOut","value","data","Object","assign","trainDefaults","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","Infinity","setupData","keepNetworkIntact","sum","err","trainPattern","isNaN","type","constructor","name","toJSON","layers","JSON","stringify","parse","states","jsonString","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","replace","fileName","fnName","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function","toFunctionString","Array","isArray","values","result","fromArrayInputOutput","indexTable","toIndexesInputOutput","toIndexes","toCharacters"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\r\nimport RandomMatrix from './matrix/random-matrix';\r\nimport Equation from './matrix/equation';\r\nimport sampleI from './matrix/sample-i';\r\nimport maxI from './matrix/max-i';\r\nimport softmax from './matrix/softmax';\r\nimport copy from './matrix/copy';\r\nimport { randomF } from '../utilities/random';\r\nimport zeros from '../utilities/zeros';\r\nimport DataFormatter from '../utilities/data-formatter';\r\n\r\nexport default class RNN {\r\n  constructor(options = {}) {\r\n    const defaults = RNN.defaults;\r\n\r\n    for (let p in defaults) {\r\n      if (!defaults.hasOwnProperty(p)) continue;\r\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\r\n    }\r\n\r\n    this.stepCache = {};\r\n    this.runs = 0;\r\n    this.totalCost = null;\r\n    this.ratioClipped = null;\r\n    this.model = null;\r\n\r\n    this.initialLayerInputs = this.hiddenSizes.map((size) => new Matrix(this.hiddenSizes[0], 1));\r\n    this.inputLookup = null;\r\n    this.outputLookup = null;\r\n    this.initialize();\r\n  }\r\n\r\n  initialize() {\r\n    this.model = {\r\n      input: null,\r\n      hiddenLayers: [],\r\n      output: null,\r\n      equations: [],\r\n      allMatrices: [],\r\n      equationConnections: []\r\n    };\r\n\r\n    if (this.dataFormatter !== null) {\r\n      this.inputSize =\r\n      this.inputRange =\r\n      this.outputSize = this.dataFormatter.characters.length;\r\n    }\r\n\r\n    if (this.json) {\r\n      this.fromJSON(this.json);\r\n    } else {\r\n      this.mapModel();\r\n    }\r\n  }\r\n\r\n  createHiddenLayers() {\r\n    let hiddenSizes = this.hiddenSizes;\r\n    let model = this.model;\r\n    let hiddenLayers = model.hiddenLayers;\r\n    //0 is end, so add 1 to offset\r\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\r\n    let prevSize = hiddenSizes[0];\r\n\r\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\r\n      let hiddenSize = hiddenSizes[d];\r\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\r\n      prevSize = hiddenSize;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number} hiddenSize\r\n   * @param {Number} prevSize\r\n   * @returns {object}\r\n   */\r\n  getModel(hiddenSize, prevSize) {\r\n    return {\r\n      //wxh\r\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\r\n      //whh\r\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\r\n      //bhh\r\n      bias: new Matrix(hiddenSize, 1)\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Equation} equation\r\n   * @param {Matrix} inputMatrix\r\n   * @param {Matrix} previousResult\r\n   * @param {Object} hiddenLayer\r\n   * @returns {Matrix}\r\n   */\r\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\r\n    let relu = equation.relu.bind(equation);\r\n    let add = equation.add.bind(equation);\r\n    let multiply = equation.multiply.bind(equation);\r\n\r\n    return relu(\r\n      add(\r\n        add(\r\n          multiply(\r\n            hiddenLayer.weight,\r\n            inputMatrix\r\n          ),\r\n          multiply(\r\n            hiddenLayer.transition,\r\n            previousResult\r\n          )\r\n        ),\r\n        hiddenLayer.bias\r\n      )\r\n    );\r\n  }\r\n\r\n  createInputMatrix() {\r\n    //0 is end, so add 1 to offset\r\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\r\n  }\r\n\r\n  createOutputMatrix() {\r\n    let model = this.model;\r\n    let outputSize = this.outputSize;\r\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\r\n\r\n    //0 is end, so add 1 to offset\r\n    //whd\r\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\r\n    //0 is end, so add 1 to offset\r\n    //bd\r\n    model.output = new Matrix(outputSize + 1, 1);\r\n  }\r\n\r\n  bindEquation() {\r\n    let model = this.model;\r\n    let hiddenSizes = this.hiddenSizes;\r\n    let hiddenLayers = model.hiddenLayers;\r\n    let equation = new Equation();\r\n    let outputs = [];\r\n    let equationConnection = model.equationConnections.length > 0\r\n      ? model.equationConnections[model.equationConnections.length - 1]\r\n      : this.initialLayerInputs\r\n      ;\r\n\r\n      // 0 index\r\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], hiddenLayers[0]);\r\n    outputs.push(output);\r\n    // 1+ indices\r\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\r\n      output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);\r\n      outputs.push(output);\r\n    }\r\n\r\n    model.equationConnections.push(outputs);\r\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\r\n    model.equations.push(equation);\r\n  }\r\n\r\n  mapModel() {\r\n    let model = this.model;\r\n    let hiddenLayers = model.hiddenLayers;\r\n    let allMatrices = model.allMatrices;\r\n\r\n    this.createInputMatrix();\r\n    if (!model.input) throw new Error('net.model.input not set');\r\n    allMatrices.push(model.input);\r\n\r\n    this.createHiddenLayers();\r\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\r\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\r\n      let hiddenMatrix = hiddenLayers[i];\r\n      for (let property in hiddenMatrix) {\r\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\r\n        allMatrices.push(hiddenMatrix[property]);\r\n      }\r\n    }\r\n\r\n    this.createOutputMatrix();\r\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\r\n    if (!model.output) throw new Error('net.model.output not set');\r\n\r\n    allMatrices.push(model.outputConnector);\r\n    allMatrices.push(model.output);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]} input\r\n   * @param {Number} [learningRate]\r\n   * @returns {number}\r\n   */\r\n  trainPattern(input, learningRate = null) {\r\n    const error = this.runInput(input);\r\n    this.runBackpropagate(input);\r\n    this.step(learningRate);\r\n    return error;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]} input\r\n   * @returns {number}\r\n   */\r\n  runInput(input) {\r\n    this.runs++;\r\n    let model = this.model;\r\n    let max = input.length;\r\n    let log2ppl = 0;\r\n    let cost = 0;\r\n    let equation;\r\n    while (model.equations.length <= input.length + 1) {//last is zero\r\n      this.bindEquation();\r\n    }\r\n    for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\r\n      // start and end tokens are zeros\r\n      let equationIndex = inputIndex + 1;\r\n      equation = model.equations[equationIndex];\r\n\r\n      let source = (inputIndex === -1 ? 0 : input[inputIndex] + 1); // first step: start with START token\r\n      let target = (inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1); // last step: end with END token\r\n      let output = equation.run(source);\r\n      // set gradients into log probabilities\r\n      let logProbabilities = output; // interpret output as log probabilities\r\n      let probabilities = softmax(output); // compute the softmax probabilities\r\n\r\n      log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing\r\n      cost += -Math.log(probabilities.weights[target]);\r\n      // write gradients into log probabilities\r\n      logProbabilities.deltas = probabilities.weights.slice(0);\r\n      logProbabilities.deltas[target] -= 1;\r\n    }\r\n\r\n    this.totalCost = cost;\r\n    return Math.pow(2, log2ppl / (max - 1));\r\n  }\r\n\r\n  /**\r\n   * @param {Number[]} input\r\n   */\r\n  runBackpropagate(input) {\r\n    let i = input.length;\r\n    let model = this.model;\r\n    let equations = model.equations;\r\n    while(i > 0) {\r\n      equations[i].runBackpropagate(input[i - 1] + 1);\r\n      i--;\r\n    }\r\n    equations[0].runBackpropagate(0);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number} [learningRate]\r\n   */\r\n  step(learningRate = null) {\r\n    // perform parameter update\r\n    //TODO: still not sure if this is ready for learningRate\r\n    let stepSize = this.learningRate;\r\n    let regc = this.regc;\r\n    let clipval = this.clipval;\r\n    let model = this.model;\r\n    let numClipped = 0;\r\n    let numTot = 0;\r\n    let allMatrices = model.allMatrices;\r\n    for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {\r\n      const matrix = allMatrices[matrixIndex];\r\n      const { weights, deltas }  = matrix;\r\n      if (!(matrixIndex in this.stepCache)) {\r\n        this.stepCache[matrixIndex] = zeros(matrix.rows * matrix.columns);\r\n      }\r\n      const cache = this.stepCache[matrixIndex];\r\n      for (let i = 0; i < weights.length; i++) {\r\n        let r = deltas[i];\r\n        let w = weights[i];\r\n        // rmsprop adaptive learning rate\r\n        cache[i] = cache[i] * this.decayRate + (1 - this.decayRate) * r * r;\r\n        // gradient clip\r\n        if (r > clipval) {\r\n          r = clipval;\r\n          numClipped++;\r\n        }\r\n        if (r < -clipval) {\r\n          r = -clipval;\r\n          numClipped++;\r\n        }\r\n        numTot++;\r\n        // update (and regularize)\r\n        weights[i] = w + -stepSize * r / Math.sqrt(cache[i] + this.smoothEps) - regc * w;\r\n      }\r\n    }\r\n    this.ratioClipped = numClipped / numTot;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number[]|*} [rawInput]\r\n   * @param {Number} [maxPredictionLength]\r\n   * @param {Boolean} [isSampleI]\r\n   * @param {Number} temperature\r\n   * @returns {*}\r\n   */\r\n  run(rawInput = [], maxPredictionLength = 100, isSampleI = false, temperature = 1) {\r\n    const input = this.formatDataIn(rawInput);\r\n    const model = this.model;\r\n    const output = [];\r\n    let i = 0;\r\n    while (model.equations.length < maxPredictionLength) {\r\n      this.bindEquation();\r\n    }\r\n    while (true) {\r\n      let previousIndex = (i === 0\r\n        ? 0\r\n        : i < input.length\r\n          ? input[i - 1] + 1\r\n          : output[i - 1])\r\n          ;\r\n      let equation = model.equations[i];\r\n      // sample predicted letter\r\n      let outputMatrix = equation.run(previousIndex);\r\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\r\n      copy(logProbabilities, outputMatrix);\r\n      if (temperature !== 1 && isSampleI) {\r\n        /**\r\n         * scale log probabilities by temperature and re-normalize\r\n         * if temperature is high, logProbabilities will go towards zero\r\n         * and the softmax outputs will be more diffuse. if temperature is\r\n         * very low, the softmax outputs will be more peaky\r\n         */\r\n        for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {\r\n          logProbabilities.weights[j] /= temperature;\r\n        }\r\n      }\r\n\r\n      let probs = softmax(logProbabilities);\r\n      let nextIndex = (isSampleI ? sampleI(probs) : maxI(probs));\r\n\r\n      i++;\r\n      if (nextIndex === 0) {\r\n        // END token predicted, break out\r\n        break;\r\n      }\r\n      if (i >= maxPredictionLength) {\r\n        // something is wrong\r\n        break;\r\n      }\r\n\r\n      output.push(nextIndex);\r\n    }\r\n\r\n    /**\r\n     * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the\r\n     * network what is contained in input, so the data is essentially guessed by the network what could be next, till it\r\n     * locks in on a value.\r\n     * Kind of like this, values are from input:\r\n     * 0 -> 4 (or in English: \"beginning on input\" -> \"I have no idea? I'll guess what they want next!\")\r\n     * 2 -> 2 (oh how interesting, I've narrowed down values...)\r\n     * 1 -> 9 (oh how interesting, I've now know what the values are...)\r\n     * then the output looks like: [4, 2, 9,...]\r\n     * so we then remove the erroneous data to get our true output\r\n     */\r\n    return this.formatDataOut(\r\n      input,\r\n      output\r\n        .slice(input.length)\r\n        .map(value => value - 1)\r\n    );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings\r\n   * @param {Object} [options]\r\n   * @returns {{error: number, iterations: number}}\r\n   */\r\n  train(data, options = {}) {\r\n    options = Object.assign({}, RNN.trainDefaults, options);\r\n    let iterations = options.iterations;\r\n    let errorThresh = options.errorThresh;\r\n    let log = options.log === true ? console.log : options.log;\r\n    let logPeriod = options.logPeriod;\r\n    let learningRate = options.learningRate || this.learningRate;\r\n    let callback = options.callback;\r\n    let callbackPeriod = options.callbackPeriod;\r\n    let error = Infinity;\r\n    let i;\r\n\r\n    if (this.hasOwnProperty('setupData')) {\r\n      data = this.setupData(data);\r\n    }\r\n\r\n    if (!options.keepNetworkIntact) {\r\n      this.initialize();\r\n    }\r\n\r\n    for (i = 0; i < iterations && error > errorThresh; i++) {\r\n      let sum = 0;\r\n      for (let j = 0; j < data.length; j++) {\r\n        let err = this.trainPattern(data[j], learningRate);\r\n        sum += err;\r\n      }\r\n      error = sum / data.length;\r\n\r\n      if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\r\n      if (log && (i % logPeriod == 0)) {\r\n        log('iterations:', i, 'training error:', error);\r\n      }\r\n      if (callback && (i % callbackPeriod == 0)) {\r\n        callback({ error: error, iterations: i });\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      iterations: i\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param data\r\n   * @returns {\r\n   *  {\r\n   *    error: number,\r\n   *    misclasses: Array\r\n   *  }\r\n   * }\r\n   */\r\n  test(data) {\r\n    throw new Error('not yet implemented');\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  toJSON() {\r\n    const defaults = RNN.defaults;\r\n    let model = this.model;\r\n    let options = {};\r\n    for (let p in defaults) {\r\n      options[p] = this[p];\r\n    }\r\n\r\n    return {\r\n      type: this.constructor.name,\r\n      options: options,\r\n      input: model.input.toJSON(),\r\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\r\n        let layers = {};\r\n        for (let p in hiddenLayer) {\r\n          layers[p] = hiddenLayer[p].toJSON();\r\n        }\r\n        return layers;\r\n      }),\r\n      outputConnector: this.model.outputConnector.toJSON(),\r\n      output: this.model.output.toJSON()\r\n    };\r\n  }\r\n\r\n  toJSONString() {\r\n    return JSON.stringify(this.toJSON());\r\n  }\r\n\r\n  fromJSON(json) {\r\n    this.json = json;\r\n    const defaults = RNN.defaults;\r\n    let model = this.model;\r\n    let options = json.options;\r\n    let allMatrices = model.allMatrices;\r\n    model.input = Matrix.fromJSON(json.input);\r\n    allMatrices.push(model.input);\r\n    model.hiddenLayers = json.hiddenLayers.map((hiddenLayer) => {\r\n      let layers = {};\r\n      for (let p in hiddenLayer) {\r\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\r\n        allMatrices.push(layers[p]);\r\n      }\r\n      return layers;\r\n    });\r\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\r\n    model.output = Matrix.fromJSON(json.output);\r\n    allMatrices.push(model.outputConnector);\r\n    allMatrices.push(model.output);\r\n\r\n    for (let p in defaults) {\r\n      if (!defaults.hasOwnProperty(p)) continue;\r\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\r\n    }\r\n\r\n    if (options.hasOwnProperty('dataFormatter') && options.dataFormatter !== null) {\r\n      this.dataFormatter = DataFormatter.fromJSON(options.dataFormatter);\r\n      delete options.dataFormatter;\r\n    }\r\n\r\n    this.bindEquation();\r\n  }\r\n\r\n  fromJSONString(json) {\r\n    return this.fromJSON(JSON.parse(json));\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {Function}\r\n   */\r\n  toFunction() {\r\n    let model = this.model;\r\n    let equations = this.model.equations;\r\n    let equation = equations[1];\r\n    let states = equation.states;\r\n    let jsonString = JSON.stringify(this.toJSON());\r\n\r\n    function matrixOrigin(m, stateIndex) {\r\n      for (let i = 0, max = states.length; i < max; i++) {\r\n        let state = states[i];\r\n\r\n        if (i === stateIndex) {\r\n          let j = previousConnectionIndex(m);\r\n          switch (m) {\r\n            case state.left:\r\n              if (j > -1) {\r\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\r\n              }\r\n            case state.right:\r\n              if (j > -1) {\r\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\r\n              }\r\n            case state.product:\r\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\r\n            default:\r\n              throw Error('unknown state');\r\n          }\r\n        }\r\n\r\n        if (m === state.product) return `states[${ i }].product`;\r\n        if (m === state.right) return `states[${ i }].right`;\r\n        if (m === state.left) return `states[${ i }].left`;\r\n      }\r\n    }\r\n\r\n    function previousConnectionIndex(m) {\r\n      const connection = model.equationConnections[0];\r\n      const states = equations[0].states;\r\n      for (let i = 0, max = states.length; i < max; i++) {\r\n        if (states[i].product === m) {\r\n          return i;\r\n        }\r\n      }\r\n      return connection.indexOf(m);\r\n    }\r\n\r\n    function matrixToString(m, stateIndex) {\r\n      if (!m || !m.rows || !m.columns) return 'null';\r\n\r\n      if (m === model.input) return `json.input`;\r\n      if (m === model.outputConnector) return `json.outputConnector`;\r\n      if (m === model.output) return `json.output`;\r\n\r\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\r\n        let hiddenLayer = model.hiddenLayers[i];\r\n        for (let p in hiddenLayer) {\r\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\r\n          if (hiddenLayer[p] !== m) continue;\r\n          return `json.hiddenLayers[${ i }].${ p }`;\r\n        }\r\n      }\r\n\r\n      return matrixOrigin(m, stateIndex);\r\n    }\r\n\r\n    function toInner(fnString) {\r\n      // crude, but should be sufficient for now\r\n      // function() { body }\r\n      fnString = fnString.toString().split('{');\r\n      fnString.shift();\r\n      // body }\r\n      fnString = fnString.join('{');\r\n      fnString = fnString.split('}');\r\n      fnString.pop();\r\n      // body\r\n      return fnString.join('}').split('\\n').join('\\n        ')\r\n        .replace('product.deltas[i] = 0;', '')\r\n        .replace('product.deltas[column] = 0;', '')\r\n        .replace('left.deltas[leftIndex] = 0;', '')\r\n        .replace('right.deltas[rightIndex] = 0;', '')\r\n        .replace('product.deltas = left.deltas.slice(0);', '');\r\n    }\r\n\r\n    function fileName(fnName) {\r\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\r\n    }\r\n\r\n    let statesRaw = [];\r\n    let usedFunctionNames = {};\r\n    let innerFunctionsSwitch = [];\r\n    for (let i = 0, max = states.length; i < max; i++) {\r\n      let state = states[i];\r\n      statesRaw.push(`states[${ i }] = {\r\n      name: '${ state.forwardFn.name }',\r\n      left: ${ matrixToString(state.left, i) },\r\n      right: ${ matrixToString(state.right, i) },\r\n      product: ${ matrixToString(state.product, i) }\r\n    }`);\r\n\r\n      let fnName = state.forwardFn.name;\r\n      if (!usedFunctionNames[fnName]) {\r\n        usedFunctionNames[fnName] = true;\r\n        innerFunctionsSwitch.push(\r\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\r\n          ${ toInner(state.forwardFn.toString()) }\r\n          break;`\r\n        );\r\n      }\r\n    }\r\n\r\n    return new Function('input', 'maxPredictionLength', 'isSampleI', 'temperature', `\r\n  if (typeof input === 'undefined') input = [];\r\n  if (typeof maxPredictionLength === 'undefined') maxPredictionLength = 100;\r\n  if (typeof isSampleI === 'undefined') isSampleI = false;\r\n  if (typeof temperature === 'undefined') temperature = 1;\r\n  \r\n  ${\r\n      (this.dataFormatter !== null && typeof this.formatDataIn === 'function')\r\n        ? 'input = formatDataIn(input);' \r\n        : ''\r\n    }\r\n        \r\n  var json = ${ jsonString };\r\n  var _i = 0;\r\n  var output = [];\r\n  var states = [];\r\n  var prevStates;\r\n  while (true) {\r\n    var previousIndex = (_i === 0\r\n        ? 0\r\n        : _i < input.length\r\n          ? input[_i - 1] + 1\r\n          : output[_i - 1])\r\n          ;\r\n    var rowPluckIndex = previousIndex;\r\n    prevStates = states;\r\n    states = [];\r\n    ${ statesRaw.join(';\\n    ') };\r\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\r\n      var state = states[stateIndex];\r\n      var product = state.product;\r\n      var left = state.left;\r\n      var right = state.right;\r\n      \r\n      switch (state.name) {\r\n${ innerFunctionsSwitch.join('\\n') }\r\n      }\r\n    }\r\n    \r\n    var logProbabilities = state.product;\r\n    if (temperature !== 1 && isSampleI) {\r\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\r\n        logProbabilities.weights[q] /= temperature;\r\n      }\r\n    }\r\n\r\n    var probs = softmax(logProbabilities);\r\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\r\n    \r\n    _i++;\r\n    if (nextIndex === 0) {\r\n      break;\r\n    }\r\n    if (_i >= maxPredictionLength) {\r\n      break;\r\n    }\r\n\r\n    output.push(nextIndex);\r\n  }\r\n  ${ (this.dataFormatter !== null && typeof this.formatDataOut === 'function') \r\n      ? 'return formatDataOut(output.slice(input.length).map(function(value) { return value - 1; }))'\r\n      : 'return output.slice(input.length).map(function(value) { return value - 1; })' };\r\n  \r\n  function Matrix(rows, columns) {\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n    this.weights = zeros(rows * columns);\r\n  }\r\n  ${ this.dataFormatter !== null && typeof this.formatDataIn === 'function'\r\n      ? `function formatDataIn(input, output) { ${ toInner(this.formatDataIn.toString()).replace('this.dataFormatter', 'json.options.dataFormatter') } }`\r\n      : '' }\r\n  ${ this.dataFormatter !== null && typeof this.formatDataOut === 'function'\r\n        ? `function formatDataOut(output) { ${ toInner(this.formatDataIn.toString()).replace('this.dataFormatter', 'json.options.dataFormatter') } }` \r\n        : '' }\r\n  ${ (this.dataFormatter !== null) ? this.dataFormatter.toFunctionString('json.options.dataFormatter') : '' }\r\n  ${ zeros.toString() }\r\n  ${ softmax.toString().replace('_2.default', 'Matrix') }\r\n  ${ randomF.toString() }\r\n  ${ sampleI.toString() }\r\n  ${ maxI.toString() }`)\r\n  }\r\n}\r\n\r\nRNN.defaults = {\r\n  inputSize: 20,\r\n  inputRange: 20,\r\n  hiddenSizes:[20,20],\r\n  outputSize: 20,\r\n  learningRate: 0.01,\r\n  decayRate: 0.999,\r\n  smoothEps: 1e-8,\r\n  regc: 0.000001,\r\n  clipval: 5,\r\n  json: null,\r\n  /**\r\n   *\r\n   * @param {*[]} data\r\n   * @returns {Number[]}\r\n   */\r\n  setupData: function(data) {\r\n    if (\r\n      typeof data[0] !== 'string'\r\n      && !Array.isArray(data[0])\r\n      && (\r\n        !data[0].hasOwnProperty('input')\r\n        || !data[0].hasOwnProperty('output')\r\n      )\r\n    ) {\r\n      return data;\r\n    }\r\n    let values = [];\r\n    const result = [];\r\n    if (typeof data[0] === 'string' || Array.isArray(data[0])) {\r\n      if (this.dataFormatter === null) {\r\n        for (let i = 0; i < data.length; i++) {\r\n          values.push(data[i]);\r\n        }\r\n        this.dataFormatter = new DataFormatter(values);\r\n      }\r\n      for (let i = 0, max = data.length; i < max; i++) {\r\n        result.push(this.formatDataIn(data[i]));\r\n      }\r\n    } else {\r\n      if (this.dataFormatter === null) {\r\n        for (let i = 0; i < data.length; i++) {\r\n          values.push(data[i].input);\r\n          values.push(data[i].output);\r\n        }\r\n        this.dataFormatter = DataFormatter.fromArrayInputOutput(values);\r\n      }\r\n      for (let i = 0, max = data.length; i < max; i++) {\r\n        result.push(this.formatDataIn(data[i].input, data[i].output));\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n  /**\r\n   *\r\n   * @param {*[]} input\r\n   * @param {*[]} output\r\n   * @returns {Number[]}\r\n   */\r\n  formatDataIn: function(input, output = null) {\r\n    if (this.dataFormatter !== null) {\r\n      if (this.dataFormatter.indexTable.hasOwnProperty('stop-input')) {\r\n        return this.dataFormatter.toIndexesInputOutput(input, output);\r\n      } else {\r\n        return this.dataFormatter.toIndexes(input);\r\n      }\r\n    }\r\n    return input;\r\n  },\r\n  /**\r\n   *\r\n   * @param {Number[]} input\r\n   * @param {Number[]} output\r\n   * @returns {*}\r\n   */\r\n  formatDataOut: function(input, output) {\r\n    if (this.dataFormatter !== null) {\r\n      return this.dataFormatter\r\n        .toCharacters(output)\r\n        .join('');\r\n    }\r\n    return output;\r\n  },\r\n  dataFormatter: null\r\n};\r\n\r\nRNN.trainDefaults = {\r\n  iterations: 20000,\r\n  errorThresh: 0.005,\r\n  log: false,\r\n  logPeriod: 10,\r\n  learningRate: 0.3,\r\n  callback: null,\r\n  callbackPeriod: 10,\r\n  keepNetworkIntact: false\r\n};"]}