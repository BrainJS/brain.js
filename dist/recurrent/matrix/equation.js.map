{"version":3,"sources":["../../../src/recurrent/matrix/equation.js"],"names":["Equation","inputRow","states","left","right","weights","length","Error","product","rows","columns","push","forwardFn","backpropagationFn","m","add","allOnes","cloneNegative","self","iForward","iBackpropagate","rowIndex","state","i","max","hasOwnProperty"],"mappings":"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","file":"equation.js","sourcesContent":["import Matrix from './';\r\nimport OnesMatrix from './ones-matrix';\r\nimport copy from './copy';\r\nimport cloneNegative from './clone-negative';\r\nimport add from './add';\r\nimport addB from './add-b';\r\nimport allOnes from './all-ones';\r\nimport multiply from './multiply';\r\nimport multiplyB from './multiply-b';\r\nimport multiplyElement from './multiply-element';\r\nimport multiplyElementB from './multiply-element-b';\r\nimport relu from './relu';\r\nimport reluB from './relu-b';\r\nimport rowPluck from './row-pluck';\r\nimport rowPluckB from './row-pluck-b';\r\nimport sigmoid from './sigmoid';\r\nimport sigmoidB from './sigmoid-b';\r\nimport tanh from './tanh';\r\nimport tanhB from './tanh-b';\r\n\r\nexport default class Equation {\r\n  constructor() {\r\n    this.inputRow = 0;\r\n    this.states = [];\r\n  }\r\n\r\n  /**\r\n   * connects two matrices together by add\r\n   * @param {Matrix} left\r\n   * @param {Matrix} right\r\n   * @returns {Matrix}\r\n   */\r\n  add(left, right) {\r\n    if (left.weights.length !== right.weights.length) {\r\n      throw new Error('misaligned matrices');\r\n    }\r\n    let product = new Matrix(left.rows, left.columns);\r\n    this.states.push({\r\n      left: left,\r\n      right: right,\r\n      product: product,\r\n      forwardFn: add,\r\n      backpropagationFn: addB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number} rows\r\n   * @param {Number} columns\r\n   * @returns {Matrix}\r\n   */\r\n  allOnes(rows, columns) {\r\n    let product = new Matrix(rows, columns);\r\n    this.states.push({\r\n      left: product,\r\n      product: product,\r\n      forwardFn: allOnes\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Matrix} m\r\n   * @returns {Matrix}\r\n   */\r\n  cloneNegative(m) {\r\n    let product = new Matrix(m.rows, m.columns);\r\n    this.states.push({\r\n      left: m,\r\n      product: product,\r\n      forwardFn: cloneNegative\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects two matrices together by subtract\r\n   * @param {Matrix} left\r\n   * @param {Matrix} right\r\n   * @returns {Matrix}\r\n   */\r\n  subtract(left, right) {\r\n    if (left.weights.length !== right.weights.length) {\r\n      throw new Error('misaligned matrices');\r\n    }\r\n    return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);\r\n  }\r\n\r\n  /**\r\n   * connects two matrices together by multiply\r\n   * @param {Matrix} left\r\n   * @param {Matrix} right\r\n   * @returns {Matrix}\r\n   */\r\n  multiply(left, right) {\r\n    if (left.columns !== right.rows) {\r\n      throw new Error('misaligned matrices');\r\n    }\r\n    let product = new Matrix(left.rows, right.columns);\r\n    this.states.push({\r\n      left: left,\r\n      right: right,\r\n      product: product,\r\n      forwardFn: multiply,\r\n      backpropagationFn: multiplyB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects two matrices together by multiplyElement\r\n   * @param {Matrix} left\r\n   * @param {Matrix} right\r\n   * @returns {Matrix}\r\n   */\r\n  multiplyElement(left, right) {\r\n    if (left.weights.length !== right.weights.length) {\r\n      throw new Error('misaligned matrices');\r\n    }\r\n    let product = new Matrix(left.rows, left.columns);\r\n    this.states.push({\r\n      left: left,\r\n      right: right,\r\n      product: product,\r\n      forwardFn: multiplyElement,\r\n      backpropagationFn: multiplyElementB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects a matrix to relu\r\n   * @param {Matrix} m\r\n   * @returns {Matrix}\r\n   */\r\n  relu(m) {\r\n    let product = new Matrix(m.rows, m.columns);\r\n    this.states.push({\r\n      left: m,\r\n      product: product,\r\n      forwardFn: relu,\r\n      backpropagationFn: reluB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects a matrix via a row\r\n   * @param {Matrix} m\r\n   * @returns {Matrix}\r\n   */\r\n  inputMatrixToRow(m) {\r\n    let self = this;\r\n    let product = new Matrix(m.columns, 1);\r\n    this.states.push({\r\n      left: m,\r\n      get right () {\r\n        return self.inputRow;\r\n      },\r\n      product: product,\r\n      forwardFn: rowPluck,\r\n      backpropagationFn: rowPluckB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects a matrix to sigmoid\r\n   * @param {Matrix} m\r\n   * @returns {Matrix}\r\n   */\r\n  sigmoid(m) {\r\n    let product = new Matrix(m.rows, m.columns);\r\n    this.states.push({\r\n      left: m,\r\n      product: product,\r\n      forwardFn: sigmoid,\r\n      backpropagationFn: sigmoidB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   * connects a matrix to tanh\r\n   * @param {Matrix} m\r\n   * @returns {Matrix}\r\n   */\r\n  tanh(m) {\r\n    let product = new Matrix(m.rows, m.columns);\r\n    this.states.push({\r\n      left: m,\r\n      product: product,\r\n      forwardFn: tanh,\r\n      backpropagationFn: tanhB\r\n    });\r\n    return product;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param m\r\n   * @returns {Matrix}\r\n   */\r\n  observe(m) {\r\n    let iForward = 0;\r\n    let iBackpropagate = 0;\r\n    this.states.push({\r\n      forwardFn: function() {\r\n        iForward++;\r\n      },\r\n      backpropagationFn: function() {\r\n        iBackpropagate++;\r\n      }\r\n    });\r\n    return m;\r\n  }\r\n\r\n  /**\r\n   * @patam {Number} [rowIndex]\r\n   * @output {Matrix}\r\n   */\r\n  run(rowIndex = 0) {\r\n    this.inputRow = rowIndex;\r\n    let state;\r\n    for (let i = 0, max = this.states.length; i < max; i++) {\r\n      state = this.states[i];\r\n      if (!state.hasOwnProperty('forwardFn')) {\r\n        continue;\r\n      }\r\n      state.forwardFn(state.product, state.left, state.right);\r\n    }\r\n\r\n    return state.product;\r\n  }\r\n\r\n  /**\r\n   * @patam {Number} [rowIndex]\r\n   * @output {Matrix}\r\n   */\r\n  runBackpropagate(rowIndex = 0) {\r\n    this.inputRow = rowIndex;\r\n\r\n    let i = this.states.length;\r\n    let state;\r\n    while (i-- > 0) {\r\n      state = this.states[i];\r\n      if (!state.hasOwnProperty('backpropagationFn')) {\r\n        continue;\r\n      }\r\n      state.backpropagationFn(state.product, state.left, state.right);\r\n    }\r\n\r\n    return state.product;\r\n  }\r\n}\r\n"]}